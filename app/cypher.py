class Cypher:
	def __init__(self):
		pass
	# user procedures
	allowed_emails = (
		' MATCH '
		'	(e: Emails) '
		' RETURN '
		'	e.allowed '
	)
	user_allowed_emails = (
		' MATCH '
		'	(u:User) '
		' WITH '
		'	COLLECT (DISTINCT u.email) as registered_emails '
		' MATCH '
		'	(user:User {'
		'		username_lower : toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(e: Emails) '
		' RETURN '
		'	FILTER (n in e.allowed WHERE NOT n in registered_emails) as user_allowed '
	)
	email_find = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' RETURN '
		'	user '
	)
	confirm_email = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' SET '
		'	user.confirmed = true '
	)
	user_find = (
		' MATCH '
		'	(user: User) '
		'		WHERE '
		'			user.username_lower = toLower($username) '
		'		OR '
		'			user.email = toLower(trim($email)) '
		' RETURN '
		'	user '
	)
	username_find = (
		' MATCH '
		'	(user: User { '
		'		username_lower: toLower($username)'
		'	}) '
		' RETURN '
		'	user '
	)
	user_affiliations = (
		' MATCH '
		'	(u: User { '
		'		username_lower: toLower($username) '
		'	}) '
		'	-[a: AFFILIATED]->(p: Partner) '
		' OPTIONAL MATCH '
		'	(p)<-[: AFFILIATED {admin: true}]-(admin: User) '
		' RETURN '
		'	p.name , '
		'	p.fullname , '
		'	a.confirmed as confirmed, '
		'	a.data_shared as data_shared , '
		'	admin.email as admin_email'
	)
	add_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		}), '
		'		(p:Partner { '
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	MERGE '
		'		(u)-[a: AFFILIATED { '
		'			data_shared: false, '
		'			admin: false, '
		'			confirm_timestamp: [], '
		'			confirmed: false '
		' 		}]->(p) '
		' 	ON CREATE SET '
		'		a.add_timestamp = timestamp() '
		' 	RETURN '
		'		p.name '
	)
	remove_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		 }) '
		'		-[a:AFFILIATED { '
		'			data_shared: false '
		'		}]->(p: Partner {'
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	WHERE '
		'		size(a.confirm_timestamp) = 0 '
		' 	DELETE '
		'		a '
		' 	RETURN p.name '
	)
	password_reset = (
		' MATCH '
		'	(user: User { '
		'		email : toLower(trim($email)) '
		' 	}) '
		' SET user.password = $password '
	)
	user_register = (
		# This is a little cautious using merge to prevent overwriting a user profile if it is called in error
		' MATCH '
		'	(partner:Partner {'
		'		name_lower: toLower(trim($partner)) '
		'	}) '
		' MERGE '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	ON CREATE SET '
		'		user.username = trim($username), '
		'		user.password = $password, ' 
		'		user.email = toLower(trim($email)), '
		'		user.name = $name, '
		'		user.time = timestamp(), '
		'		user.access = ["user"], '
		'		user.confirmed = false, '
		'		user.found = false '
		'	ON MATCH SET '
		'		user.found = TRUE '
		' WITH '
		'	user, partner '	
		' WHERE '
		'	user.found = false '
		' CREATE '
		'	(user)-[r: AFFILIATED { '
		'		data_shared: true, '
		'		confirmed: false, '
		'		confirm_timestamp: [], '
		'		admin: false '				
		'	}]->(partner), '
		'	(user)-[: SUBMITTED]->(sub: Submissions), '
		'		(sub)-[: SUBMITTED]->(: Emails {allowed :[]}),'
		'		(sub)-[: SUBMITTED]->(: Partners), '
		'		(sub)-[: SUBMITTED]->(: Traits), '
		'		(sub)-[: SUBMITTED]->(: Trials), '
		'		(sub)-[: SUBMITTED]->(locations: Locations), '
		'			(locations)-[: SUBMITTED]->(: Countries), '
		'			(locations)-[: SUBMITTED]->(: Regions), '
		'			(locations)-[: SUBMITTED]->(: Farms), '
		'			(locations)-[: SUBMITTED]->(: Plots), '
		'		(sub)-[:SUBMITTED]->(traits:Traits), '
		'			(traits)-[: SUBMITTED]->(: FarmTraits), '
		'			(traits)-[: SUBMITTED]->(: PlotTraits), '
		'			(traits)-[: SUBMITTED]->(: BlockTraits), '
		'			(traits)-[: SUBMITTED]->(: TreeTraits), '
		'			(traits)-[: SUBMITTED]->(: BranchTraits), '
		'			(traits)-[: SUBMITTED]->(: LeafTraits), '
		'			(traits)-[: SUBMITTED]->(: SampleTraits), '
		'		(sub)-[:SUBMITTED]->(varieties:Varieties), '
		'			(varieties)-[: SUBMITTED]->(: Hybrids), '
		'			(varieties)-[: SUBMITTED]->(: Inbreds), '
		'			(varieties)-[: SUBMITTED]->(: Grafts), '
		'		(sub)-[:SUBMITTED]->(descriptors: SampleDescriptors), '
		'			(descriptors)-[: SUBMITTED]->(: Tissues), '
		'			(descriptors)-[: SUBMITTED]->(: StorageMethods), '
		'		(sub)-[:SUBMITTED]->(items: Items), '
		'			(items)-[: SUBMITTED]->(: Blocks), '
		'			(items)-[: SUBMITTED]->(: Trees), '
		'			(items)-[: SUBMITTED]->(: Branches), '
		'			(items)-[: SUBMITTED]->(: Leaves), '
		'			(items)-[: SUBMITTED]->(: Samples), '
		'		(sub)-[:SUBMITTED]->(data: DataSub), '
		'			(data)-[: SUBMITTED]->(: FieldBook),'
		'			(data)-[: SUBMITTED]->(: TableCSV) '
	)
	add_allowed_email = (
		' MATCH '
		'	(all: Emails) '
		' WITH '
		'	all.allowed as allowed_emails '
		' UNWIND '
		'	allowed_emails as email '
		' WITH '
		'	COLLECT(DISTINCT email) as set '
		' WHERE '
		'	NOT toLower(trim($email)) IN set '
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' SET e.allowed = e.allowed + [toLower(trim($email))] '
		' RETURN toLower(trim($email)) '
	)
	remove_allowed_email = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' SET e.allowed = FILTER (n in e.allowed WHERE NOT n IN toLower(trim($email))) '
		' RETURN toLower(trim($email)) '
	)
	user_del = (
		' MATCH '
		'	(u:User { '
		'		email: toLower(trim($email)), '
		'		confirmed: false '
		'	}) '
		' OPTIONAL MATCH '
		'	(u)-[:SUBMITTED*..3]->(n) '
		' DETACH DELETE '
		' u,n '
	)
	partner_admin_users = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: AFFILIATED { '
		'		admin: true '
		'	}]->(p:Partner) '
		' WITH p '
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) ' 
		' RETURN { '
		'	Username: u.username, '
		'	Email: u.email, '
		'	Name: u.name, '
		'	Partner: p.name, '
		'	PartnerFullName: p.fullname, '
		'	Confirmed: a.confirmed '
		' } '
	)
	global_admin_users = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.confirmed '
		' } '
	)
	# these functions toggle the confirmed status so do both confirm/un-confirm operations
	partner_confirm_users = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:AFFILIATED {admin : true}]->(p:Partner) '
		' WHERE '
		'	"partner_admin" in user.access'
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(confirm["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(confirm["username"])) '
		' 	SET '
		'		a.confirmed = NOT a.confirmed, '
		'		a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' 	RETURN u.name '
	)
	global_confirm_users = ( 
		' MATCH '
		'	(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' WITH '
		'	p,a,u '
		' WHERE '
		'	p.name_lower = toLower(trim(confirm["partner"])) '
		' AND '
		'	u.username_lower = toLower(trim(confirm["username"])) '
		' SET '
		'	a.confirmed = NOT a.confirmed, '
		'	a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' RETURN u.name '
	)
	partner_admins = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.admin '
		' } '
	)
	confirm_admins = (
		' MATCH '
		'		(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $admins as admin '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(admin["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(admin["username"])) '
		' 	SET '
		'		a.admin = NOT a.admin '
		' 	RETURN '
		'		u.name '
	)
	# LOCATION PROCEDURES
	# country procedures
	country_find = (
		' MATCH '
		'	(country:Country { '
		'		name_lower : toLower(trim($country))'
		' 	}) '
		' RETURN '
		'	country '
	)
	country_add = (
		' MATCH \n'
		'	(: User  {\n'
		'		username_lower: toLower(trim($username)) \n'
		' 	}) \n'
		'	-[: SUBMITTED]->(: Submissions) \n'
		'	-[: SUBMITTED]->(: Locations) \n'
		'	-[: SUBMITTED]->(c: Countries) \n'
		' MERGE \n'
		'	(c)-[s: SUBMITTED]->(country: Country { \n'
		'		name_lower: toLower(trim($country)) \n'
		' 	}) \n'
		'	ON CREATE SET \n'
		'		country.name = trim($country), \n'
		'	 	s.time = timestamp() \n'
		' RETURN country.name \n'
	)
	# region procedures
	region_find = (
		' MATCH '
		'	(:Country { '
		'		name_lower : toLower(trim($country)) '
		' 	}) '
		'	<-[:IS_IN]-(region:Region { '
		'		name_lower: toLower(trim($region)) '
		' 	}) '
		' RETURN region '
	)
	region_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Locations) '
		'	-[:SUBMITTED]->(r: Regions), ' 
		'	(c:Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' MERGE '
		'	(region:Region { '
		'		name_lower: toLower(trim($region)) '
		' 	}) '
		'	-[:IS_IN]->(c) '
		'	ON CREATE SET '
		'		region.name = trim($region) '
		' MERGE '
		'	(r)-[s: SUBMITTED]->(region) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN '
		'	region.name '
	)
	get_farms = (
		' MATCH '
		'	(f: Farm) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' RETURN properties (f) '
	)
	farm_find = (
		' MATCH '
		'	(farm: Farm { '
		'		name_lower: toLower(trim($farm)) '
		' 	}) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' RETURN farm '
	)
	farm_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(f: Farms), ' 
		'	(r: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country {name_lower: toLower(trim($country))}) '
		' MERGE '
		'	(farm: Farm { '
		'		name_lower: toLower(trim($farm)) '
		' 	}) '
		' 	-[:IS_IN]->(r) '
		'	ON CREATE SET '
		'		farm.name = trim($farm) '
		' MERGE '
		'	(f)-[s:SUBMITTED]->(farm) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN farm.name '
	)
	# plot procedures
	get_plots = (
		' MATCH '
		'	(p:Plot) '
		'	-[:IS_IN]->(:Farm {name_lower: toLower(trim($farm))}) '
		'	-[:IS_IN]->(:Region {name_lower: toLower(trim($region))}) '
		'	-[:IS_IN]->(:Country {name_lower: toLower(trim($country))}) '
		' RETURN '
		'	properties (p) '
	)
	plot_find = (
		' MATCH '
		'	(plot:Plot {name_lower: toLower(trim($plot))}) '
		' 	-[:IS_IN]->(:Farm { name: toLower(trim($farm))}) ' 
		' 	-[:IS_IN]->(:Region { name: toLower(trim($region))}) '
		' 	-[:IS_IN]->(:Country { name: toLower(trim($country))}) '
		' RETURN '
		'	plot '
	)
	# for autoincrement:
	# https://stackoverflow.com/questions/32040409/reliable-autoincrementing-identifiers-for-all-nodes-relationships-in-neo4j
	# for lock:
	# this allows the increment counter (allowing for concurrent transactions to be serialised):
	# http://neo4j.com/docs/stable/transactions-isolation.html
	# https://stackoverflow.com/questions/35138645/how-to-perform-an-atomic-update-on-relationship-properties-with-py2neo
	# https://stackoverflow.com/questions/31798311/write-lock-behavior-in-neo4j-cypher-over-transational-rest-ap
	plot_id_lock = (
		' MATCH '
		'	(id: Counter { '
		'		name: "plot" '
		' 	}) '
		' SET '
		'	id._LOCK_ = true '
	)
	plot_add = (
		' MATCH '
		'	(:User { '
		'		username_lower:toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(p: Plots), '
		'	(f: Farm { '
		'		name_lower: toLower(trim($farm)) '
		'	}) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower($region) }) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower($country) '
		' 	}),  '
		'	(id: Counter { '
		'		name: "plot" '
		'	}) '
		' SET '
		'	id.count = id.count + 1 '
		' MERGE '
		'	(plot: Plot: Item { '
		'		name_lower:toLower(trim(($plot))) '
		' 	}) '
		'	-[:IS_IN]->(f) '
		' 	ON CREATE SET '
		' 		plot.name = trim($plot), '
		'		plot.uid = id.count '
		# Create the plot level counters and container nodes for sub-levels
		' MERGE '
		'	(block_counter: Counter { '
		'		name: "block", '
		'		uid: (toString(id.count) + "_block") '
		'	}) '
		'	-[: FOR]->(: PlotBlocks)-[: IS_IN]->(plot) '
		'	ON CREATE SET '
		'		block_counter.count = 0 '
		' MERGE '
		'	(tree_counter: Counter { '
		'		name: "tree", '
		'		uid: (toString(id.count) + "_tree") '
		'	}) '
		'	-[: FOR]->(: PlotTrees)-[: IS_IN]->(plot) '
		'	ON CREATE SET '
		'		tree_counter.count = 0 '
		' MERGE '
		'	(branch_counter: Counter { '
		'		name: "branch", '
		'		uid: (toString(id.count) + "_branch") '
		'	}) '
		'	-[:FOR]->(: PlotBranches)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		branch_counter.count = 0 '
		' MERGE '
		'	(leaf_counter: Counter { '
		'		name: "leaf", '
		'		uid: (toString(id.count) + "_leaf") '
		'	}) '
		'	-[:FOR]->(: PlotLeaves)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		leaf_counter.count = 0 '
		' MERGE '
		'	(sample_counter: Counter { '
		'		name: "sample", '
		'		uid: (toString(id.count) + "_sample") '
		'	}) '
		'	-[:FOR]->(: PlotSamples)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		sample_counter.count = 0 '
		# track time and user
		' MERGE '
		'	(p)-[s:SUBMITTED]->(plot) '
		'	ON CREATE SET '
		'		s.time = timestamp() '
		' MERGE '
		'	(id)-[: COUNTED]->(plot) '
		' SET id._LOCK_ = false' 
		' RETURN { '
		'	uid: plot.uid,'
		'	name:plot.name '
		' } '
	)
	# ITEM PROCEDURES
	# have unique plotID so don't need other location details
	id_lock = (
		' MATCH '
		'	(id:Counter { '
		'		name: $level, '
		'		uid: ($plotID + "_" + $level ) '
		'	}) '
		' SET '
		'	id._LOCK_ = true '
		' RETURN { '
		'	lock : id._LOCK_, '
		'	uid : id.uid '
		' } '
	)
	# a lock for separate BlockTree counters (store the count of trees per block only, not used to generate IDs)
	block_id_lock = (
		' MATCH '
		'	(id:Counter { '
		'		name: $level, '
		'		uid: ($blockUID + "_" + $level ) '
		'	}) '
		' SET '
		'	id._LOCK_ = true '
		' RETURN { '
		'	lock : id._LOCK_, '
		'	uid : id.uid '
		' } '
	)
	get_blocks = (
		' MATCH '
		'	(b:Block) '
		'	-[:IS_IN]->(:PlotBlocks) '
		'	-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		' RETURN properties (b) '
	)
	block_find = (
		' MATCH '
		'	(block:Block { '
		'		name : $block'
		'	}) '
		'	-[:IS_IN]->(:PlotBlocks) '
		'	-[:IS_IN]->(:Plot { '
		'		uid : toInteger($plotID) '
		'	}) '
		' RETURN '
		'	block '
	)
	block_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(b:Blocks), '
		'	(id:Counter { '
		'		uid: ($plotID + "_block") '
		'	}) '
		'	-[:FOR]->(pb: PlotBlocks) '
		'	-[:IS_IN]->(p:Plot) '
		' SET id.count = id.count+1 '
		' MERGE '
		'	(block: Block: Item { '
		'		name_lower: toLower(trim($block)), '
		'		uid:($plotID + "_B" + id.count), '
		'		id:id.count '
		'	}) '
		'	-[:IS_IN]->(pb) '
		' 	ON CREATE SET '
		'		block.name = trim($block) '
		' MERGE '
		'	(b)-[s:SUBMITTED]->(block) '
		'	ON CREATE SET '
		'		s.time = timestamp() '
		# Create BlockTrees container node and counter
		' MERGE '
		'	(block_tree_counter: Counter { '
		'		name: "tree", '
		'		uid: (block.uid + "_tree") '
		'	}) '
		'	-[:FOR]->(: BlockTrees)-[:IS_IN]->(block) '
		'	ON CREATE SET '
		'		block_tree_counter.count = 0 '
		' SET id._LOCK_ = false '
		' RETURN { '
		'	uid: block.uid, '
		'	name: block.name '
		' } '
	)
	get_blocks_details = (
		' MATCH '
		'	(b: Block) '
		'	-[:IS_IN]->(: PlotBlocks) '
		'	-[:IS_IN]->(p: Plot { '
		'		uid : toInteger($plotID)'
		'	}) '
		'	-[:IS_IN]->(f: Farm) '
		'	-[:IS_IN]->(r: Region) '
		'	-[:IS_IN]->(c: Country) '
		' RETURN { '
		'	UID : b.uid, '
		'	PlotID : p.uid, '
		'	BlockID : b.id, '
		'	Block : b.name, '
		'	Plot : p.name, '
		'	Farm : f.name, '
		'	Region : r.name, '
		'	Country : c.name '
		' } '
		' ORDER BY b.id '
	)
	# tree procedures
	trees_add = (
		# Start with users tree submissions node (UserTrees)
		# and the plots tree container (PlotTrees)
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ut:Trees), '
		'	(pt:PlotTrees)-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		# create per user per plot trees node (UserPlotTrees) linking these
		' MERGE '
		'	(ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		# keep the PlotTrees and UserPlotTrees nodes
		' WITH '
		'	pt, upt'
		# find the id counter node (plot tree counter)
		' MATCH '
		'	(id:Counter { '
		'		uid: ($plotID + "_tree") '
		'	}) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter ' 
		' 	SET '
		'		id.count = id.count + 1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		' 	CREATE '
		'		(t: Tree: Item { '
		'			uid: ($plotID + "_T" + id.count), '
		'			id: id.count, '
		'			custom_id: "", '
		'			variety: "" '
		'		}) '
		'		-[:IS_IN]->(pt) '
		'	CREATE '
		'		(upt)-[: SUBMITTED {time: timestamp()}]->(t) '
		# unlock the counter
		'	SET '
		'		id._LOCK_ = false '
		# and return a table of IDs
		'	RETURN '
		'		count (t)'
	)
	trees_add_block = (
		# Start with users tree submissions node (UserTrees)
		# and the plots tree container (PlotTrees)
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ut:Trees), '
		'	(pt:PlotTrees)-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}), '
		'	(bt:BlockTrees)-[:IS_IN]->(:Block { '
		'		uid: $blockUID '
		'	}) '
		# create per user per plot trees node (UserPlotTrees) linking these
		' MERGE '
		'	(ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		# keep the PlotTrees and UserPlotTrees nodes
		' WITH '
		'	pt, upt, bt'
		# find the id counter node (plot tree counter)
		' MATCH '
		'	(id:Counter {uid: ($plotID + "_tree")}), '
		# and the block counter node
		'	(bc:Counter {uid: ($blockUID + "_tree")}) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter '
		'	SET '
		'		id.count = id.count + 1, '
		'		bc.count = bc.count + 1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		'	CREATE '
		'		(t: Tree: Item { '
		'			uid: ($plotID + "_T" + id.count), '
		'			id: id.count, '
		'			custom_id: "", '
		'			variety: "" '
		'		}) '
		'		-[:IS_IN]->(pt), '
		'		(upt)-[:SUBMITTED { '
		'			time:timestamp() '
		'		}]->(t), '
		# link to block trees (record when it was added to this block and by who)
		'		(t)-[:IS_IN { '
		'			current: True, '
		'			time: timestamp(), '
		'			user: trim($username), '
		'			from: "web_form" '
		'		}]->(bt) '
		# unlock the counter
		'	SET '
		'		id._LOCK_ = false '
		'	RETURN '
		'		count(t) '
	)
	trees_get = (
		' MATCH '
		'	(tree: Tree) '
		'	-[:IS_IN]->(pt: PlotTrees) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid : toInteger($plotID) '
		'	}) '
		'	-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		# filter by range of tree ID's
		' WHERE '
		'	tree.id >= $start '
		' AND '
		'	tree.id <= $end '
		# find blocks if registered
		' OPTIONAL MATCH '
		'	(tree) '
		'	-[is_in:IS_IN]->(: BlockTrees) '
		' WITH '
		'	tree, '
		'	max(is_in.time) as newest_block_time, ' 
		'	plot.name as plot, '
		'	plot.uid as plot_id, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' OPTIONAL MATCH '
		'	(tree)-[is_in:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block)'
		'	WHERE is_in.time = newest_block_time '
		' RETURN { '
		'	UID: tree.uid, '
		'	Country: country, '
		'	Region: region, '
		'	Farm: farm, '
		'	Plot: plot, '		
		'	PlotID: plot_id, '
		'	Block: block.name, '
		'	BlockID: block.id, '
		'	TreeID: tree.id, '
		'	Variety: tree.variety, '
		' 	TreeCustomID: tree.custom_id '
		' } '
		' ORDER BY tree.id '
	)
	treecount = (
		' MATCH '
		'	(tc: Counter { '
		'		uid: ($plotid + "_tree") '
		'	}) '
		' RETURN '
		'	tc.count '
	)
	# branch procedures
	branches_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User {'
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ub:Branches), '
		# and both the PlotBranches and branch id counter nodes
		'	(t:Tree) '
		'	-[:IS_IN]->(:PlotTrees)'
		'	-[:IS_IN]->(p:Plot { '
		'		uid:toInteger($plotID) '
		'	}) '
		'	<-[:FROM_PLOT]-(pb:PlotBranches) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: ($plotID + "_branch") '
		'	}), '
		'	(p)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		' WHERE '
		'	t.id >= toInteger($start) '
		' AND '
		'	t.id <= toInteger($end) '
		# find block if registered
		' OPTIONAL MATCH (t) '
		'	-[is_in:IS_IN]->(:BlockTrees) '
		# create links for context TreeBranches and PlotBranches
		' MERGE '
		'	(tb:TreeBranches)-[:FROM_TREE]->(t) '
		' MERGE '
		'	(tb)-[:FROM_PLOT]->(pb)'
		# per UserBranches per PlotBranches for tracking
		' MERGE '
		'	(ub)-[:SUBMITTED]->(upb:UserPlotBranches)-[:CONTRIBUTED]->(pb) '
		# per UserPlotBranches per TreeBranches for tracking
		' MERGE '
		'	(upb)-[:SUBMITTED]->(utb:UserTreeBranches)-[:CONTRIBUTED]->(tb) '
		' WITH '
		'	t, id, tb, utb, '
		'	max(is_in.time) as newest_block_time, '
		'	p.uid as plot_id, '
		'	p.name as plot, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' ORDER BY '
		'	t.id '
		' OPTIONAL MATCH '
		'	(t)-[is_in:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block)'
		'	WHERE is_in.time = newest_block_time '
		# create new branch ids
		' UNWIND range(1, $replicates) as replicates '
		'	SET id.count = id.count + 1 '
		'	CREATE '
		'		(r:Branch: Item { '
		'			uid: (plot_id + "_R" + id.count), '
		'			id: id.count, '
		'			tree: t.id, '
		'			replicates: $replicates '
		'		}) '
		# link branch to TreeBranches
		'	CREATE '
		'		(r)-[:FROM_TREE]->(tb) '
		# link UserTreeBranches to branch with timestamp for submission
		'	CREATE '
		'		(utb)-[:SUBMITTED { '
		'			time : timestamp() '
		'		}]->(r) '
		# unlock the id counter node
		'	SET '
		'		id._LOCK_ = false '
		# return the list of ID's created
		'	RETURN { '
		'		UID : r.uid, '
		'		Country : country, '
		'		Region : region, '
		'		Farm : farm, '
		'		Plot: plot, '
		'		PlotID : plot_id, '
		'		Block: block.name, '
		'		BlockID: block.id, '
		'		TreeID : t.id, '
		'		TreeCustomID : t.custom_id, '
		'		Variety: t.variety, '
		'		BranchID : r.id  '
		'	} '
	)
	branches_get = (
		' MATCH '
		'	(branch:Branch) '
		'	-[:FROM_TREE]->(tb:TreeBranches) '
		'	-[:FROM_TREE]->(tree:Tree) '
		'	-[:IS_IN]->(pt:PlotTrees) '
		'	-[:IS_IN]->(plot:Plot {uid : toInteger($plotID)}) '
		'	-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		# filter by range of tree ID's
		' WHERE tree.id >= $trees_start '
		' AND tree.id <= $trees_end '
		' AND branch.id >= $branches_start '
		' AND branch.id <= $branches_end '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree)-[is_in: IS_IN]->(:BlockTrees) '
		' WITH '
		'	branch.uid as uid, '
		'	branch.id as branch_id, '
		'	tree, '
		'	max(is_in.time) as newest_block_time, '
		'	plot.name as plot, '
		'	plot.uid as plot_id, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' OPTIONAL MATCH '
		'	(tree)-[is_in: IS_IN]->(:BlockTrees) '
		'	-[: IS_IN]->(block: Block) '
		'	WHERE is_in.time = newest_block_time '
		' RETURN { '
		'	UID: uid, '
		'	Country: country, '
		'	Region: region, '
		'	Farm: farm, '
		'	Plot: plot, '
		'	PlotID: plot_id, ' 
		'	Block: block.name, '
		'	BlockID: block.id, '
		'	TreeID: tree.id, '
		'	TreeCustomID: tree.custom_id, '
		'	Variety: tree.variety, '
		'	BranchID: branch_id '		
		' } '
		' ORDER BY '
		'	branch_id '
	)
	# leaf procedures
	leaves_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(ul: Leaves), '
		# and both the PlotBranches and branch id counter nodes
		'	(t:Tree) '
		'	-[:IS_IN]->(: PlotTrees)'
		'	-[:IS_IN]->(p: Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		'	<-[:FROM_PLOT]-(pl: PlotLeaves) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: ($plotID + "_leaf")'
		'	}) '
		' WHERE t.id >= toInteger($start) '
		' AND t.id <= toInteger($end) '
		' MATCH '
		'	(p)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# find block if registered
		' OPTIONAL MATCH '
		'	(t)-[is_in: IS_IN]->(: BlockTrees) '
		# Create links for context TreeLeaves and PlotLeaves
		' MERGE (tl:TreeLeaves)-[:FROM_TREE]->(t) '
		' MERGE (tl)-[:FROM_PLOT]->(pl) '
		# per UserLeaves per PlotLeaves for tracking
		' MERGE (ul)-[:SUBMITTED]->(upl: UserPlotLeaves)-[:CONTRIBUTED]->(pl) '
		# per UserPlotLeaves per TreeLeaves for tracking
		' MERGE (upl)-[:SUBMITTED]->(utl: UserTreeLeaves)-[:CONTRIBUTED]->(tl) '
		# create leaf ID's
		' WITH '
		'	t, id, tl, utl, '
		'	max(is_in.time) as newest_block_time, '
		'	p.uid as plot_id, '
		'	p.name as plot,'
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' ORDER BY t.id '
		' OPTIONAL MATCH '
		'	(t)-[is_in:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block)'
		'	WHERE is_in.time = newest_block_time '
		' UNWIND range(1, toInteger($replicates)) as replicates '
		'	SET '
		'		id.count = id.count + 1 '
		'	CREATE '
		'		(l: Leaf: Item { '
		'			uid: (plot_id + "_L" + id.count), '
		'			id: id.count, '
		'			tree: t.id, '
		'			replicates: $replicates '
		'		}), '
		# link leaf to TreeLeaves
		'		(l)-[:FROM_TREE]->(tl), '
		# link UserTreeLeaves to branch with timestamp for submission
		'		(utl)-[:SUBMITTED {time: timestamp()}]->(l) '
		# unlock the id counter node
		'	SET id._LOCK_ = false '
		# return the list of ID's created
		'	RETURN { '
		'		UID: l.uid, '
		'		Country: country, '
		'		Region: region, '
		'		Farm: farm, '
		'		Plot: plot, '
		'		PlotID: plot_id, '
		'		Block: block.name, '
		'		BlockID: block.id, '
		'		TreeID: t.id, '
		'		TreeCustomID: t.custom_id, '
		'		Variety: t.variety, '
		'		LeafID: l.id  '
		'	} '
	)
	leaves_get = (
		' MATCH '
		'	(leaf: Leaf) '
		'	-[:FROM_TREE]-(tl: TreeLeaves) '
		'	-[:FROM_TREE]-(tree: Tree) '
		'	-[:IS_IN]->(pt: PlotTrees) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid : toInteger($plotID) '
		' }) '
		'	-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# filter by ranges of ID's
		' WHERE tree.id >= $trees_start '
		' AND tree.id <= $trees_end '
		' AND leaf.id >= $leaves_start '
		' AND leaf.id <= $leaves_end '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree) '
		'	-[is_in:IS_IN]->(: BlockTrees) '
		# and a branch if the leaf has been assigned to a branchID
		' OPTIONAL MATCH (leaf) '
		'	-[:FROM_BRANCH {current: True}]->(branch: Branch) '
		' WITH '
		'	leaf.uid as uid, '
		'	leaf.id as leaf_id, '
		'	branch.id as branch_id, '
		'	tree, '
		'	max(is_in.time) as newest_block_time, '
		'	plot.name as plot, '
		'	plot.uid as plot_id, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' OPTIONAL MATCH '
		'	(tree)-[is_in:IS_IN]->(:BlockTrees) '
		'	-[:IS_IN]->(block: Block) '
		'	WHERE is_in.time = newest_block_time '
		# and return
		' RETURN { '
		' 	UID: uid, '
		' 	Country: country, '
		' 	Region: region, '
		' 	Farm: farm, '
		' 	Plot: plot, '
		' 	PlotID: plot_id, ' 
		' 	Block: block.name, '
		' 	BlockID: block.id, '
		' 	TreeID: tree.id, '
		' 	TreeCustomID: tree.custom_id, '
		' 	Variety: tree.variety, '
		' 	BranchID: branch_id, '
		' 	LeafID: leaf_id '
		' } '
		' ORDER BY '
		'	leaf_id '
	)
	# sample procedures
	# not sure if good idea for users to add these, maybe restrict to admins
	tissue_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: SampleDescriptors) '
		'	-[:SUBMITTED]->(tissues: Tissues) '
		' MERGE '
		'	(tissue:Tissue { '
		'		name_lower: toLower(trim($tissue)) '
		'	}) '
		'	ON CREATE SET '
		'		tissue.name = trim($tissue) '
		' MERGE '
		'	(tissues)-[s:SUBMITTED]->(tissue)'		
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN '
		'	tissue '
	)
	storage_add = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: SampleDescriptors) '
		'	-[:SUBMITTED]->(sm: StorageMethods) '
		' MERGE '
		'	(storage:Storage { '
		'		name_lower: toLower(trim($storage))}) '
		'	ON CREATE SET '
		'		storage.name = trim($storage) '
		' MERGE '
		'	(sm)-[s:SUBMITTED]->(storage) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN storage '
	)
	samples_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username))}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(samples: Samples), '
		'	(t:Tree) '
		'	-[:IS_IN]->(: PlotTrees) '
		'	-[:IS_IN]->(: Plot { '
		'		uid: toInteger($plotID) '
		'	}), '
		'	(tissue:Tissue { '
		'		name_lower: toLower(trim($tissue)) '
		'	}), '
		'	(storage:Storage { '
		'		name_lower: toLower(trim($storage)) '
		'	}), '
		'	(id:Counter { '
		'		uid: ($plotID + "_sample") '
		'	}) '
		'	-[:FOR]->(ps: PlotSamples) '
		'	-[:FROM_PLOT]->(p: Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		'	-[:IS_IN]->(f: Farm) '
		'	-[:IS_IN]->(r: Region) '
		'	-[:IS_IN]->(c: Country) '
		' WHERE '
		'	t.id >= $start '
		' AND '
		'	t.id <= $end '
		# with the selected trees to be sampled
		' WITH '
		'	t, tissue, storage, samples, id, ps, p, f, r, c '
		' ORDER BY '
		'	t.id '
		# get block name if available
		' OPTIONAL MATCH '
		'	(t) '
		'	-[is_in:IS_IN]->(: BlockTrees) '
		# Merge a per Tissue per Storage container node
		' MERGE '
		'	(tissue)<-[: OF_TISSUE]-(TiSt: TissueStorage)-[:STORED_IN]->(storage) '
		# And split this off per PlotSamples
		' MERGE '
		'	(TiSt)<-[: COLLECTED_AS]-(pts: PlotTissueStorage)-[: FROM_PLOT]->(ps) '
		# Create a TreeSamples node per tree
		' MERGE '
		'	(t)<-[:FROM_TREE]-(ts:TreeSamples) '
		# Track user submissions through successive UserPlotSamples then UserTreeSamples container nodes
		' MERGE '
		'	(samples)-[:SUBMITTED]->(ups:UserPlotSamples)-[:CONTRIBUTED]->(ps) '
		' MERGE '
		'	(ups)-[:SUBMITTED]->(uts:UserTreeSamples)-[:CONTRIBUTED]->(ts) '
		' WITH '
		'	id, '
		'	ts, '
		'	pts, '
		'	uts, '
		'	max(is_in.time) as newest_block_time, '
		'	t, '
		'	tissue.name as tissue, '
		'	storage.name as storage, '
		'	b.name as block, '
		'	p.name as plot, '
		'	p.uid as plot_uid, '
		'	f.name as farm, '
		'	r.name as region, '
		'	c.name as country '
		' OPTIONAL MATCH '
		'	(t)-[is_in:IS_IN]->(:BlockTrees) '
		'	-[:IS_IN]->(block: Block) '
		'	WHERE is_in.time = newest_block_time '
		# with replicates
		' UNWIND '
		'	range(1, $replicates) as replicates '
		# incrementing with a plot level counter
		'	SET '
		'		id.count = id.count + 1 '
		# Create samples
		'	CREATE '
		'		(s: Sample: Item { '
		'			uid: (plot_uid + "_S" + id.count), '
		'			id: id.count, '
		'			tree: tree_id, '
		# '			date: $date, '
		# '			time: $time, '
		'			replicates: $replicates '
		'		}) '
		# Link the sample to its TreeSamples
		'	MERGE '
		'		(s)-[: FROM_TREE]->(ts) '
		# and the PlotTissueStorage container
		'	MERGE '
		'		(s)-[: FROM_PLOT]->(pts) '
		# and user tracking through UserTreeSamples
		'	MERGE  '
		'		(uts)-[s1:SUBMITTED]->(s) '
		'		ON CREATE SET s1.time = timestamp() '
		'	SET '
		'		id._LOCK_ = false '
		# return for csv
		'	RETURN { '
		'		UID : s.uid, '
		'		PlotID : plot_uid, '
		'		TreeID : tree_id, '
		'		TreeCustomID : tree_custom_id, '
		'		Variety: tree_variety, '
		'		SampleID : s.id, '
		'		Date : s.date, '
		'		Tissue : tissue, '
		'		Storage : storage, '
		'		Block : block, '
		'		Plot : plot, '
		'		Farm : farm, '
		'		Region : region, '
		'		Country : country '
		'	} '
		'	ORDER BY s.id '
		)
	# Upload procedures
	upload_check_value = (
		# make sure that all the entries match accepted entries
		# handles empty items and white space
		# forces strings to lower case and float/integer types
		# removes % symbols
		# ! ensure to declare trait (as node) and value (from file) before including
		' CASE '
		'	WHEN trait.format = "multicat" '
		'		THEN CASE '
		'			WHEN size(FILTER (n in split(value, ":") WHERE size(n) > 0)) '
		'				= size(FILTER (n in split(value, ":") WHERE toLower(trim(n)) in '
		'					extract(item in trait.category_list | toLower(item)))) '
		'			THEN extract(i in FILTER (n in split(value, ":") WHERE  size(n) > 0 )| trim(i)) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "categorical" '
		'		THEN CASE '
		'			WHEN toLower(trim(value)) in extract(item in trait.category_list | toLower(item)) '
		'				THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "text" '
		'		THEN CASE '
		'			WHEN trait.name_lower = "variety" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "el frances code" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "synthetic fertiliser n:p:k ratio" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 3 '
		'					AND toFloat(trim(split(value, ":")[0])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[1])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[2])) IS NOT NULL '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name contains "time" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 2 '
		'					AND size(split(value, ":")[0]) <= 2 '
		'					AND toInteger(trim(split(value, ":")[0])) <=24 '
		'					AND toInteger(trim(split(value, ":")[0])) >= 0 '
		'					AND size(split(value, ":")[1]) <= 2 '
		'					AND toInteger(trim(split(value, ":")[1])) < 60 '
		'					AND toInteger(trim(split(value, ":")[1])) >= 0 '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			ELSE '
		'				toString(value) '
		'			END '
		'	WHEN trait.format = "percent" '
		'		THEN CASE '
		'			WHEN toFloat(replace(value, "%", "")) IS NOT NULL '
		'				THEN toFloat(replace(value, "%", "")) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "counter" '
		'		THEN CASE '
		'			WHEN toInteger(value) IS NOT NULL '
		'				THEN toInteger(value) '
		'			ELSE '
		'				Null '
		'			END '
		'	WHEN trait.format = "numeric" '
		'		THEN CASE '
		'			WHEN toFloat(value) IS NOT NULL '
		'				THEN toFloat(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "boolean" '
		'		THEN CASE '
		'			WHEN value in ["yes","y"] '
		'				THEN True '
		'			WHEN value in ["no","n"] '
		'				THEN False '
		'			WHEN toBoolean(value) IS NOT NULL '
		'				THEN toBoolean(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "location" '
		'		THEN CASE '
		'			WHEN size(split(value, ";")) = 2 '
		'			AND toFloat(trim(split(value, ";")[0])) IS NOT NULL '
		'			AND toFloat(trim(split(value, ";")[1])) IS NOT NULL '
		'				THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "date" '
		'		THEN CASE '
		'			WHEN size(split(value, "-")) = 3 '
		'			AND size(trim(split(value, "-")[0])) = 4 '
		'			AND size(trim(split(value, "-")[1])) <= 2 '
		'			AND size(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) <= 12 '
		'			AND size(trim(split(value, "-")[2])) <= 2 '
		'			AND size(trim(split(value, "-")[2])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) <= 31 '
		'			THEN '
		'				apoc.date.parse(value,"ms","yyyy-MM-dd HH:mm:sszzz") '
		'			ELSE '
		'				Null '
		'			END '
		'	ELSE Null '
		'	END '
	)
	# generic upload to handle mixed UID (multiple levels) in csv in database format
	upload_fb = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	trim(csvLine.location) as location, '
		'	trim(csvLine.person) as person, '
		'	trim(toUpper(csvLine.uid)) as uid, '
		'	toLower(trim(csvLine.trait)) as trait_name_lower, '
		'	apoc.date.parse(csvLine.timestamp, "ms", "yyyy-MM-dd HH:mm:sszzz") as time, '
		'	trim(csvLine.value) as value '
		# Identify the items and traits assessed
		' MATCH '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					uid '
		'				END '
		'	}), '
		'	(trait: Trait { '
		'		name_lower: trait_name_lower, '
		'		level: '
		'			CASE '
		'				WHEN split(uid, "_")[1] IS NULL '
		'					THEN "plot" '
		'				WHEN left(split(uid, "_")[1],1) = "B" '
		'					THEN "block" '
		'				WHEN left(split(uid, "_")[1],1) = "T" '
		'					THEN "tree" '
		'				WHEN left(split(uid, "_")[1],1) = "R" '
		'					THEN "branch" '
		'				WHEN left(split(uid, "_")[1],1) = "L" '
		'					THEN "leaf" '
		'				WHEN left(split(uid, "_")[1],1) = "S" '
		'					THEN "sample" '
		'				END '
		'	}) '
		'	WHERE size(value) > 0 '
		# these optional matches are used in FOREACH CASE statements 
		# to create Plot or Tree item trait containers where appropriate
		' OPTIONAL MATCH '
		'	(item)-[:IS_IN*2]->(plot_item_plot:Plot) '
		' OPTIONAL MATCH '
		'	(item)-[:FROM_TREE*2]->(tree_item_tree:Tree) '
		'	-[:IS_IN*2]->(tree_item_plot:Plot) '
		' WITH '
		'	item, trait, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	uid, location, person, time, '
		'	value '
		' FOREACH (n in CASE '
		'	WHEN trait.level = "plot" '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(item)<-[: FOR_ITEM]-()-[: FOR_TRAIT]->(trait) '
		' ) '
		' FOREACH (n in CASE '
		'	WHEN trait.level in ["block","tree"] '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(plot_item_plot)<-[: FROM_PLOT]-(pt)-[: FOR_TRAIT]->(trait) '
		'			MERGE '
		'				(item)<-[: FOR_ITEM]-()-[: FOR_TRAIT]->(pt) '
		' ) '
		' FOREACH (n in CASE '
		'	WHEN trait.level in ["branch","leaf","sample"] '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(tree_item_plot)<-[: FROM_PLOT]-(pt)-[: FOR_TRAIT]->(trait) '
		'			MERGE '
		'				(tree_item_tree)<-[:FROM_TREE]-(tt)-[: FOR_TRAIT]->(pt) '
		'			MERGE '
		'				(item)<-[:FOR_ITEM]-()-[: FOR_TRAIT]->(pt) '
		' ) '
		# get rid of some of the optional matches since they are no longer needed
		' WITH item, trait, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, location, time, value '
		# get the user submission tracking nodes
		' MATCH '
		'	(:User { '
		'		username_lower : toLower(trim($username))'
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: DataSub) '
		'	-[: SUBMITTED]->(fb: FieldBook), '
		'	(item)<-[ :FOR_ITEM]-(it)-[ :FOR_TRAIT*..3]->(trait) '
		# Optional matches so can modify relationships depending on level
		' OPTIONAL MATCH '
		'	(item)-[is_in_block:IS_IN {current: True}]->( :BlockTrees)<-[:FOR]-(current_block_counter:Counter) '
		# for branch and leaf assignment find current
		' OPTIONAL MATCH '
		'	(item)-[from_branch_current: FROM_BRANCH {current: True}]->(:Branch) '
		# without this below with statement there is a database error that I could not diagnose 
		# it appears to be due to the many OPTIONAL MATCH statements
		' WITH '
		'	item, trait, plot_item_plot, tree_item_tree, tree_item_plot, '
		'	fb, it, current_block_counter, from_branch_current, is_in_block, '
		'	person, location, time, value '
		' OPTIONAL MATCH '
		'	(branch_update: Branch)-[: FROM_TREE*2]->(tree_item_tree) WHERE branch_update.id = toInteger(value) '
		' OPTIONAL MATCH '
		'	(item)-[from_leaf_current:FROM_LEAF]->(:Leaf) WHERE from_leaf_current.current = True '
		' OPTIONAL MATCH '
		'	(leaf_update:Leaf)-[:FROM_TREE*2]->(tree_item_tree) WHERE leaf_update.id = toInteger(value) '
		# for variety, find current assignment and the variety that matches the new data
		' OPTIONAL MATCH '
		'	(tree)-[is_variety: IS_VARIETY]->()-[:IS_VARIETY]->(variety:Variety) WHERE is_variety.current = True '
		' OPTIONAL MATCH '
		'	(variety_update:Variety {name_lower: toLower(value)}) '
		# Merge the data point to ensure unique to the time and item/trait node
		' MERGE '
		'	(d:Data { '
		'		time : time '
		'	}) '
		'	-[:DATA_FOR]->(it) '
		'	ON MATCH SET '
		'		d.found = True '
		'	ON CREATE SET '
		'		d.found = False, '
		'		d.location = location, '
		'		d.person = person, '
		'		d.value = ' + upload_check_value +
		# track user submissions through /User/Trait container
		' MERGE '
		'	(fb)-[:SUBMITTED]->(ut) '
		'	-[:CONTRIBUTED]->(trait) '
		# then /UserTrait/ItemTrait container
		' MERGE '
		'	(ut)-[:SUBMITTED]->(uit) '
		'	-[:CONTRIBUTED]->(it) '
		# then finally the data with a timestamp
		' MERGE '
		'	(uit)-[s1:SUBMITTED]->(d) '
		'	ON CREATE SET '
		'		s1.time = timestamp() '
		# Now update "special" trait values
		# if block data 
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree"'
		'	AND trait.name = "assign to block" '
		'		THEN [1] ELSE [] END | '
		# create block and a BlockTrees and BlockTreeCounter node
		'			MERGE '
		'				(block_counter: Counter { '
		'					uid: (plot_item_plot.uid + "_block") '
		'				}) '
		'				-[: FOR]->(pb: PlotBlocks) '
		'				-[: IS_IN]->(plot_item_plot) '
		'			MERGE (block: Block { '
		'				name_lower: toLower(d.value) '
		'				}) '
		'				-[:IS_IN]->(pb) '
		'				ON CREATE SET '
		'					block_counter.count = block_counter.count + 1, '
		'					block.uid = (plot_item_plot.uid + "_B" + block_counter.count), '
		'					block.id = block_counter.count, '
		'					block.name = d.value '
		'			MERGE '
		'				(block_tree_counter: Counter { '
		'					name: "tree", '
		'					uid: (block.uid + "_tree") '
		'				}) '
		'				-[: FOR]->(bt: BlockTrees) '
		'				-[: IS_IN]->(block) '
		'				ON CREATE SET '
		'					block_tree_counter.count = 0 '
		# link tree to block (and track number in block with counter)
		'			MERGE '
		'				(tree)-[s1:IS_IN]->(bt) '
		# remove current flag from OPTIONAL MATCHED IS_IN block 
		# track the block submission to the user
		'			SET '
		'				is_in_block.current = False, '
		'				current_block_counter.count = current_block_counter.count - 1, '
		'				s1.current = True, '
		'				block_tree_counter.count = block_tree_counter.count + 1, '
		'				s1.from = CASE WHEN s1.from IS NULL THEN "upload" ELSE [s1.from] + "upload" END, '
		'				s1.time = CASE WHEN s1.time IS NULL THEN timestamp() ELSE [s1.time] + timestamp() END, '
		'				s1.user = CASE WHEN s1.user IS NULL THEN trim($username) ELSE [s1.user] + trim($username) END '
		'			MERGE '
		'				(submissions)-[: SUBMITTED]->(: Items) '
		'				-[: SUBMITTED]->(blocks: Blocks) '
		'				-[s2: SUBMITTED]->(block) '
		'				ON CREATE SET '
		'					block_tree_counter.count = block_tree_counter.count + 1, '
		'					s2.time = timestamp(), '
		'					s2.user = trim($username), '
		'					s2.from = "upload" '
		' ) '
		# if variety trait create link tree to variety. 
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower = "variety" '
		'	AND d.value IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'			MERGE '
		'				(plot_item_plot)<-[: FROM_PLOT]-(pv) '
		'				-[: IS_VARIETY]->(variety_update) '
		'			MERGE '
		'				(tree)-[is_variety_merge: IS_VARIETY]->(pv) '
		'			SET '
		'				is_variety.current = False, '
		'				is_variety_merge.current = True, '
		'				is_variety_merge.time = CASE '
		'					WHEN is_variety_merge.time IS NULL '
		'					THEN timestamp() '
		'					ELSE [is_variety_merge.time] + timestamp()'
		'					END, '
		'				is_variety_merge.user = CASE '
		'					WHEN is_variety_merge.user IS NULL '
		'					THEN trim($username) '
		'					ELSE [is_variety_merge.user] + trim($username)'
		'					END, '
		# also set the tree variety property
		'				tree.variety = variety_update.name '
		' ) '
		# if El frances Code variety trait then create link to variety.
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower = "el frances code" '
		'	AND d.value IS NOT NULL '
		'	THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'		MERGE '
		'			(plot_item_plot)<-[: FROM_PLOT]-(pv) '
		'			-[: IS_VARIETY]->(variety_update) '
		'		MERGE '
		'			(tree)-[is_variety_merge: IS_VARIETY]->(pv) '
		'		SET '
		'			tree.variety = variety_update.name, '
		'			is_variety.current = False, '
		'			is_variety_merge.current = True, '
		'			is_variety_merge.time = CASE '
		'				WHEN is_variety_merge.time IS NULL '
		'				THEN timestamp() '
		'				ELSE [is_variety_merge.time] + timestamp()'
		'				END, '
		'			is_variety_merge.user = CASE '
		'				WHEN is_variety_merge.user IS NULL '
		'				THEN trim($username) '
		'				ELSE [is_variety_merge.user] + trim($username)'
		'				END '
		# also set the tree variety property
		' ) '
		# if trait is branch id then link to branch
		' FOREACH (n IN CASE '
		'	WHEN trait.level in ["leaf","sample"] '
		'	AND trait.name_lower = "assign to branch" '
		'	THEN [1] ELSE [] END | '
		'		MERGE '
		'			(item)-[from_branch_merge:FROM_BRANCH]->(branch_update) '
		'		SET  '
		'			from_branch_current.current = False,  '
		'			from_branch_merge.current = True,  '
		'			from_branch_merge.time = CASE  '
		'				WHEN from_branch_merge.time IS NULL '
		'				THEN timestamp()  '
		'				ELSE [from_branch_merge.time] + timestamp() '
		'				END, '
		'			from_branch_merge.user = CASE  '
		'				WHEN from_branch_merge.user IS NULL '
		'				THEN trim($username)  '
		'				ELSE [from_branch_merge.user] + trim($username) '
		'				END '
		' ) '
		# if trait is leaf id then link to leaf
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "sample" '
		'	AND trait.name_lower = "assign to leaf" '
		'	THEN [1] ELSE [] END | '
		'		MERGE '
		'			(item)-[from_leaf_merge:FROM_LEAF]->(leaf_update) '
		'		SET '
		'			from_leaf_current.current = False, '
		'			from_leaf_merge.current = True, '
		'			from_leaf_merge.time = CASE '
		'				WHEN from_leaf_merge.time IS NULL'
		'				THEN timestamp() '
		'				ELSE [from_leaf_merge.time] + timestamp() '
		'				END, '
		'			from_leaf_merge.user = CASE '
		'				WHEN from_leaf_merge.user IS NULL'
		'				THEN trim($username) '
		'				ELSE [from_leaf_merge.user] + trim($username) '
		'				END'
		' ) '
		# And give the user feedback on their submission success
		' RETURN '
		'	d.found '
		)
	# Upload Table procedures
	upload_table = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine, '
		'	trim(toUpper(csvLine.uid)) as uid, '
		'	apoc.date.parse( '
		'		CASE '
		'			WHEN size(split(csvLine.date, "-")) = 3 '
		'			AND size(split(csvLine.date, "-")[0]) = 4 '
		'			AND size(split(csvLine.date, "-")[1]) <=2 '
		'			AND size(split(csvLine.date, "-")[1]) >=1 '
		'			AND toInteger(trim(split(csvLine.date, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(csvLine.date, "-")[1])) <= 12 '
		'			AND size(split(csvLine.date, "-")[2]) <=2 '
		'			AND size(split(csvLine.date, "-")[2]) >=1 '
		'			AND toInteger(trim(split(csvLine.date, "-")[2])) >= 1 '
		'			AND toInteger(trim(split(csvLine.date, "-")[2])) <= 31 '
		'			THEN '
		'				trim(csvLine.date) '
		'			ELSE '
		'				Null '
		'			END '
		'		+ " " + '
		'		CASE '
		'			WHEN size(split(csvLine.time, ":")) = 2 '
		'			AND size(split(csvLine.time, ":")[0]) <= 2 '
		'			AND toInteger(trim(split(csvLine.time, ":")[0])) <=24 '
		'			AND toInteger(trim(split(csvLine.time, ":")[0])) >= 0'
		'			AND size(split(csvLine.time, ":")[1]) <= 2 '
		'			AND toInteger(trim(split(csvLine.time, ":")[1])) <=24 '
		'			AND toInteger(trim(split(csvLine.time, ":")[1])) >=0 '
		'			THEN '
		'				trim(csvLine.time) '
		'			ELSE '
		'				"00:00" '
		'			END '
		'		, "ms", "yyyy-MM-dd HH:mm") as time, '
		'	trim(csvLine.person) as person '
		# And identify the plots and traits assessed
		' MATCH  '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					toUpper(uid) '
		'				END '
		'	}) '
		' UNWIND $traits as trait_name '
		'	MATCH '
		'		(trait: Trait { '
		'			name_lower: toLower(trait_name), '
		'			level: '
		'				CASE '
		'					WHEN split(uid, "_")[1] IS NULL '
		'						THEN "plot" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "B" '
		'						THEN "block" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "T" '
		'						THEN "tree" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "R" '
		'						THEN "branch" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "L" '
		'						THEN "leaf" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "S" '
		'						THEN "sample" '
		'					END '
		'		}) '
		# Check for data in table
		# all load_csv values are string so can just check size after trimming whitespace  
		'	WHERE size(csvLine[trait_name]) > 0 '
		'	OPTIONAL MATCH '
		'		(item)-[:IS_IN*2]->(plot_item_plot:Plot) '
		'	OPTIONAL MATCH '
		'		(item)-[:FROM_TREE*2]->(tree_item_tree:Tree) '
		'		-[:IS_IN*2]->(tree_item_plot:Plot) '
		'	WITH '
		'		item, trait, ' 
		'		plot_item_plot, tree_item_tree, tree_item_plot, '
		'		person, time, '
		'		csvLine[trait_name] as value '
		'	FOREACH (n in CASE '
		'		WHEN trait.level = "plot" '
		'			THEN [1] ELSE [] END | '
		'				MERGE '
		'					(item)<-[: FOR_ITEM]-()-[: FOR_TRAIT]->(trait) '
		'	) '
		'	FOREACH (n in CASE '
		'		WHEN trait.level in ["block","tree"] '
		'			THEN [1] ELSE [] END | '
		'				MERGE '
		'					(plot_item_plot)<-[: FROM_PLOT]-(pt)-[: FOR_TRAIT]->(trait) '
		'				MERGE '
		'					(item)<-[: FOR_ITEM]-()-[: FOR_TRAIT]->(pt) '
		'	) '
		'	FOREACH (n in CASE '
		'		WHEN trait.level in ["branch","leaf","sample"] '
		'			THEN [1] ELSE [] END | '
		'				MERGE '
		'					(tree_item_plot)<-[: FROM_PLOT]-(pt)-[: FOR_TRAIT]->(trait) '
		'				MERGE '
		'					(tree_item_tree)<-[:FROM_TREE]-(tt)-[: FOR_TRAIT]->(pt) '
		'				MERGE '
		'					(item)<-[:FOR_ITEM]-()-[: FOR_TRAIT]->(pt) '
		'	) '
		# get rid of some of the optional matches since they are no longer needed
		'	WITH '
		'		item, trait, '
		'		plot_item_plot, tree_item_tree, tree_item_plot, '
		'		person, time, value '
		'	MATCH '
		'		(:User { '
		'			username_lower : toLower(trim($username))'
		'		}) '
		'		-[: SUBMITTED]->(: Submissions) '
		'		-[: SUBMITTED]->(: DataSub) '
		'		-[: SUBMITTED]->(fb: FieldBook), '
		'		(item)<-[ :FOR_ITEM]-(it)-[ :FOR_TRAIT*..3]->(trait) '
		# Optional matches so can modify relationships depending on level
		'	OPTIONAL MATCH '
		'		(item)-[is_in_block:IS_IN {current: True}]->( :BlockTrees)<-[:FOR]-(current_block_counter:Counter) '
		# for branch and leaf assignment find current
		'	OPTIONAL MATCH '
		'		(item)-[from_branch_current: FROM_BRANCH {current: True}]->(:Branch) '
		# without this below with statement there is a database error that I could not diagnose 
		# it appears to be due to the many OPTIONAL MATCH statements
		'	WITH '
		'		item, trait, plot_item_plot, tree_item_tree, tree_item_plot, '
		'		fb, it, current_block_counter, from_branch_current, is_in_block, '
		'		person, time, value '
		'	OPTIONAL MATCH '
		'		(branch_update: Branch)-[: FROM_TREE*2]->(tree_item_tree) WHERE branch_update.id = toInteger(value) '
		'	OPTIONAL MATCH '
		'		(item)-[from_leaf_current:FROM_LEAF]->(:Leaf) WHERE from_leaf_current.current = True '
		'	OPTIONAL MATCH '
		'		(leaf_update:Leaf)-[:FROM_TREE*2]->(tree_item_tree) WHERE leaf_update.id = toInteger(value) '
		# for variety, find current assignment and the variety that matches the new data
		'	OPTIONAL MATCH '
		'		(tree)-[is_variety: IS_VARIETY]->()-[:IS_VARIETY]->(variety:Variety) WHERE is_variety.current = True '
		'	OPTIONAL MATCH '
		'		(variety_update:Variety {name_lower: toLower(value)}) '
		# Merge the data point linking to the Plot/PlotTrait node
		'	MERGE '
		'		(d:Data { '
		'			time: time '
		'		}) '
		'		-[:DATA_FOR]->(it) '
		'		ON MATCH SET '
		'			d.found = True '
		'		ON CREATE SET '
		'			d.found = False, '
		'			d.person = person, '
		'			d.value = ' + upload_check_value +
		# track user submissions through /User/Trait container
		' MERGE '
		'	(fb)-[:SUBMITTED]->(ut) '
		'	-[:CONTRIBUTED]->(trait) '
		# then /UserTrait/ItemTrait container
		' MERGE '
		'	(ut)-[:SUBMITTED]->(uit) '
		'	-[:CONTRIBUTED]->(it) '
		# then finally the data with a timestamp
		' MERGE '
		'	(uit)-[s1:SUBMITTED]->(d) '
		'	ON CREATE SET '
		'		s1.time = timestamp() '
		# Now update "special" trait values
		# if block data 
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree"'
		'	AND trait.name = "assign to block" '
		'		THEN [1] ELSE [] END | '
		# create block and a BlockTrees and BlockTreeCounter node
		'			MERGE '
		'				(block_counter: Counter { '
		'					uid: (plot_item_plot.uid + "_block") '
		'				}) '
		'				-[: FOR]->(pb: PlotBlocks) '
		'				-[: IS_IN]->(plot_item_plot) '
		'			MERGE (block: Block { '
		'				name_lower: toLower(d.value) '
		'				}) '
		'				-[:IS_IN]->(pb) '
		'				ON CREATE SET '
		'					block_counter.count = block_counter.count + 1, '
		'					block.uid = (plot_item_plot.uid + "_B" + block_counter.count), '
		'					block.id = block_counter.count, '
		'					block.name = d.value '
		'			MERGE '
		'				(block_tree_counter: Counter { '
		'					name: "tree", '
		'					uid: (block.uid + "_tree") '
		'				}) '
		'				-[: FOR]->(bt: BlockTrees) '
		'				-[: IS_IN]->(block) '
		'				ON CREATE SET '
		'					block_tree_counter.count = 0 '
		# link tree to block (and track number in block with counter)
		'			MERGE '
		'				(tree)-[s1:IS_IN]->(bt) '
		# remove current flag from OPTIONAL MATCHED IS_IN block 
		# track the block submission to the user
		'			SET '
		'				is_in_block.current = False, '
		'				current_block_counter.count = current_block_counter.count - 1, '
		'				s1.current = True, '
		'				block_tree_counter.count = block_tree_counter.count + 1, '
		'				s1.from = CASE WHEN s1.from IS NULL THEN "upload" ELSE [s1.from] + "upload" END, '
		'				s1.time = CASE WHEN s1.time IS NULL THEN timestamp() ELSE [s1.time] + timestamp() END, '
		'				s1.user = CASE WHEN s1.user IS NULL THEN trim($username) ELSE [s1.user] + trim($username) END '
		'			MERGE '
		'				(submissions)-[: SUBMITTED]->(: Items) '
		'				-[: SUBMITTED]->(blocks: Blocks) '
		'				-[s2: SUBMITTED]->(block) '
		'				ON CREATE SET '
		'					block_tree_counter.count = block_tree_counter.count + 1, '
		'					s2.time = timestamp(), '
		'					s2.user = trim($username), '
		'					s2.from = "upload" '
		' ) '
		# if variety trait create link tree to variety. 
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower = "variety" '
		'	AND d.value IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'			MERGE '
		'				(plot_item_plot)<-[: FROM_PLOT]-(pv) '
		'				-[: IS_VARIETY]->(variety_update) '
		'			MERGE '
		'				(tree)-[is_variety_merge: IS_VARIETY]->(pv) '
		'			SET '
		'				is_variety.current = False, '
		'				is_variety_merge.current = True, '
		'				is_variety_merge.time = CASE '
		'					WHEN is_variety_merge.time IS NULL '
		'					THEN timestamp() '
		'					ELSE [is_variety_merge.time] + timestamp()'
		'					END, '
		'				is_variety_merge.user = CASE '
		'					WHEN is_variety_merge.user IS NULL '
		'					THEN trim($username) '
		'					ELSE [is_variety_merge.user] + trim($username)'
		'					END, '
		# also set the tree variety property
		'				tree.variety = variety_update.name '
		' ) '
		# if El frances Code variety trait then create link to variety.
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower = "el frances code" '
		'	AND d.value IS NOT NULL '
		'	THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'		MERGE '
		'			(plot_item_plot)<-[: FROM_PLOT]-(pv) '
		'			-[: IS_VARIETY]->(variety_update) '
		'		MERGE '
		'			(tree)-[is_variety_merge: IS_VARIETY]->(pv) '
		'		SET '
		'			tree.variety = variety_update.name, '
		'			is_variety.current = False, '
		'			is_variety_merge.current = True, '
		'			is_variety_merge.time = CASE '
		'				WHEN is_variety_merge.time IS NULL '
		'				THEN timestamp() '
		'				ELSE [is_variety_merge.time] + timestamp()'
		'				END, '
		'			is_variety_merge.user = CASE '
		'				WHEN is_variety_merge.user IS NULL '
		'				THEN trim($username) '
		'				ELSE [is_variety_merge.user] + trim($username)'
		'				END '
		# also set the tree variety property
		' ) '
		# if trait is branch id then link to branch
		' FOREACH (n IN CASE '
		'	WHEN trait.level in ["leaf","sample"] '
		'	AND trait.name_lower = "assign to branch" '
		'	THEN [1] ELSE [] END | '
		'		MERGE '
		'			(item)-[from_branch_merge:FROM_BRANCH]->(branch_update) '
		'		SET  '
		'			from_branch_current.current = False,  '
		'			from_branch_merge.current = True,  '
		'			from_branch_merge.time = CASE  '
		'				WHEN from_branch_merge.time IS NULL '
		'				THEN timestamp()  '
		'				ELSE [from_branch_merge.time] + timestamp() '
		'				END, '
		'			from_branch_merge.user = CASE  '
		'				WHEN from_branch_merge.user IS NULL '
		'				THEN trim($username)  '
		'				ELSE [from_branch_merge.user] + trim($username) '
		'				END '
		' ) '
		# if trait is leaf id then link to leaf
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "sample" '
		'	AND trait.name_lower = "assign to leaf" '
		'	THEN [1] ELSE [] END | '
		'		MERGE '
		'			(item)-[from_leaf_merge:FROM_LEAF]->(leaf_update) '
		'		SET '
		'			from_leaf_current.current = False, '
		'			from_leaf_merge.current = True, '
		'			from_leaf_merge.time = CASE '
		'				WHEN from_leaf_merge.time IS NULL'
		'				THEN timestamp() '
		'				ELSE [from_leaf_merge.time] + timestamp() '
		'				END, '
		'			from_leaf_merge.user = CASE '
		'				WHEN from_leaf_merge.user IS NULL'
		'				THEN trim($username) '
		'				ELSE [from_leaf_merge.user] + trim($username) '
		'				END'
		' ) '
		# And give the user feedback on their submission success
		' RETURN d.found '
	)
	get_plots_treecount = (' MATCH (C:Country)<-[:IS_IN]-(R:Region) '
		' OPTIONAL MATCH (R)<-[:IS_IN]-(F:Farm) '
		' OPTIONAL MATCH (F)<-[:IS_IN]-(P:Plot) '
		' OPTIONAL MATCH (P)<-[:IS_IN]-(:PlotTrees)<-[:FOR]-(T:Counter {name:"tree"}) '
		' OPTIONAL MATCH (P)<-[:IS_IN*..2]-(B:Block) '
		' OPTIONAL MATCH (B)<-[:IS_IN*..2]-(t:Tree) '
		' WITH C, R, F, P, T, {name: B.name, label:"Block", treecount:count(t)} as blocks, count(t) as blocktrees '
		' WITH C, R, F, {name: P.name, label:"Plot", treecount: T.count - sum(blocktrees), children: FILTER(block IN collect(blocks) WHERE block["name"] IS NOT NULL)} as plots '
		' WITH C, R, {name: F.name, label:"Farm", children: FILTER(plot IN collect(plots) WHERE plot["name"] IS NOT NULL)} as farms '
		' WITH C, {name: R.name, label:"Region", children: FILTER(farm IN collect(farms) WHERE farm["name"] IS NOT NULL)} as regions '
		' WITH {name: C.name, label:"Country", children: FILTER(region IN collect (regions) WHERE region["name"] IS NOT NULL)} as countries '
		' RETURN countries ' )
	get_submissions_range = (
		# gets arguments to filter by time from last SUBMITTED relationship
		# sample data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(sst:SampleSampleTrait) '
					' -[:DATA_FOR*2]->(:PlotSampleTrait) '
					' -[:FOR_TRAIT]->(sampletrait:SampleTrait), '
				' (sst)'
					' -[:FROM_SAMPLE]->(sample:Sample) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (sampletrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(sampletrait)) as d_id, '
			' "Samples" as n_label, '
			' count(DISTINCT sample) as n_name, '
			' (id(plot) + "_" + id(sampletrait) + "_sample_count_node") as n_id,'
			' "FROM_PLOT_SAMPLES" as r_type,  '
			' (id(plot) + "_" + id(sampletrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(sampletrait)) as r_start, '
			' (id(plot) + "_" + id(sampletrait) + "_sample_count_node") as r_end '
			' '
		' UNION '
		#sample data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(sst:SampleSampleTrait) '
					' -[:DATA_FOR*2]->(:PlotSampleTrait) '
					' -[:FOR_TRAIT]->(sampletrait:SampleTrait), '
				' (sst) '
					' -[:FROM_SAMPLE]->(sample:Sample)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (sampletrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(sampletrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Samples" as n_label, '
			' count(DISTINCT sample) as n_name, '
			' (id(block) + "_" + id(sampletrait) + "_sample_count_node") as n_id,'
			' "FROM_BLOCK_SAMPLES" as r_type,  '
			' (id(block) + "_" + id(sampletrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(sampletrait)) as r_start, '
			' (id(block) + "_" + id(sampletrait) + "_sample_count_node") as r_end '
		' UNION '
		# leaf data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(llt:LeafLeafTrait) '
					' -[:DATA_FOR*2]->(:PlotLeafTrait) '
					' -[:FOR_TRAIT]->(leaftrait:LeafTrait), '
				' (llt)'
					' -[:FROM_LEAF]->(leaf:Leaf) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (leaftrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(leaftrait)) as d_id, '
			' "Leaves" as n_label, '
			' count(DISTINCT leaf) as n_name, '
			' (id(plot) + "_" + id(leaftrait) + "_leaf_count_node") as n_id,'
			' "FROM_PLOT_LEAVES" as r_type,  '
			' (id(plot) + "_" + id(leaftrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(leaftrait)) as r_start, '
			' (id(plot) + "_" + id(leaftrait) + "_leaf_count_node") as r_end '
			' '
		' UNION '
		#leaf data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(llt:LeafLeafTrait) '
					' -[:DATA_FOR*2]->(:PlotLeafTrait) '
					' -[:FOR_TRAIT]->(leaftrait:LeafTrait), '
				' (llt) '
					' -[:FROM_LEAF]->(leaf:Leaf)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (leaftrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(leaftrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Leaves" as n_label, '
			' count(DISTINCT leaf) as n_name, '
			' (id(block) + "_" + id(leaftrait) + "_leaf_count_node") as n_id,'
			' "FROM_BLOCK_LEAVES" as r_type,  '
			' (id(block) + "_" + id(leaftrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(leaftrait)) as r_start, '
			' (id(block) + "_" + id(leaftrait) + "_leaf_count_node") as r_end '
		' UNION '
		# branch data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(bbt:BranchBranchTrait) '
					' -[:DATA_FOR*2]->(:PlotBranchTrait) '
					' -[:FOR_TRAIT]->(branchtrait:BranchTrait), '
				' (bbt)'
					' -[:FROM_BRANCH]->(branch:Branch) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (branchtrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(branchtrait)) as d_id, '
			' "Branches" as n_label, '
			' count(DISTINCT branch) as n_name, '
			' (id(plot) + "_" + id(branchtrait) + "_branch_count_node") as n_id,'
			' "FROM_PLOT_BRANCHES" as r_type,  '
			' (id(plot) + "_" + id(branchtrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(branchtrait)) as r_start, '
			' (id(plot) + "_" + id(branchtrait) + "_branch_count_node") as r_end '
			' '
		' UNION '
		#branch data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(bbt:BranchBranchTrait) '
					' -[:DATA_FOR*2]->(:PlotBranchTrait) '
					' -[:FOR_TRAIT]->(branchtrait:BranchTrait), '
				' (bbt) '
					' -[:FROM_BRANCH]->(branch:Branch)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (branchtrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(branchtrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Branches" as n_label, '
			' count(DISTINCT branch) as n_name, '
			' (id(block) + "_" + id(branchtrait) + "_branch_count_node") as n_id,'
			' "FROM_BLOCK_BRANCHES" as r_type,  '
			' (id(block) + "_" + id(branchtrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(branchtrait)) as r_start, '
			' (id(block) + "_" + id(branchtrait) + "_branch_count_node") as r_end '
		' UNION '
		#tree data (from plot but not block, connect to tree counter)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(ttt:TreeTreeTrait) '
					' -[:DATA_FOR]->(:PlotTreeTrait) '
					' -[:FOR_TRAIT]->(treetrait:TreeTrait), '
				' (ttt)-[:FROM_TREE]->(tree:Tree), '
				' (ptt)-[:FROM_PLOT]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (treetrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(treetrait)) as d_id, '
			' "Trees" as n_label, '
			' count(DISTINCT tree) as n_name, '
			' (id(plot) + "_" + id(treetrait) + "_tree_count_node") as n_id,'
			' "FROM_PLOT_TREES" as r_type,  '
			' (id(plot) + "_" + id(treetrait) + "_rel") as r_id, '
			' (id(plot) + "_" + id(treetrait)) as r_start, '
			' (id(plot) + "_" + id(treetrait) + "_tree_count_node") as r_end ' 
		' UNION '
		#tree data (from block)
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(ttt:TreeTreeTrait) '
				' -[:DATA_FOR]->(:PlotTreeTrait) '
				' -[:FOR_TRAIT]->(treetrait:TreeTrait), '
			' (ttt)-[:FROM_TREE]->(tree:Tree) '
				' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (treetrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(treetrait)) as d_id, '
			' "Trees" as n_label, '
			' count(DISTINCT tree) as n_name, '
			' (id(block) + "_" + id(treetrait) + "_tree_count_node") as n_id,'
			' "FROM_BLOCK_TREES" as r_type,  '
			' (id(block) + "_" + id(treetrait) + "_rel") as r_id, '
			' (id(block) + "_" + id(treetrait)) as r_start, '
			' (id(block) + "_" + id(treetrait) + "_tree_count_node") as r_end '
		' UNION '
		#block data
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(bbt:BlockBlockTrait) '
				' -[:DATA_FOR]->(:PlotBlockTrait) '
				' -[:FOR_TRAIT]->(blocktrait:BlockTrait), '
			' (bbt)-[:FROM_BLOCK]->(block:Block) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (blocktrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(blocktrait)) as d_id, '
			' "Block" as n_label, '
			' block.name as n_name, '
			' id(block) as n_id,'
			' "FROM_BLOCK" as r_type,  '
			' (id(block) + "_" + id(blocktrait) + "_rel") as r_id, '
			' (id(block) + "_" + id(blocktrait)) as r_start, '
			' id(block) as r_end '
		'UNION'
		#plot data
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(ppt:PlotPlotTrait) '
				' -[:FOR_TRAIT]->(plottrait:PlotTrait), '
		' 	(ppt)-[:FROM_PLOT]-(plot:Plot) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (plottrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(plottrait)) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id,'
			' "FROM_PLOT" as r_type,  '
			' (id(plot) + "_" + id(plottrait) + "_rel") as r_id, '
			' (id(plot) + "_" + id(plottrait)) as r_start, '
			' id(plot) as r_end '
		' UNION '
		#link blocks into plots
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (block:Block) '
				' WHERE '
					' (data)-[:DATA_FOR*2]->(:TreeSampleTrait) '
					' -[:FROM_TREE]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
				' OR '
					'(data)-[:DATA_FOR]->(:TreeTreeTrait) '
					' -[:FROM_TREE]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
				' OR '
					' (data)-[:DATA_FOR]->(:BlockBlockTrait) '
					' -[:FROM_BLOCK]->(block:Block) '
		' WITH DISTINCT block '
		' MATCH (block)-[:IS_IN*2]->(plot:Plot) '
		' RETURN '
			' "Block" as d_label, '
			' block.name as d_name, '
			' id(block) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(block) + "_" + id(plot)) as r_id, '
			' id(block) as r_start, '
			' id(plot) as r_end'
		' UNION '
		# link plots into farms
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (plot:Plot) '
				' WHERE '
					' (data)-[:DATA_FOR*3]->(:PlotSampleTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
				' OR '
					'(data)-[:DATA_FOR*2]->(:PlotTreeTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
				' OR '
					' (data)-[:DATA_FOR*2]->(:PlotBlockTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
				' OR '
					' (data)-[:DATA_FOR]->(:PlotPlotTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
		' WITH DISTINCT plot '
		' MATCH (plot)-[:IS_IN]->(farm:Farm) '
		' RETURN '		
			' "Plot" as d_label, '
			' plot.name as d_name, '
			' id(plot) as d_id, '
			' "Farm" as n_label, '
			' farm.name as n_name, '
			' id(farm) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(plot) + "_" + id(farm)) as r_id, '
			' id(plot) as r_start, '
			' id(farm) as r_end'
		' UNION '
		# link farms into regions
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (farm:Farm) '
				' WHERE '
					' (data)-[:DATA_FOR*3]->(:PlotSampleTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
				' OR '
					'(data)-[:DATA_FOR*2]->(:PlotTreeTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
				' OR '
					' (data)-[:DATA_FOR*2]->(:PlotBlockTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
				' OR '
					' (data)-[:DATA_FOR]->(:PlotPlotTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
		' WITH DISTINCT farm '
		' MATCH (farm)-[:IS_IN]->(region:Region) '
		' RETURN '
			' "Farm" as d_label, '
			' farm.name as d_name, '
			' id(farm) as d_id, '
			' "Region" as n_label, '
			' region.name as n_name, '
			' id(region) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(farm) + "_" + id(region)) as r_id, '
			' id(farm) as r_start, '
			' id(region) as r_end'
		' UNION '
		# link regions into countries
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (region:Region) '
				' WHERE '
					' (data)-[:DATA_FOR*3]->(:PlotSampleTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm) '
					' -[:IS_IN]->(region:Region) '
				' OR '
					'(data)-[:DATA_FOR*2]->(:PlotTreeTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm)'
					' -[:IS_IN]->(region:Region) '
				' OR '
					' (data)-[:DATA_FOR*2]->(:PlotBlockTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm)'
					' -[:IS_IN]->(region:Region) '
				' OR '
					' (data)-[:DATA_FOR]->(:PlotPlotTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm)'
					' -[:IS_IN]->(region:Region) '
		' WITH DISTINCT region '
		' MATCH (region)-[:IS_IN]->(country:Country) '
		' RETURN '
			' "Region" as d_label, '
			' region.name as d_name, '
			' id(region) as d_id, '
			' "Country" as n_label, '
			' country.name as n_name, '
			' id(country) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(region) + "_" + id(country)) as r_id, '
			' id(region) as r_start, '
			' id(country) as r_end '
	)