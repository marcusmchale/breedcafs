class Cypher:
	def __init__(self):
		pass
	# user procedures
	allowed_emails = (
		' MATCH '
		'	(e: Emails) '
		' RETURN '
		'	e.allowed '
	)
	user_allowed_emails = (
		' MATCH '
		'	(u:User) '
		' WITH '
		'	COLLECT (DISTINCT u.email) as registered_emails '
		' MATCH '
		'	(user:User {'
		'		username_lower : toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(e: Emails) '
		' RETURN '
		'	FILTER (n in e.allowed WHERE NOT n in registered_emails) as user_allowed '
	)
	email_find = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' RETURN '
		'	user '
	)
	confirm_email = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' SET '
		'	user.confirmed = true '
	)
	user_find = (
		' MATCH '
		'	(user: User) '
		'		WHERE '
		'			user.username_lower = toLower($username) '
		'		OR '
		'			user.email = toLower(trim($email)) '
		' RETURN '
		'	user '
	)
	username_find = (
		' MATCH '
		'	(user: User { '
		'		username_lower: toLower($username)'
		'	}) '
		' RETURN '
		'	user '
	)
	user_affiliations = (
		' MATCH '
		'	(u: User { '
		'		username_lower: toLower($username) '
		'	}) '
		'	-[a: AFFILIATED]->(p: Partner) '
		' OPTIONAL MATCH '
		'	(p)<-[: AFFILIATED {admin: true}]-(admin: User) '
		' RETURN '
		'	p.name , '
		'	p.fullname , '
		'	a.confirmed as confirmed, '
		'	a.data_shared as data_shared , '
		'	admin.email as admin_email'
	)
	add_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		}), '
		'		(p:Partner { '
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	MERGE '
		'		(u)-[a: AFFILIATED { '
		'			data_shared: false, '
		'			admin: false, '
		'			confirm_timestamp: [], '
		'			confirmed: false '
		' 		}]->(p) '
		' 	ON CREATE SET '
		'		a.add_timestamp = timestamp() '
		' 	RETURN '
		'		p.name '
	)
	remove_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		 }) '
		'		-[a:AFFILIATED { '
		'			data_shared: false '
		'		}]->(p: Partner {'
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	WHERE '
		'		size(a.confirm_timestamp) = 0 '
		' 	DELETE '
		'		a '
		' 	RETURN p.name '
	)
	password_reset = (
		' MATCH '
		'	(user: User { '
		'		email : toLower(trim($email)) '
		' 	}) '
		' SET user.password = $password '
	)
	user_register = (
		# This is a little cautious using merge to prevent overwriting a user profile if it is called in error
		' MATCH '
		'	(partner:Partner {'
		'		name_lower: toLower(trim($partner)) '
		'	}) '
		' MERGE '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	ON CREATE SET '
		'		user.username = trim($username), '
		'		user.password = $password, ' 
		'		user.email = toLower(trim($email)), '
		'		user.name = $name, '
		'		user.time = timestamp(), '
		'		user.access = ["user"], '
		'		user.confirmed = false, '
		'		user.found = false '
		'	ON MATCH SET '
		'		user.found = TRUE '
		' WITH '
		'	user, partner '	
		' WHERE '
		'	user.found = false '
		' CREATE '
		'	(user)-[r: AFFILIATED { '
		'		r.data_shared: true, '
		'		r.confirmed: false, '
		'		r.confirm_timestamp: [], '
		'		r.admin: false '				
		'	}]->(partner) '
		'	(user)-[: SUBMITTED]->(sub: Submissions), '
		'		(sub)-[: SUBMITTED]->(: Emails {allowed :[]}),'
		'		(sub)-[: SUBMITTED]->(: Partners), '
		'		(sub)-[: SUBMITTED]->(: Traits), '
		'		(sub)-[: SUBMITTED]->(: Trials), '
		'		(sub)-[: SUBMITTED]->(locations: Locations), '
		'			(locations)-[: SUBMITTED]->(: Countries), '
		'			(locations)-[: SUBMITTED]->(: Regions), '
		'			(locations)-[: SUBMITTED]->(: Farms), '
		'			(locations)-[: SUBMITTED]->(: Plots), '
		'		(sub)-[:SUBMITTED]->(traits:Traits), '
		'			(traits)-[: SUBMITTED]->(: FarmTraits), '
		'			(traits)-[: SUBMITTED]->(: PlotTraits), '
		'			(traits)-[: SUBMITTED]->(: BlockTraits), '
		'			(traits)-[: SUBMITTED]->(: TreeTraits), '
		'			(traits)-[: SUBMITTED]->(: BranchTraits), '
		'			(traits)-[: SUBMITTED]->(: LeafTraits), '
		'			(traits)-[: SUBMITTED]->(: SampleTraits), '
		'		(sub)-[:SUBMITTED]->(varieties:Varieties), '
		'			(varieties)-[: SUBMITTED]->(: Hybrids), '
		'			(varieties)-[: SUBMITTED]->(: Inbreds), '
		'			(varieties)-[: SUBMITTED]->(: Grafts), '
		'		(sub)-[:SUBMITTED]->(descriptors: SampleDescriptors), '
		'			(descriptors)-[: SUBMITTED]->(: Tissues), '
		'			(descriptors)-[: SUBMITTED]->(: StorageMethods), '
		'		(sub)-[:SUBMITTED]->(items: Items), '
		'			(items)-[: SUBMITTED]->(: Blocks), '
		'			(items)-[: SUBMITTED]->(: Trees), '
		'			(items)-[: SUBMITTED]->(: Branches), '
		'			(items)-[: SUBMITTED]->(: Leaves), '
		'			(items)-[: SUBMITTED]->(: Samples), '
		'		(sub)-[:SUBMITTED]->(data: DataSub), '
		'			data)-[: SUBMITTED]->(: FieldBook),'
		'			data)-[: SUBMITTED]->(: TableCSV) '
	)
	add_allowed_email = (
		' MATCH '
		'	(all: Emails) '
		' WITH '
		'	all.allowed as allowed_emails '
		' UNWIND '
		'	allowed_emails as email '
		' WITH '
		'	COLLECT(DISTINCT email) as set '
		' WHERE '
		'	NOT toLower(trim($email)) IN set '
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' SET e.allowed = e.allowed + [toLower(trim($email))] '
		' RETURN toLower(trim($email)) '
	)
	remove_allowed_email = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' SET e.allowed = FILTER (n in e.allowed WHERE NOT n IN toLower(trim($email))) '
		' RETURN toLower(trim($email)) '
	)
	user_del = (
		' MATCH '
		'	(u:User { '
		'		email: toLower(trim($email)), '
		'		confirmed: false '
		'	}) '
		' OPTIONAL MATCH '
		'	(u)-[:SUBMITTED*..3]->(n) '
		' DETACH DELETE '
		' u,n '
	)
	partner_admin_users = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: AFFILIATED { '
		'		admin: true '
		'	}]->(p:Partner) '
		' WITH p '
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) ' 
		' RETURN { '
		'	Username: u.username, '
		'	Email: u.email, '
		'	Name: u.name, '
		'	Partner: p.name, '
		'	PartnerFullName: p.fullname, '
		'	Confirmed: a.confirmed '
		' } '
	)
	global_admin_users = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.confirmed '
		' } '
	)
	# these functions toggle the confirmed status so do both confirm/un-confirm operations
	partner_confirm_users = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:AFFILIATED {admin : true}]->(p:Partner) '
		' WHERE '
		'	"partner_admin" in user.access'
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(confirm["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(confirm["username"])) '
		' 	SET '
		'		a.confirmed = NOT a.confirmed, '
		'		a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' 	RETURN u.name '
	)
	global_confirm_users = ( 
		' MATCH '
		'	(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' WITH '
		'	p,a,u '
		' WHERE '
		'	p.name_lower = toLower(trim(confirm["partner"])) '
		' AND '
		'	u.username_lower = toLower(trim(confirm["username"])) '
		' SET '
		'	a.confirmed = NOT a.confirmed, '
		'	a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' RETURN u.name '
	)
	partner_admins = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.admin '
		' } '
	)
	confirm_admins = (
		' MATCH '
		'		(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $admins as admin '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(admin["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(admin["username"])) '
		' 	SET '
		'		a.admin = NOT a.admin '
		' 	RETURN '
		'		u.name '
	)
	# LOCATION PROCEDURES
	# country procedures
	country_find = (
		' MATCH '
		'	(country:Country { '
		'		name_lower : toLower(trim($country))'
		' 	}) '
		' RETURN '
		'	country '
	)
	country_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(c: Countries) '
		' MERGE '
		'	(c)-[s: SUBMITTED]->(country: Country { '
		'		name_lower: toLower(trim($country)) '
		' 	}) '
		'	ON CREATE SET '
		'		country.name = trim($country), '
		'	 	s.time = timestamp() '
		' RETURN country.name '
	)
	# region procedures
	region_find = (
		' MATCH '
		'	(:Country { '
		'		name_lower : toLower(trim($country)) '
		' 	}) '
		'	<-[:IS_IN]-(region:Region { '
		'		name_lower: toLower(trim($region)) '
		' 	}) '
		' RETURN region '
	)
	region_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Locations) '
		'	-[:SUBMITTED]->(r: Regions), ' 
		'	(c:Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' MERGE '
		'	(region:Region { '
		'		name_lower: toLower(trim($region)) '
		' 	}) '
		'	-[:IS_IN]->(c) '
		'	ON CREATE SET '
		'		region.name = trim($region) '
		' MERGE '
		'	(r)-[s: SUBMITTED]->(region) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN '
		'	region.name '
	)
	get_farms = (
		' MATCH '
		'	(f: Farm) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' RETURN properties (f) '
	)
	farm_find = (
		' MATCH '
		'	(farm: Farm { '
		'		name_lower: toLower(trim($farm)) '
		' 	}) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' RETURN farm '
	)
	farm_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(f: Farms), ' 
		'	(r: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country {name_lower: toLower(trim($country))}) '
		' MERGE '
		'	(farm:Farm { '
		'		name_lower: toLower(trim($farm)) '
		' 	}) '
		' 	-[:IS_IN]->(r) '
		'	ON CREATE SET '
		'		farm.name = trim($farm) '
		' MERGE '
		'	(f)-[s:SUBMITTED]->(farm) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN farm.name '
	)
	# plot procedures
	get_plots = (
		' MATCH '
		'	(p:Plot) '
		'	-[:IS_IN]->(:Farm {name_lower: toLower(trim($farm))}) '
		'	-[:IS_IN]->(:Region {name_lower: toLower(trim($region))}) '
		'	-[:IS_IN]->(:Country {name_lower: toLower(trim($country))}) '
		' RETURN '
		'	properties (p) '
	)
	plot_find = (
		' MATCH '
		'	(plot:Plot { name_lower: toLower(trim($plot))}) '
		' 	-[:IS_IN]->(:Farm { name: toLower(trim($farm))}) ' 
		' 	-[:IS_IN]->(:Region { name: toLower(trim($region))}) '
		' 	-[:IS_IN]->(:Country { name: toLower(trim($country)}) '
		' RETURN '
		'	plot '
	)
	# for autoincrement:
	# https://stackoverflow.com/questions/32040409/reliable-autoincrementing-identifiers-for-all-nodes-relationships-in-neo4j
	# for lock:
	# this allows the increment counter (allowing for concurrent transactions to be serialised):
	# http://neo4j.com/docs/stable/transactions-isolation.html
	# https://stackoverflow.com/questions/35138645/how-to-perform-an-atomic-update-on-relationship-properties-with-py2neo
	# https://stackoverflow.com/questions/31798311/write-lock-behavior-in-neo4j-cypher-over-transational-rest-ap
	plot_id_lock = (
		' MATCH '
		'	(id: Counter { '
		'		name: "plot" '
		' 	}) '
		' SET '
		'	id._LOCK_ = true '
	)
	plot_add = (
		' MATCH '
		'	(:User { '
		'		username_lower:toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(p: Plots), '
		'	(f: Farm { '
		'		name_lower: toLower(trim($farm)) '
		'	}) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower($region) }) '
		'	-[:IS_IN]->(: Country { '
		'		name: $country '
		' 	}),  '
		'	(id: Counter { '
		'		name: "plot" '
		'	}) '
		' SET '
		'	id.count = id.count + 1 '
		' MERGE '
		'	(plot:Plot { '
		'		name_lower:toLower(trim(($plot))) '
		' 	}) '
		'	-[:IS_IN]->(f) '
		' 	ON CREATE SET '
		' 		plot.name = trim($plot), '
		'		plot.uid = id.count '
		# Create the plot level counters and container nodes for sub-levels
		' MERGE '
		'	(block_counter: Counter { '
		'		name: "block", '
		'		uid: (toString(id.count) + "_block") '
		'	}) '
		'	-[: FOR]->(: PlotBlocks)-[: IS_IN]->(plot) '
		'	ON CREATE SET '
		'		block_counter.count = 0 '
		' MERGE '
		'	(tree_counter: Counter { '
		'		name: "tree", '
		'		uid: (toString(id.count) + "_tree") '
		'	}) '
		'	-[: FOR]->(: PlotTrees)-[: IS_IN]->(plot) '
		'	ON CREATE SET '
		'		tree_counter.count = 0 '
		' MERGE '
		'	(branch_counter: Counter { '
		'		name: "branch", '
		'		uid: (toString(id.count) + "_branch") '
		'	}) '
		'	-[:FOR]->(: PlotBranches)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		branch_counter.count = 0 '
		' MERGE '
		'	(leaf_counter: Counter { '
		'		name: "leaf", '
		'		uid: (toString(id.count) + "_leaf") '
		'	}) '
		'	-[:FOR]->(: PlotLeaves)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		leaf_counter.count = 0 '
		' MERGE '
		'	(sample_counter: Counter { '
		'		name: "sample", '
		'		uid: (toString(id.count) + "_sample") '
		'	}) '
		'	-[:FOR]->(: PlotSamples)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		sample_counter.count = 0 '
		# track time and user
		' MERGE '
		'	(p)-[s:SUBMITTED]->(plot) '
		'	ON CREATE SET '
		'		s.time = timestamp() '
		' MERGE '
		'	(id)-[: COUNTED]->(plot) '
		' SET id._LOCK_ = false' 
		' RETURN { '
		'	uid: plot.uid,'
		'	name:plot.name '
		' } '
	)
	# ITEM PROCEDURES
	# have unique plotID so don't need other location details
	id_lock = (
		' MATCH '
		'	(id:Counter { '
		'		name: $level, '
		'		uid: ($plotID + "_" + $level ) '
		'	}) '
		' SET '
		'	id._LOCK_ = true '
		' RETURN { '
		'	lock : id._LOCK_, '
		'	uid : id.uid '
		' } '
	)
	# a lock for separate BlockTree counters (store the count of trees per block only, not used to generate IDs)
	block_id_lock = (
		' MATCH '
		'	(id:Counter { '
		'		name: $level, '
		'		uid: ($blockUID + "_" + $level ) '
		'	}) '
		' SET '
		'	id._LOCK_ = true '
		' RETURN { '
		'	lock : id._LOCK_, '
		'	uid : id.uid '
		' } '
	)
	get_blocks = (
		' MATCH '
		'	(b:Block) '
		'	-[:IS_IN]->(:PlotBlocks) '
		'	-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		' RETURN properties (b) '
	)
	block_find = (
		' MATCH '
		'	(block:Block { '
		'		name : $block'
		'	}) '
		'	-[:IS_IN]->(:PlotBlocks) '
		'	-[:IS_IN]->(:Plot { '
		'		uid : toInteger($plotID) '
		'	}) '
		' RETURN '
		'	block '
	)
	block_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(b:Blocks), '
		'	(id:Counter { '
		'		uid: ($plotID + "_block") '
		'	}) '
		'	-[:FOR]->(pb: PlotBlocks) '
		'	-[:IS_IN]->(p:Plot) '
		' SET id.count = id.count+1 '
		' MERGE '
		'	(block:Block { '
		'		name_lower: toLower(trim($block)), '
		'		uid:($plotID + "_B" + id.count), '
		'		id:id.count '
		'	}) '
		'	-[:IS_IN]->(pb) '
		' 	ON CREATE SET '
		'		block.name = trim($block) '
		' MERGE '
		'	(b)-[s:SUBMITTED]->(block) '
		'	ON CREATE SET s.time = timestamp () '
		# Create BlockTrees container node and counter
		' MERGE '
		'	(block_tree_counter: Counter { '
		'		name: "tree", '
		'		uid: (block.uid + "_tree"), '
		'	}) '
		'	-[:FOR]->(: BlockTrees)-[:IS_IN]->(block) '
		'	ON CREATE SET '
		'		block_tree_counter.count = 0 '
		' SET id._LOCK_ = false '
		' RETURN { '
		'	uid: block.uid, '
		'	name: block.name '
		' } '
	)
	get_blocks_details = (
		' MATCH '
		'	(b: Block) '
		'	-[:IS_IN]->(: PlotBlocks) '
		'	-[:IS_IN]->(p: Plot { '
		'		uid : toInteger($plotID)'
		'	}) '
		'	-[:IS_IN]->(f: Farm) '
		'	-[:IS_IN]->(r: Region) '
		'	-[:IS_IN]->(c: Country) '
		' RETURN { '
		'	UID : b.uid, '
		'	PlotID : p.uid, '
		'	BlockID : b.id, '
		'	Block : b.name, '
		'	Plot : p.name, '
		'	Farm : f.name, '
		'	Region : r.name, '
		'	Country : c.name '
		' } '
		' ORDER BY b.id '
	)
	# tree procedures
	trees_add = (
		# Start with users tree submissions node (UserTrees)
		# and the plots tree container (PlotTrees)
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ut:Trees), '
		'	(pt:PlotTrees)-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		# create per user per plot trees node (UserPlotTrees) linking these
		' MERGE '
		'	(ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		# keep the PlotTrees and UserPlotTrees nodes
		' WITH '
		'	pt, upt'
		# find the id counter node (plot tree counter)
		' MATCH '
		'	(id:Counter { '
		'		uid: ($plotID + "_tree") '
		'	}) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter ' 
		' 	SET '
		'		id.count = id.count + 1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		' 	CREATE '
		'		(t: Tree { '
		'			uid: ($plotID + "_T" + id.count), '
		'			id: id.count, '
		'			custom_id: "", '
		'			variety: "" '
		'		}) '
		'		-[:IS_IN]->(pt) '
		'	CREATE '
		'		(upt)-[: SUBMITTED {time: timestamp()}]->(t) '
		# unlock the counter
		'	SET '
		'		id._LOCK_ = false '
		# and return a table of IDs
		'	RETURN '
		'		count (t)'
	)
	trees_add_block = (
		# Start with users tree submissions node (UserTrees)
		# and the plots tree container (PlotTrees)
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ut:Trees), '
		'	(pt:PlotTrees)-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}), '
		'	(bt:BlockTrees)-[:IS_IN]->(:Block { '
		'		uid: $blockUID '
		'	}) '
		# create per user per plot trees node (UserPlotTrees) linking these
		' MERGE '
		'	(ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		# keep the PlotTrees and UserPlotTrees nodes
		' WITH '
		'	pt, upt, bt'
		# find the id counter node (plot tree counter)
		' MATCH '
		'	(id:Counter {uid: ($plotID + "_tree")}), '
		# and the block counter node
		'	(bc:Counter {uid: ($blockUID + "_tree")}) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter '
		'	SET '
		'		id.count = id.count + 1, '
		'		bc.count = bc.count + 1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		'	CREATE '
		'		(t:Tree { '
		'			uid: ($plotID + "_T" + id.count), '
		'			id: id.count, '
		'			custom_id: "", '
		'			variety: "" '
		'		}) '
		'		-[:IS_IN]->(pt), '
		'		(upt)-[:SUBMITTED { '
		'			time:timestamp() '
		'		}]->(t), '
		# link to block trees (record when it was added to this block and by who)
		'		(t)-[:IS_IN { '
		'			time: timestamp(), '
		'			user: toLower(trim($username)), '
		'			from: "web_form" '
		'		}]->(bt) '
		# unlock the counter
		'	SET '
		'		id._LOCK_ = false '
		'	RETURN '
		'		count(t) '
	)
	trees_get = (
		' MATCH '
		'	(tree: Tree) '
		'	-[:IS_IN]->(pt: PlotTrees) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid : toInteger($plotID) '
		'	}) '
		'	-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		# filter by range of tree ID's
		' WHERE '
		'	tree.id >= $start '
		' AND '
		'	tree.id <= $end '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree) '
		'	-[:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block) '
		' RETURN { '
		'	UID: tree.uid, '
		'	PlotID: plot.uid, '
		'	TreeID: tree.id, '
		' 	CustomID: tree.custom_id, '
		'	Variety: tree.variety, '
		'	Block: collect(distinct block.name), '
		'	Plot: plot.name, '
		'	Farm: farm.name, '
		'	Region: region.name, '
		'	Country: country.name '
		' } '
		' ORDER BY '
		'	tree.id '
	)
	treecount = (
		' MATCH '
		'	(tc: Counter { '
		'		uid: ($plotid + "_tree") '
		'	}) '
		' RETURN '
		'	tc.count '
	)
	# branch procedures
	branches_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User {'
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ub:Branches), '
		# and both the PlotBranches and branch id counter nodes
		'	(t:Tree) '
		'	-[:IS_IN]->(:PlotTrees)'
		'	-[:IS_IN]->(p:Plot { '
		'		uid:toInteger($plotID) '
		'	}) '
		'	<-[:FROM_PLOT]-(pb:PlotBranches) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: ($plotID + "_branch") '
		'	}), '
		'	(p)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		' WHERE '
		'	t.id >= toInteger($start) '
		' AND '
		'	t.id <= toInteger($end) '
		' WITH '
		'	ub, p, t, pb, id, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' ORDER BY '
		'	t.id '
		# find block if registered
		' OPTIONAL MATCH (t) '
		'	-[:IS_IN]->(:BlockTrees) '
		'	-[:IS_IN]->(block:Block) '
		# create links for context TreeBranches and PlotBranches
		' MERGE '
		'	(tb:TreeBranches)-[:FROM_TREE]->(t) '
		' MERGE '
		'	(tb)-[:FROM_PLOT]->(pb)'
		# per UserBranches per PlotBranches for tracking
		' MERGE '
		'	(ub)-[:SUBMITTED]->(upb:UserPlotBranches)-[:CONTRIBUTED]->(pb) '
		# per UserPlotBranches per TreeBranches for tracking
		' MERGE '
		'	(upb)-[:SUBMITTED]->(utb:UserTreeBranches)-[:CONTRIBUTED]->(tb) '
		# create new branch ids
		' UNWIND range(1, $replicates) as replicates '
		'	SET id.count = id.count + 1 '
		'	CREATE '
		'		(r:Branch { '
		'			uid: (p.uid + "_R" + id.count), '
		'			id: id.count, '
		'			tree: t.id, '
		'			replicates: $replicates '
		'		}) '
		# link branch to TreeBranches
		'	CREATE '
		'		(r)-[:FROM_TREE]->(tb) '
		# link UserTreeBranches to branch with timestamp for submission
		'	CREATE '
		'		(utb)-[:SUBMITTED { '
		'			time : timestamp() '
		'		}]->(r) '
		# unlock the id counter node
		'	SET '
		'		id._LOCK_ = false '
		# return the list of ID's created
		'	RETURN { '
		'		UID : r.uid, '
		'		Country : country, '
		'		Region : region, '
		'		Farm : farm, '
		'		Plot: p.name, '
		'		PlotID : p.uid, '
		'		Block: collect(distinct block.name), '
		'		BlockID: block.id, '
		'		TreeID : t.id, '
		'		CustomID : tree.custom_id, '
		'		Variety: tree.variety, '
		'		BranchID : r.id  '
		'	} '
	)
	branches_get = (
		' MATCH '
		'	(branch:Branch) '
		'	-[:FROM_TREE]-(tb:TreeBranches) '
		'	-[:FROM_TREE]-(tree:Tree) '
		'	-[:IS_IN]->(pt:PlotTrees) '
		'	-[:IS_IN]->(plot:Plot {uid : toInteger($plotID)}) '
		'	-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		# filter by range of tree ID's
		' WHERE tree.id >= $trees_start '
		' AND tree.id <= $trees_end '
		' AND branch.id >= $branches_start '
		' AND branch.id <= $branches_end '
		# find block if registered
		' OPTIONAL MATCH (tree) '
		'	-[:IS_IN]->(:BlockTrees)-[:IS_IN]->(block:Block)'
		' RETURN { '
		'	UID: branch.uid, '
		'	Country: country.name, '
		'	Region: region.name, '
		'	Farm: farm.name, '
		'	Plot: plot.name, '
		'	PlotID: plot.uid, ' 
		'	Block: block.name, '
		'	BlockID: block.id, '
		'	TreeID: tree.id, '
		'	CustomID: tree.custom_id, '
		'	Variety: tree.variety, '
		'	BranchID: branch.id '
		' } '
		' ORDER BY '
		'	branch.id '
	)
	# leaf procedures
	leaves_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(ul: Leaves), '
		# and both the PlotBranches and branch id counter nodes
		'	(t:Tree) '
		'	-[:IS_IN]->(: PlotTrees)'
		'	-[:IS_IN]->(p: Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		'	<-[:FROM_PLOT]-(pl: PlotLeaves) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: ($plotID + "_leaf")'
		'	}), '
		'	(p)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		' WITH '
		'	ul, p, t, pl, id, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' ORDER BY t.id '
		' WHERE t.id >= toInteger($start) '
		' AND t.id <= toInteger($end) '
		# find block if registered
		' OPTIONAL MATCH (t) '
		'	-[: IS_IN]->(: BlockTrees)-[:IS_IN]->(block: Block) '
		# Create links for context TreeLeaves and PlotLeaves
		' MERGE (tl:TreeLeaves)-[:FROM_TREE]->(t) '
		' MERGE (tl)-[:FROM_PLOT]->(pl) '
		# per UserLeaves per PlotLeaves for tracking
		' MERGE (ul)-[:SUBMITTED]->(upl: UserPlotLeaves)-[:CONTRIBUTED]->(pl) '
		# per UserPlotLeaves per TreeLeaves for tracking
		' MERGE (upl)-[:SUBMITTED]->(utl: UserTreeLeaves)-[:CONTRIBUTED]->(tl) '
		# create leaf ID's
		' UNWIND range(1, toInteger($replicates)) as replicates '
		'	SET '
		'		id.count = id.count + 1 '
		'	CREATE '
		'		(l: Leaf { '
		'			uid: (p.uid + "_L" + id.count), '
		'			id: id.count, '
		'			tree: t.id, '
		'			replicates: $replicates '
		'		}), '
		# link leaf to TreeLeaves
		'		(l)-[:FROM_TREE]->(tl), '
		# link UserTreeLeaves to branch with timestamp for submission
		'		(utl)-[:SUBMITTED {time: timestamp()}]->(l) '
		# unlock the id counter node
		'	SET id._LOCK_ = false '
		# return the list of ID's created
		'	RETURN { '
		'		UID: l.uid, '
		'		County: country, '
		'		Region: region, '
		'		Farm: farm, '
		'		Plot: p.name, '
		'		PlotID: p.uid, '
		'		Block: block.name, '
		'		BlockID: block.id, '
		'		TreeID: t.id, '
		'		CustomID: t.custom_id, '
		'		Variety: t.variety, '
		'		LeafID: l.id  '
		'	} '
	)
	leaves_get = (
		' MATCH '
		'	(leaf: Leaf) '
		'	-[:FROM_TREE]-(tl: TreeLeaves) '
		'	-[:FROM_TREE]-(tree: Tree) '
		'	-[:IS_IN]->(pt: PlotTrees) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid : toInteger($plotID) '
		' }) '
		'	-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# filter by ranges of ID's
		' WHERE tree.id >= $trees_start '
		' AND tree.id <= $trees_end '
		' AND leaf.id >= $leaves_start '
		' AND leaf.id <= $leaves_end '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree) '
		'	-[:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block)'
		# and a branch if the leaf has been assigned to a branchID
		' OPTIONAL MATCH (leaf) '
		'	-[:FROM_BRANCH]->(branch: Branch) '
		# and return
		' RETURN { '
		' 	UID: leaf.uid, '
		' 	Country: country.name, '
		' 	Region: region.name, '
		' 	Farm: farm.name, '
		' 	Plot: plot.name, '
		' 	PlotID: plot.uid, ' 
		' 	Block: block.name, '
		' 	BlockID: block.id, '
		' 	TreeID: tree.id, '
		' 	TreeName: tree.custom_id, '
		' 	BranchID: branch.id, '
		' 	LeafID: leaf.id '
		' } '
		' ORDER BY '
		'	leaf.id '
	)
	# sample procedures
	# not sure if good idea for users to add these, maybe restrict to admins
	tissue_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: SampleDescriptors) '
		'	-[:SUBMITTED]->(tissues: Tissues) '
		' MERGE '
		'	(tissue:Tissue { '
		'		name_lower: toLower(trim($tissue)) '
		'	}) '
		'	ON CREATE SET '
		'		tissue.name = trim($tissue) '
		' MERGE '
		'	(tissues)-[s:SUBMITTED]->(tissue)'		
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN '
		'	tissue '
	)
	storage_add = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: SampleDescriptors) '
		'	-[:SUBMITTED]->(sm: StorageMethods) '
		' MERGE '
		'	(storage:Storage { '
		'		name_lower: toLower(trim($storage))}) '
		'	ON CREATE SET '
		'		storage.name = trim($storage) '
		' MERGE '
		'	(sm)-[s:SUBMITTED]->(storage) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN storage '
	)
	samples_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username))}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(samples: Samples), '
		'	(t:Tree) '
		'	-[:IS_IN]->(: PlotTrees) '
		'	-[:IS_IN]->(: Plot { '
		'		uid: toInteger($plotID) '
		'	}), '
		'	(tissue:Tissue { '
		'		name_lower: toLower(trim($tissue)) '
		'	}), '
		'	(storage:Storage { '
		'		name_lower: toLower(trim($storage)) '
		'	}), '
		'	(id:Counter { '
		'		uid: ($plotID + "_sample") '
		'	}) '
		'	-[:FOR]->(ps: PlotSamples) '
		'	-[:FROM_PLOT]->(p: Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		'	-[:IS_IN]->(f: Farm) '
		'	-[:IS_IN]->(r: Region) '
		'	-[:IS_IN]->(c: Country) '
		' WHERE '
		'	t.id >= $start '
		' AND '
		'	t.id <= $end '
		# with the selected trees to be sampled
		' WITH '
		'	t, tissue, storage, samples, id, ps, p, f, r, c '
		' ORDER BY '
		'	t.id '
		# get block name if available
		' OPTIONAL MATCH '
		'	(t) '
		'	-[:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(b: Block) '
		# Merge a per Tissue per Storage container node
		' MERGE '
		'	(tissue)<-[: OF_TISSUE]-(TiSt: TissueStorage)-[:STORED_IN]->(storage) '
		# And split this off per PlotSamples
		' MERGE '
		'	(TiSt)<-[: COLLECTED_AS]-(pts: PlotTissueStorage)-[: FROM_PLOT]->(ps) '
		# Create a TreeSamples node per tree
		' MERGE '
		'	(t)<-[:FROM_TREE]-(ts:TreeSamples) '
		# Track user submissions through successive UserPlotSamples then UserTreeSamples container nodes
		' MERGE '
		'	(samples)-[:SUBMITTED]->(ups:UserPlotSamples)-[:CONTRIBUTED]->(ps) '
		' MERGE '
		'	(ups)-[:SUBMITTED]->(uts:UserTreeSamples)-[:CONTRIBUTED]->(ts) '
		# with replicates
		' UNWIND '
		'	range(1, $replicates) as replicates '
		# incrementing with a plot level counter
		'	SET '
		'		id.count = id.count + 1 '
		# Create samples
		'	CREATE '
		'		(s:Sample { '
		'			uid: (p.uid + "_S" + id.count), '
		'			id: id.count, '
		'			tree: t.id, '
		# '			date: $date, '
		# '			time: $time, '
		'			replicates: $replicates '
		'		}) '
		# Link the sample to its TreeSamples
		'	MERGE '
		'		(s)-[: FROM_TREE]->(ts) '
		# and the PlotTissueStorage container
		'	MERGE '
		'		(s)-[: FROM_PLOT]->(pts) '
		# and user tracking through UserTreeSamples
		'	MERGE  '
		'		(uts)-[s1:SUBMITTED]->(s) '
		'		ON CREATE SET s1.time = timestamp() '
		'	SET '
		'		id._LOCK_ = false '
		# return for csv
		'	RETURN { '
		'		UID : s.uid, '
		'		PlotID : p.uid, '
		'		TreeID : t.id, '
		'		CustomID : t.custom_id, '
		'		Variety: t.variety, '
		'		SampleID : s.id, '
		'		Date : s.date, '
		'		Tissue : tissue.name, '
		'		Storage : storage.name, '
		'		Block : b.name, '
		'		Plot : p.name, '
		'		Farm : f.name, '
		'		Region : r.name, '
		'		Country : c.name '
		'	} '
		'	ORDER BY s.id '
		)
	# Upload procedures
	upload_check_value = (
		# make sure that all the entries match accepted entries
		# handles empty items and white space
		# forces strings to lower case and float/integer types
		# removes % symbols
		# ! ensure to declare trait (as node) and value (from file) before including
		' CASE '
		'	WHEN trait.format = "multicat" '
		'		THEN CASE '
		'			WHEN size(FILTER (n in split(value, ":") WHERE size(n) > 0)) '
		'				= size(FILTER (n in split(value, ":") WHERE toLower(trim(n)) in '
		'					extract(item in trait.category_list | toLower(item))) '
		'				THEN extract(i in FILTER (n in split(value, ":") WHERE  size(n) > 0 )| trim(i)) '	
		'			ELSE False '
		'			END '
		'	WHEN trait.format = "categorical" '
		'		THEN CASE '
		'			WHEN toLower(trim(value)) in extract(item in trait.category_list | toLower(item)) '
		'				THEN trim(value) '
		'			ELSE False '
		'			END '
		'	WHEN trait.format = "text" '
		'		THEN CASE '
		'			WHEN trait.name_lower = "variety" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE False '
		'					END '
		'			WHEN trait.name_lower = "el frances code" '
		'				THEN CASE '
		'					WHEN toLower(value) in in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE False '
		'					END '
		'			WHEN trait.name_lower = "synthetic fertiliser n:p:k ratio" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 3 '
		'					AND toFloat(trim(split(value, ":")[0])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[1])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[2])) IS NOT NULL '
		'						THEN trim(value) '
		'					ELSE False '
		'					END '
		'			WHEN trait.name contains "time" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 2 '
		'					AND size(split(value, ":")[0] <= 2 '
		'					AND toInteger(trim(split(value, ";")[0])) IS NOT NULL ' 
		'					AND size(split(value, ":")[1] <= 2 '
		'					AND toInteger(trim(split(value, ";")[1])) IS NOT NULL '
		'						THEN trim(value) '
		'					ELSE False '
		'					END '							
		'			ELSE '
		'				toString(value) '
		'			END '
		'	WHEN trait.format = "percent" '
		'		THEN CASE '
		'			WHEN toFloat(replace(value, "%", "")) IS NOT NULL '
		'				THEN toFloat(replace(value, "%", "")) '
		'			ELSE False '
		'			END '
		'	WHEN trait.format = "counter" '
		'		THEN CASE '
		'			WHEN toInteger(value) IS NOT NULL '
		'				THEN toInteger(value) '
		'			ELSE '
		'			False '
		'			END '
		'	WHEN trait.format = "numeric" '
		'		THEN CASE '
		'			WHEN toFloat(value) IS NOT NULL '
		'				THEN toFloat(value) '
		'			ELSE False '
		'			END '
		'	WHEN trait.format = "boolean" '	
		'		THEN CASE '
		'			WHEN value in ["yes","y"] '
		'				THEN True '
		'			WHEN value in ["no","n"] '
		'				THEN False '
		'			WHEN toBoolean(value) IS NOT NULL '
		'				THEN toBoolean(value) '
		'			ELSE False '
		'			END '
		'	WHEN trait.format = "location" '
		'		THEN CASE '
		'			WHEN size(split(value, ";")) = 2 '
		'			AND toFloat(trim(split(value, ";")[0])) IS NOT NULL ' 
		'			AND toFloat(trim(split(value, ";")[1])) IS NOT NULL ' 
		'				THEN trim(value) '
		'			ELSE False '
		'			END '
		'	WHEN trait.format = "date" '
		'		THEN CASE '
		'			WHEN size(split(value, "-")) = 3 '
		'			AND size(toFloat(trim(split(value, "-")[0]))) = 4 ' 
		'			AND size(toFloat(trim(split(value, "-")[1])) <3 '
		'			AND size(toFloat(trim(split(value, "-")[1])) >0 '
		'			AND size(toFloat(trim(split(value, "-")[2])) <3 '
		'			AND size(toFloat(trim(split(value, "-")[2])) >0 '
		'				THEN apoc.date.parse(value,"ms","yyyy-MM-dd HH:mm:sszzz") '
		'			ELSE False '
		'			END '
		'	ELSE False '
		'	END '
	)
	upload_FB_plot = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine.location as location, '
		'	csvLine.person as person, '
		'	toInteger(csvLine.UID as uid), '
		'	toLower(trim(csvLine.trait)) as trait_name_lower, '
		'	apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz") as time, '
		'	trim(csvLine.value) as value '
		# And identify the plots and traits assessed
		' MATCH '
		'	(plot: Plot {uid: uid}), '
		'	(trait: PlotTrait { '
		'		name_lower: trait_name_lower '
		'	}), '
		# get the user submission tracking nodes
		'	(:User { '
		'		username_lower : toLower(trim($username))'
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:DataSub) '
		'	-[:SUBMITTED]->(fb:FieldBook) '
		# Create per plot per trait container node
		' MERGE '
		'	(plot)<-[:FROM_PLOT]-(ppt:PlotPlotTrait) '
		'	-[:FOR_TRAIT]->(trait) '
		# Merge the data point linking to the Plot/PlotTrait node
		' MERGE '
		'	(d:Data { '
		'		time : time, '
		'	}) '
		'	-[:DATA_FOR]->(ppt) '
		'	ON CREATE SET '
		'		d.found = false, '
		'		d.location = location, '
		'		d.person = person, '
		'		d.value = ' + upload_check_value +
		'	ON MATCH SET '
		'		d.found = true '
		# track user submissions through User/Plot/PlotTrait container
		' MERGE '
		'	(fb)-[:SUBMITTED]->(uppt:UserPlotPlotTrait) '
		'	-[:CONTRIBUTED]->(ppt) '
		' MERGE '
		'	(uppt)-[s1:SUBMITTED]->(d) '
		'	ON CREATE SET '
		'		s1.time = timestamp() '
		# And give the user feedback on their submission success
		' RETURN d.found '
		)
	upload_FB_block = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine.location as location, '
		'	csvLine.person as person, '
		'	csvLine.timestamp as time_fb, '
		'	csvLine.UID as uid, '
		'	toInteger(head(split(csvLine.UID, "_"))) as plot_id, '
		'	toLower(trim(csvLine.trait)) as trait_name, '
		'	apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz") as time, '
		'	trim(csvLine.value) as value '
		# And identify the plots and traits assessed
		' MATCH '
		'	(block: Block { '
		'		uid: uid '
		'	}) '
		'	-[:IS_IN]->(: PlotBlocks) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid: plot_id '
		'	}), '
		'	(trait : BlockTrait { '
		'		name_lower: trait_name '
		'	}), '
		# get the user submission tracking nodes
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: DataSub) '
		'	-[:SUBMITTED]->(fb: FieldBook) '
		# Create per plot per trait node
		' MERGE '
		'	(plot)<-[: FROM_PLOT]-(pbt: PlotBlockTrait) '
		'	-[: FOR_TRAIT]->(trait) '
		# Also per block per PlotBlockTrait node
		' MERGE '
		'	(block)<-[: FROM_BLOCK]-(bbt: BlockBlockTrait) '
		'	-[ : DATA_FOR]->(pbt) '
		# Merge the data point linking to the Block/BlockTrait node
		' MERGE '
		'	(d: Data { '
		'		time : time, '
		'	}) '
		'	-[ : DATA_FOR]->(bbt)'
		'	ON CREATE SET '
		'		d.found = false, '
		'		d.person = person, '
		'		d.location = location, '
		'		d.value = ' + upload_check_value +
		' ON MATCH SET '
		'	d.found = true '
		# track user submissions through User/Plot/BlockTrait container
		' MERGE '
		'	(fb)-[: SUBMITTED]->(upbt: UserPlotBlockTrait) '
		'	-[: CONTRIBUTED]->(pbt) '
		' MERGE '
		'	(upbt)-[s1: SUBMITTED]->(d) '
		' 	ON CREATE SET s1.time = timestamp() '
		# And give the user feedback on their submission success
		' RETURN '
		'	d.found'
	)
	upload_FB_tree = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' MATCH '
		'	(trait: TreeTrait { '
		'		name_lower: toLower(trim(csvLine.trait))}) '
		# '	(varieties: TreeTrait {name_lower:"variety"}), '
		# '	(codes: TreeTrait {name:"el frances code"}) '
		' WITH '
		'	trim(csvLine.value) as value, '
		'	trait as trait, '
		'	csvLine.location as location, '
		'	csvLine.person as person, '
		'	csvLine.UID as uid, '
		'	toInteger(head(split(csvLine.UID, "_"))) as plot_id, '
		'	apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz") as time, '
		# And identify the trees, plots and traits assessed
		' MATCH '
		'	(tree: Tree {uid: uid}) '
		'	-[: IS_IN]->(: PlotTrees) '
		'	-[: IS_IN]->(plot: Plot { '
		'		uid: plot_id '
		'	}), '
		# get the user submission tracking nodes
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(submissions :Submissions) '
		'	-[: SUBMITTED]->(: DataSub) '
		'	-[: SUBMITTED]->(fb :FieldBook), '
		# Create per plot per TreeTrait node
		' MERGE '
		'	(plot)<-[:FROM_PLOT]-(ptt: PlotTreeTrait)-[: FOR_TRAIT]->(trait) '
		# Also per Tree per Plot/TreeTrait node
		' MERGE '
		'	(tree)<-[: FROM_TREE]-(ttt: TreeTreeTrait)-[: DATA_FOR]->(ptt) '
		# Merge the data point linking to Tree/TreeTrait node
		' MERGE '
		'	(d: Data { '
		'		time: time, '
		'	}) '
		'	-[: DATA_FOR]->(ttt) '
		'	ON CREATE SET '
		'		d.found = false, '
		'		d.person = person, '
		'		d.location = location, '
		'		d.value = ' + upload_check_value +
		'	ON MATCH SET '
		'		d.found = true '
		# track user submissions through User/Plot/TreeTrait container
		' MERGE '
		'	(fb)-[: SUBMITTED]->(uptt: UserPlotTreeTrait)-[: CONTRIBUTED]->(ptt) '
		' MERGE '
		'	(uptt)-[s0: SUBMITTED]->(d) '
		'	ON CREATE SET s0.time = timestamp() '
		# if block data 
		' FOREACH (n IN CASE WHEN trait.name = "assign to block" THEN [1] ELSE [] END | '
		# create block and a BlockTrees and BlockTreeCounter node
		'	MERGE '
		'		(block_counter: Counter { '
		'			uid: (plot.uid + "_block") '
		'		}) '
		'		-[: FOR]->(pb: PlotBlocks) '
		'		-[: IS_IN]->(plot) '
		'	SET block_counter._LOCK_ = True '
		'	MERGE (block: Block { '
		'		name_lower: toLower(d.value) '
		'		}) '
		'		-[:IS_IN]->(pb) '
		'		ON CREATE SET '
		'			block_counter.count = block_counter.count + 1 '
		'			block.uid = (plot.uid + "_B" + block_counter.count), '
		'			block.id = block_counter.count, '
		'			block.name = d.value '
		'	SET id._LOCK_ = False '
		' 	MERGE '
		'		(block_tree_counter: Counter { '
		'			name: "tree", '
		'			uid: (block.uid + "_tree") '
		'		}) '
		'		-[: FOR]-(bt: BlockTrees) '
		'		-[: IS_IN]->(block) '
		'		ON CREATE SET '
		'			block_tree_counter.count = 0, '
		# link tree to block (and track number in block with counter)
		'	MERGE '
		'		(tree)-[s1:IS_IN]->(bt) '
		'		ON CREATE SET '
		'			block_tree_counter = block_tree_counter + 1 '
		'			s1.time = timestamp(), '
		'			s1.user = toLower(trim($username)), '
		'			s1.from = "upload" '
		# track the block submission to the user
		'	MERGE '
		'		(submissions)-[: SUBMITTED]->(: Items) '
		'		-[: SUBMITTED]->(blocks: Blocks) '
		'		-[s2: SUBMITTED]->(block) '
		' ) '
		# if variety trait create link tree to variety. If d.value is not False then variety should exist 
		' FOREACH (n IN CASE '
		'	WHEN trait.name_lower = "variety" '
		'	THEN [1] ELSE [] END | '
		'		FOREACH (m IN CASE '
		'			WHEN toLower(d.value) IS NOT False'
		'			THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'				MERGE '
		'					(plot)<-[: FROM_PLOT]-(pv: PlotVariety) '
		'					-[: IS_VARIETY]->(variety:Variety { '
		'						name_lower: toLower(d.value)'
		'					}) '
		'				MERGE '
		'					(tree)-[: IS_VARIETY]->(pv) '
		# also set the tree variety property
		'				SET tree.variety = variety.name '
		'		) '
		' ) '
		# if El frances Code variety trait then create link to variety. If d.value is False then variety should exist
		' FOREACH (n IN CASE '
		'	WHEN trait.name_lower = "el frances code" '
		'	THEN [1] ELSE [][ END | '
		'		FOREACH (m IN CASE '
		'			WHEN toLower(d.value) IS NOT False '
		'			THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'				MERGE '
		'					(plot)<-[: FROM_PLOT]-(pv: PlotVariety) '
		'					-[: IS_VARIETY]->(:Variety { '
		'						el_frances_code_lower: toLower(d.value) '
		'					}) '
		'				MERGE '
		'					(tree)-[: IS_VARIETY]->(pv) '
		'				SET tree.variety = variety.name '
		'		) '
		' ) '
		#And give the user feedback on their submission success
		' RETURN d.found '
	)
	upload_FB_branch = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine.location as location, '
		'	csvLine.person as person, '
		'	csvLine.timestamp as time_fb, '
		'	csvLine.UID as uid, '
		'	toInteger(head(split(csvLine.UID, "_"))) as plot_id, '
		'	toLower(trim(csvLine.trait)) as trait_name, '
		'	apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz") as time, '
		'	toLower(trim(csvLine.value)) as value '
		# And identify the branches, trees, plots and traits assessed
		' MATCH '
		'	(branch: Branch { '
		'		uid: uid '
		'	}) '
		'	-[: FROM_TREE]->(: TreeBranches) '
		'	-[: FROM_TREE]->(tree: Tree) '
		'	-[: IS_IN]->(: PlotTrees) '
		'	-[: IS_IN]->(plot: Plot { '
		'		uid: plot_id'
		'	}), '
		'	(trait: BranchTrait { '
		'		name: trait_name'
		'	}), '
		# get the user submission tracking nodes
		'	(:User {'
		'		username : $username'
		'	}) '
		'	-[ : SUBMITTED]->(submissions : Submissions) '
		'	-[ : SUBMITTED]->( : DataSub) '
		'	-[ : SUBMITTED]->(fb : FieldBook) '
		# Create /Plot/BranchTrait (per plot per trait) container node
		' MERGE '
		'	(plot)<-[: FROM_PLOT]-(pbt: PlotBranchTrait)-[: FOR_TRAIT]->(trait) '
		# Then  /Tree/BranchTrait container node
		' MERGE '
		'	(tree)<-[: FROM_TREE]-(tbt: TreeBranchTrait)-[: DATA_FOR]->(pbt) '
		# And finally /Branch/BranchTrait container node
		' MERGE '
		'	(branch)<-[: FROM_BRANCH]-(bbt: BranchBranchTrait)-[: DATA_FOR]->(tbt)'
		# Merge the data point linking to Sample/SampleTrait node
		' MERGE '
		'	(d:Data { '
		'		time : time, '
		'	}) '
		'	-[ : DATA_FOR]->(bbt) '
		'	ON CREATE SET '
		'		d.found = false, '
		'		d.person = person, '
		'		d.location = location, '
		'		d.value = ' + upload_check_value +
		'	ON MATCH SET d.found = true '
		#track user submissions through /User/Plot/LeafTrait container
		' MERGE '
		'	(fb)-[: SUBMITTED]->(upbt: UserPlotBranchTrait) '
		'	-[: CONTRIBUTED]->(pbt) '
		' MERGE '
		'	(upbt)-[s1 : SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '
		#And give the user feedback on their submission success
		' RETURN '
		'	d.found '
	)
	upload_FB_leaf = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
			' csvLine.location as location, '
			' csvLine.person as person, '
			' csvLine.timestamp as time_fb, '
			' csvLine.UID as uid, '
			' toInteger(head(split(csvLine.UID, "_"))) as plot_id, '
			' toLower(trim(csvLine.trait)) as trait_name, '
			' apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz") as time, '
			' toLower(trim(csvLine.value)) as value '
		# And identify the leaves, trees, plots and traits assessed
		' MATCH (leaf : Leaf {uid : uid}) '
				' -[ : FROM_TREE]->( : TreeLeaves) '
				' -[ : FROM_TREE]->(tree : Tree) '
				' -[ : IS_IN]->( : PlotTrees) '
				' -[ : IS_IN]->(plot : Plot {uid: plot_id}), '
			' (trait : LeafTrait {name : trait_name}), '
			# get the user submission tracking nodes
			' ( : User {username : $username}) '
				' -[ : SUBMITTED]->(submissions : Submissions) '
				' -[ : SUBMITTED]->( : DataSub) '
				' -[ : SUBMITTED]->(fb : FieldBook) '
		# Create /Plot/LeafTrait (per plot per trait) container node
		' MERGE (plot)<-[ : FROM_PLOT]-(plt : PlotLeafTrait)-[ : FOR_TRAIT]->(trait) '
		# Then  /Tree/LeafTrait container node
		' MERGE (tree)<-[ : FROM_TREE]-(tlt : TreeLeafTrait)-[ : DATA_FOR]->(plt) '
		# And finally /Leaf/LeafTrait container node
		' MERGE (leaf)<-[ : FROM_LEAF]-(llt : LeafLeafTrait)-[ : DATA_FOR]->(tlt) '
		# Merge the data point linking to Sample/SampleTrait node
		' MERGE (d:Data { '
				' item : uid, '
				' trait : trait.name, '
				' time_fb : time_fb, '
				# the below converts the time to epoch (ms) - same as neo4j timestamp() to allow simple math on date/time
				' time : time, '
				' person : person, '
				' location : location, '
				' value : '
					+ upload_check_value +
			' }) '
			' -[ : DATA_FOR]->(llt) '
			# storing whether found or not for user feedback
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
		# track user submissions through /User/Plot/LeafTrait container
		' MERGE (fb)-[ : SUBMITTED]->(uplt : UserPlotLeafTrait)-[ : CONTRIBUTED]->(plt) '
		' MERGE (uplt)-[s1 : SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '
		# And give the user feedback on their submission success
		' RETURN d.found '
	)
	upload_FB_sample = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
			' csvLine.location as location, '
			' csvLine.person as person, '
			' csvLine.timestamp as time_fb, '
			' split(csvLine.UID, ".")[0] as uid, '
			' toInteger(split(csvLine.UID, ".")[1]) as replicate, '
			' toInteger(head(split(csvLine.UID, "_"))) as plot_id, '
			' toLower(trim(csvLine.trait)) as trait_name, '
			#the below converts the time to epoch (ms) - same as neo4j timestamp() to allow simple math on date/time
			' apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz") as time, '
			' toLower(trim(csvLine.value)) as value '
		# And identify the samples, trees, plots and traits assessed
		' MATCH (sample : Sample {uid : uid}) '
					' -[ : FROM_TREE]->( : TreeSamples) '
					' -[ : FROM_TREE]->(tree : Tree) '
					' -[ : IS_IN]->( : PlotTrees) '
					' -[ : IS_IN]->(plot : Plot {uid : plot_id}), '
				' (trait : SampleTrait {name : trait_name}), '
			# get the user submission tracking nodes
			' ( : User {username : $username}) '
				' -[ : SUBMITTED]->(submissions : Submissions) '
				' -[ : SUBMITTED]->( : DataSub) '
				' -[ : SUBMITTED]->(fb : FieldBook) '
		# Create /Plot/SampleTrait (per plot per trait) container node
		' MERGE (plot)<-[ : FROM_PLOT]-(pst : PlotSampleTrait)-[ : FOR_TRAIT]->(trait) '
		# Then  /Tree/SampleTrait container node
		' MERGE (tree)<-[ : FROM_TREE]-(tst : TreeSampleTrait)-[ : DATA_FOR]->(pst)'
		# And finally /Sample/SampleTrait container node
		' MERGE (sample)<-[ : FROM_SAMPLE]-(sst : SampleSampleTrait)-[ : DATA_FOR]->(tst)'
		# Merge the data point linking to Sample/SampleTrait node
		' MERGE (d:Data { '
					' item : uid, '
					' trait : trait.name, '
					' time_fb : time_fb, '
					' time : time, '
					' person : person, '
					' location : location, '
					' replicate : CASE replicate WHEN NULL THEN False ELSE replicate END, '
					' value : '
						+ upload_check_value +
				' }) '
				' -[ : DATA_FOR]->(sst) '
			#storing whether found or not for user feedback
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
		#track user submissions through /User/Plot/SampleTrait container
		' MERGE (fb)-[ : SUBMITTED]->(upst : UserPlotSampleTrait)-[ : CONTRIBUTED]->(pst) '
		' MERGE (upst)-[s1 : SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '		
		# if replicate then create a link to a "replicate" node
		' FOREACH '
			' (n IN CASE '
				' WHEN replicate is not Null '
				' AND d.found = false '
			' THEN [1] ELSE [] END | '
				' MERGE '
					' (rep : Replicate { '
						' item : uid, '
						' id : replicate, '
						' timestamp : timestamp() '
					' }) '
				' MERGE (d)-[:FROM_REPLICATE]->(rep) '
		' ) '
		# And give the user feedback on their submission success
		' RETURN d.found '
	)
	##Upload Table procedures
	upload_table_plot = (
		# get the user submission tracking nodes
		' MATCH (:User {username : $username}) '
		' -[:SUBMITTED]->(:Submissions) '
		' -[:SUBMITTED]->(:DataSub) '
		' -[:SUBMITTED]->(table:TableCSV)'
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the plots and traits assessed
		' MATCH (plot:Plot {uid:toInteger(csvLine.UID)}) '
		' UNWIND $traits as trait_name '
			' WITH '
				' toInteger(csvLine.UID) as uid, '
				' toLower(trim(csvLine[trait_name])) as value, '
				' toLower(trim(trait_name)) as trait_name'
			' MATCH (trait:PlotTrait {name:trait_name}) '
				#if no entry in value then ignore - only report erronious values to user, not missing
				# all load_csv values are string so can just check size after trimming whitespace  
				' WHERE size(value) > 0 '
			# Create per plot per trait container node
			' MERGE (plot)<-[ : FROM_PLOT]-(ppt : PlotPlotTrait)-[ : FOR_TRAIT]->(trait) '
			# Merge the data point linking to the Plot/PlotTrait node
			' MERGE (d:Data {item : uid, '
				' person : trim(toLower($form_user)), '
				' date_form : $form_date, '
				' time_form : $form_time, '
				' time : $neo4j_time, '
				' trait : trait.name, '
				' value : '
					+ upload_check_value +
			' }) '
				' -[ : DATA_FOR]->(ppt) '
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
			# track user submissions through User/Plot/PlotTrait container
			' MERGE (table)-[ : SUBMITTED]->(uppt : UserPlotPlotTrait)-[ : CONTRIBUTED]->(ppt) '
			' MERGE (uppt)-[s1 : SUBMITTED]->(d) '
				' ON CREATE SET s1.time = timestamp() '
		# And give the user feedback on their submission success
		' RETURN d.found '
	)
	upload_table_block = (
		# get the user submission tracking nodes
		' MATCH (:User {username : $username}) '
		' -[:SUBMITTED]->(:Submissions) '
		' -[:SUBMITTED]->(:DataSub) '
		' -[:SUBMITTED]->(table:TableCSV)'
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the plots and traits assessed
		' MATCH (block:Block {uid:csvLine.UID}) '
			' -[:IS_IN]->(:PlotBlocks) '
			' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}) '
		' UNWIND $traits as trait_name '
			' value = toLower(trim(csvLine[trait_name])) '
			' MATCH (trait:BlockTrait {name:trait_name}) '
			' WHERE size(value) > 0 '
			# Create per plot per trait node
			' MERGE (plot)<-[:FROM_PLOT]-(pbt:PlotBlockTrait)-[:FOR_TRAIT]->(trait) '
			# Also per block per PlotBlockTrait node
			' MERGE (block)<-[:FROM_BLOCK]-(bbt:BlockBlockTrait)-[:DATA_FOR]->(pbt) '
			' MERGE (d:Data {item : csvLine.UID, '
						' person : trim($form_user), '
						' form_date : $form_date, '
						' form_time : $form_time, '
						' time : $neo4j_time,'
						' trait : trait.name, '
						' value : '
							+ upload_check_value +
					' }) '
					' -[:DATA_FOR]->(bbt)'
				' ON CREATE SET d.found = false '
				' ON MATCH SET d.found = true '
			# track user submissions through User/Plot/BlockTrait container
			' MERGE (table)-[:SUBMITTED]->(upbt:UserPlotBlockTrait)-[:CONTRIBUTED]->(pbt) '
			' MERGE (upbt)-[s1:SUBMITTED]->(d) '
				' ON CREATE SET s1.time = timestamp() '
			#And give the user feedback on their submission success
			' RETURN d.found'
	)
	upload_table_tree = (
		# get the user submission tracking nodes
		' MATCH '
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(submissions:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(table:TableCSV)'
		# and the block submission node in case block names are part of the TreeTrait data 
		# (this is a special case to handle flexible blocks)
		' MATCH (submissions)-[:SUBMITTED]->(:Items) '
				' -[:SUBMITTED]->(blocks:Blocks) '
		# In case variety information need to get these lists
		' MATCH (varieties:TreeTrait {name:"variety"}) '
		' MATCH (codes:TreeTrait {name:"el frances code"}) '
		# keep the nodes/lists we need
		' WITH '
			' varieties.category_list as varieties, '
			' codes.category_list as variety_codes, '
			' table as table, '
			' blocks as blocks'
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the trees by UID
		' MATCH (tree:Tree {uid:csvLine.UID}) '
				' -[:IS_IN]->(:PlotTrees) '
				' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}), '
			' (pb:PlotBlocks)<-[:FOR]-(id:Counter {uid: (plot.uid + "_block")}) '
		#and the traits by name from the list
		' UNWIND $traits as trait_name '
			' value = toLower(trim(csvLine[trait_name])) '
			' MATCH (trait:TreeTrait {name:trait_name}) '
			' WHERE size(value) > 0 '
				# OPTIONAL MATCHES NEEDED FOR THE FOREACH CLAUSES AS CAN'T MATCH INSIDE
				' OPTIONAL MATCH (variety_name:Variety { name : ' + upload_check_value + ' }) '
				' OPTIONAL MATCH (variety_code:Variety { el_frances_code : ' + upload_check_value + ' }) '
				# Create per plot per trait node
				' MERGE (plot)<-[:FROM_PLOT]-(ptt:PlotTreeTrait)-[:FOR_TRAIT]->(trait) '
				# Also per tree per PlotTreeTrait node
				' MERGE (tree)<-[:FROM_TREE]-(ttt:TreeTreeTrait)-[:DATA_FOR]->(ptt) '
				# Merge the data point
				' MERGE '
					'(d:Data { '
						' item : csvLine.UID, '
						' person : trim($form_user), '
						' form_date : $form_date, '
						' form_time : $form_time, '
						' time : $neo4j_time,'
						' trait : trait.name, '
						' value : '
							+ upload_check_value +
					'}) -[:DATA_FOR]->(ttt)'
					' ON CREATE SET d.found = false '
					' ON MATCH SET d.found = true '
				# track user submissions through User/Plot/BlockTrait container
				' MERGE (table)-[:SUBMITTED]->(uptt:UserPlotTreeTrait)-[:CONTRIBUTED]->(ptt) '
				' MERGE (uptt)-[s1:SUBMITTED]->(d) '
					' ON CREATE SET s1.time = timestamp() '
				# if block data create link tree to block
			' FOREACH (n IN CASE WHEN trait_name = "assign to block" THEN [1] ELSE [] END | '
					# lock the counter
						' SET id._LOCK_ = true '
					#then increment the counter and add our block
					' MERGE (block:Block {name:csvLine[trait_name]})-[:IS_IN]->(pb) '
						' ON CREATE SET '
							' SET id.count = id.count + 1, '
							' block.uid = (plot.uid + "_B" + id.count), '
							' block.id = id.count '
					#then ensure we have the BlockTrees container
					' MERGE (bt:BlockTrees)-[:IS_IN]->(block) '
					#then link the tree to this
					' MERGE (tree)-[s2:IS_IN]->(bt) '
						' ON CREATE SET s2.time = timestamp()'
					# and track the user submission in this part of the graph too, to be consistent with other block submissions
					# also add from_fb tag to allow more easy identification of these special cases (they may need scrutiny for typos/redundancy)
					' MERGE (blocks)-[s3:SUBMITTED]->(block) '
						' ON CREATE SET s3.time = timestamp(), s3.from_fb = true '
					#and "unlock"
					' SET id._LOCK_ = false'
				' ) '
			# if variety trait create link tree to variety
			' FOREACH (n IN CASE WHEN toLower(trim(trait.name)) = "variety" '
				' THEN [1] ELSE [] END | '
					# Create per plot per Variety node
					' MERGE (plot)<-[ : FROM_PLOT]-(pv : PlotVariety)-[ : IS_VARIETY]->(variety_name) '
					' MERGE (tree)-[ : IS_VARIETY]->(pv) '
			' ) '
			#if el frances code variety trait then create link to variety
			' FOREACH (n IN CASE WHEN toLower(trim(trait.name)) = "el frances code" '
				' THEN [1] ELSE [] END | '
					# Create per plot per Variety node
					' MERGE (plot)<-[ : FROM_PLOT]-(pv : PlotVariety)-[ : IS_VARIETY]->(variety_code) '
					' MERGE (tree)-[ : IS_VARIETY]->(pv) '
			# And give the user feedback on their submission success
			' RETURN d.found '
	)
	upload_table_branch = (
		# get the user submission tracking nodes
		' MATCH '
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(submissions:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(table:TableCSV) '
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the trees by UID
		' MATCH (branch:Branch {uid:csvLine.UID}) '
				' -[:FROM_TREE]->(:TreeBranches)'
				' -[:FROM_TREE]->(tree:Tree)'
				' -[:IS_IN]->(:PlotTrees) '
				' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}) '
		' OPTIONAL MATCH (tree)-[:IS_IN]->(:BlockTrees) '
				' -[:IS_IN]->(block:Block) '
		#and the traits by name from the list
		' UNWIND $traits as trait_name '
			' value = toLower(trim(csvLine[trait_name])) '
			' MATCH (trait:BranchTrait {name:trait_name}) '
			' WHERE size(value) > 0 '
				# Create per plot per trait node
				' MERGE (plot)<-[:FROM_PLOT]-(pbt:PlotBranchTrait)-[:FOR_TRAIT]->(trait) '
				# Also per tree per PlotBranchTrait node
				' MERGE (tree)<-[:FROM_TREE]-(tbt:TreeBranchTrait)-[:DATA_FOR]->(pbt) '
				' MERGE '
					'(d:Data { '
						' item : csvLine.UID, '
						' person : trim($form_user), '
						' form_date : $form_date, '
						' form_time : $form_time, '
						' time : $neo4j_time,'
						' trait : trait.name, '
						' value : '
							+ upload_check_value +
					'}) -[:DATA_FOR]->(tbt)'
					' ON CREATE SET d.found = false '
					' ON MATCH SET d.found = true '
				# track user submissions through User/Plot/BlockTrait container
				' MERGE (table)-[:SUBMITTED]->(upbt:UserPlotBranchTrait)-[:CONTRIBUTED]->(pbt) '
				' MERGE (upbt)-[s1:SUBMITTED]->(d) '
					' ON CREATE SET s1.time = timestamp() '
			# And give the user feedback on their submission success
			' RETURN d.found'
	)
	upload_table_leaf = (
		# get the user submission tracking nodes
		' MATCH '
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(submissions:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(table:TableCSV) '
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the trees by UID
		' MATCH (leaf:Leaf {uid:csvLine.UID}) '
				' -[:FROM_TREE]->(:TreeLeaves)'
				' -[:FROM_TREE]->(tree:Tree)'
				' -[:IS_IN]->(:PlotTrees) '
				' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}) '
		' OPTIONAL MATCH (tree)-[:IS_IN]->(:BlockTrees) '
				' -[:IS_IN]->(block:Block) '
		#and the traits by name from the list
		' UNWIND $traits as trait_name '
			' value = toLower(trim(csvLine[trait_name])) '
			' MATCH (trait:LeafTrait {name:trait_name}) '
			' WHERE size(trim(csvLine[trait_name])) > 0 '
				# Create per plot per trait node
				' MERGE (plot)<-[:FROM_PLOT]-(plt:PlotLeafTrait)-[:FOR_TRAIT]->(trait) '
				# Also per tree per PlotLeafTrait node
				' MERGE (tree)<-[:FROM_TREE]-(tlt:TreeLeafTrait)-[:DATA_FOR]->(plt) '
				' MERGE '
					'(d:Data { '
						' item : csvLine.UID, '
						' person : trim($form_user), '
						' form_date : $form_date, '
						' form_time : $form_time, '
						' time : $neo4j_time,'
						' trait : trait.name, '
						' value : '
							+ upload_check_value +
					'}) -[:DATA_FOR]->(tlt)'
					' ON CREATE SET d.found = false '
					' ON MATCH SET d.found = true '
				# track user submissions through User/Plot/BlockTrait container
				' MERGE (table)-[:SUBMITTED]->(uplt:UserPlotLeafTrait)-[:CONTRIBUTED]->(plt) '
				' MERGE (uplt)-[s1:SUBMITTED]->(d) '
					' ON CREATE SET s1.time = timestamp() '
			# And give the user feedback on their submission success
			' RETURN d.found'
	)
	upload_table_sample = (
		# get the user submission tracking nodes
		' MATCH '
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(submissions:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(table:TableCSV) '
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the trees by UID
		' MATCH (sample:Sample {uid:split(csvLine.UID, ".")[0]}) '
				' -[:FROM_TREE]->(:TreeSamples)'
				' -[:FROM_TREE]->(tree:Tree)'
				' -[:IS_IN]->(:PlotTrees) '
				' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}) '
		' OPTIONAL MATCH (tree)-[:IS_IN]->(:BlockTrees) '
				' -[:IS_IN]->(block:Block) '
		#and the traits by name from the list
		' UNWIND $traits as trait_name '
			' value = toLower(trim(csvLine[trait_name])) '
			' MATCH (trait:SampleTrait {name:trait_name}) '
			' WHERE size(value) > 0 '
				# Create per plot per trait node
				' MERGE (plot)<-[:FROM_PLOT]-(pst:PlotSampleTrait)-[:FOR_TRAIT]->(trait) '
				# Also per tree per PlotSampleTrait node
				' MERGE (tree)<-[:FROM_TREE]-(tst:TreeSampleTrait)-[:DATA_FOR]->(pst) '
				' MERGE '
					' (d:Data { '
						' item : split(csvLine.UID, ".")[0], '
						' person : trim($form_user), '
						' form_date : $form_date, '
						' form_time : $form_time, '
						' time : $neo4j_time,'
						' trait : trait.name, '
						' replicate : toInteger(split(csvLine.UID, ".")[1]), '
						' value : '
							+ upload_check_value +
					' })-[:DATA_FOR]->(tst) '
					' ON CREATE SET d.found = false '
					' ON MATCH SET d.found = true '
				# track user submissions through User/Plot/BlockTrait container
				' MERGE (table)-[:SUBMITTED]->(upst:UserPlotSampleTrait)-[:CONTRIBUTED]->(pst) '
				' MERGE (upst)-[s1:SUBMITTED]->(d) '
					' ON CREATE SET s1.time = timestamp() '
				# if replicate then create a link to a "replicate" node
				' FOREACH '
					' (n IN CASE '
						' WHEN toInteger(split(csvLine.UID, ".")[1]) is not Null '
						' AND d.found = false '
					' THEN [1] ELSE [] END | '
						' MERGE '
							' (rep : Replicate { '
								' item : split(csvLine.UID, ".")[0], '
								' id : toInteger(split(csvLine.UID, ".")[1]), '
								' timestamp : timestamp() '
							' }) '
						' MERGE (d)-[:FROM_REPLICATE]->(rep) '
				' ) '
			# And give the user feedback on their submission success
			' RETURN d.found '
	)
	get_plots_treecount = (' MATCH (C:Country)<-[:IS_IN]-(R:Region) '
		' OPTIONAL MATCH (R)<-[:IS_IN]-(F:Farm) '
		' OPTIONAL MATCH (F)<-[:IS_IN]-(P:Plot) '
		' OPTIONAL MATCH (P)<-[:IS_IN]-(:PlotTrees)<-[:FOR]-(T:Counter {name:"tree"}) '
		' OPTIONAL MATCH (P)<-[:IS_IN*..2]-(B:Block) '
		' OPTIONAL MATCH (B)<-[:IS_IN*..2]-(t:Tree) '
		' WITH C, R, F, P, T, {name: B.name, label:"Block", treecount:count(t)} as blocks, count(t) as blocktrees '
		' WITH C, R, F, {name: P.name, label:"Plot", treecount: T.count - sum(blocktrees), children: FILTER(block IN collect(blocks) WHERE block["name"] IS NOT NULL)} as plots '
		' WITH C, R, {name: F.name, label:"Farm", children: FILTER(plot IN collect(plots) WHERE plot["name"] IS NOT NULL)} as farms '
		' WITH C, {name: R.name, label:"Region", children: FILTER(farm IN collect(farms) WHERE farm["name"] IS NOT NULL)} as regions '
		' WITH {name: C.name, label:"Country", children: FILTER(region IN collect (regions) WHERE region["name"] IS NOT NULL)} as countries '
		' RETURN countries ' )
	get_submissions_range = (
		# gets arguments to filter by time from last SUBMITTED relationship
		# sample data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(sst:SampleSampleTrait) '
					' -[:DATA_FOR*2]->(:PlotSampleTrait) '
					' -[:FOR_TRAIT]->(sampletrait:SampleTrait), '
				' (sst)'
					' -[:FROM_SAMPLE]->(sample:Sample) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (sampletrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(sampletrait)) as d_id, '
			' "Samples" as n_label, '
			' count(DISTINCT sample) as n_name, '
			' (id(plot) + "_" + id(sampletrait) + "_sample_count_node") as n_id,'
			' "FROM_PLOT_SAMPLES" as r_type,  '
			' (id(plot) + "_" + id(sampletrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(sampletrait)) as r_start, '
			' (id(plot) + "_" + id(sampletrait) + "_sample_count_node") as r_end '
			' '
		' UNION '
		#sample data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(sst:SampleSampleTrait) '
					' -[:DATA_FOR*2]->(:PlotSampleTrait) '
					' -[:FOR_TRAIT]->(sampletrait:SampleTrait), '
				' (sst) '
					' -[:FROM_SAMPLE]->(sample:Sample)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (sampletrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(sampletrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Samples" as n_label, '
			' count(DISTINCT sample) as n_name, '
			' (id(block) + "_" + id(sampletrait) + "_sample_count_node") as n_id,'
			' "FROM_BLOCK_SAMPLES" as r_type,  '
			' (id(block) + "_" + id(sampletrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(sampletrait)) as r_start, '
			' (id(block) + "_" + id(sampletrait) + "_sample_count_node") as r_end '
		' UNION '
		# leaf data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(llt:LeafLeafTrait) '
					' -[:DATA_FOR*2]->(:PlotLeafTrait) '
					' -[:FOR_TRAIT]->(leaftrait:LeafTrait), '
				' (llt)'
					' -[:FROM_LEAF]->(leaf:Leaf) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (leaftrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(leaftrait)) as d_id, '
			' "Leaves" as n_label, '
			' count(DISTINCT leaf) as n_name, '
			' (id(plot) + "_" + id(leaftrait) + "_leaf_count_node") as n_id,'
			' "FROM_PLOT_LEAVES" as r_type,  '
			' (id(plot) + "_" + id(leaftrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(leaftrait)) as r_start, '
			' (id(plot) + "_" + id(leaftrait) + "_leaf_count_node") as r_end '
			' '
		' UNION '
		#leaf data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(llt:LeafLeafTrait) '
					' -[:DATA_FOR*2]->(:PlotLeafTrait) '
					' -[:FOR_TRAIT]->(leaftrait:LeafTrait), '
				' (llt) '
					' -[:FROM_LEAF]->(leaf:Leaf)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (leaftrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(leaftrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Leaves" as n_label, '
			' count(DISTINCT leaf) as n_name, '
			' (id(block) + "_" + id(leaftrait) + "_leaf_count_node") as n_id,'
			' "FROM_BLOCK_LEAVES" as r_type,  '
			' (id(block) + "_" + id(leaftrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(leaftrait)) as r_start, '
			' (id(block) + "_" + id(leaftrait) + "_leaf_count_node") as r_end '
		' UNION '
		# branch data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(bbt:BranchBranchTrait) '
					' -[:DATA_FOR*2]->(:PlotBranchTrait) '
					' -[:FOR_TRAIT]->(branchtrait:BranchTrait), '
				' (bbt)'
					' -[:FROM_BRANCH]->(branch:Branch) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (branchtrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(branchtrait)) as d_id, '
			' "Branches" as n_label, '
			' count(DISTINCT branch) as n_name, '
			' (id(plot) + "_" + id(branchtrait) + "_branch_count_node") as n_id,'
			' "FROM_PLOT_BRANCHES" as r_type,  '
			' (id(plot) + "_" + id(branchtrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(branchtrait)) as r_start, '
			' (id(plot) + "_" + id(branchtrait) + "_branch_count_node") as r_end '
			' '
		' UNION '
		#branch data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(bbt:BranchBranchTrait) '
					' -[:DATA_FOR*2]->(:PlotBranchTrait) '
					' -[:FOR_TRAIT]->(branchtrait:BranchTrait), '
				' (bbt) '
					' -[:FROM_BRANCH]->(branch:Branch)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (branchtrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(branchtrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Branches" as n_label, '
			' count(DISTINCT branch) as n_name, '
			' (id(block) + "_" + id(branchtrait) + "_branch_count_node") as n_id,'
			' "FROM_BLOCK_BRANCHES" as r_type,  '
			' (id(block) + "_" + id(branchtrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(branchtrait)) as r_start, '
			' (id(block) + "_" + id(branchtrait) + "_branch_count_node") as r_end '
		' UNION '
		#tree data (from plot but not block, connect to tree counter)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(ttt:TreeTreeTrait) '
					' -[:DATA_FOR]->(:PlotTreeTrait) '
					' -[:FOR_TRAIT]->(treetrait:TreeTrait), '
				' (ttt)-[:FROM_TREE]->(tree:Tree), '
				' (ptt)-[:FROM_PLOT]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (treetrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(treetrait)) as d_id, '
			' "Trees" as n_label, '
			' count(DISTINCT tree) as n_name, '
			' (id(plot) + "_" + id(treetrait) + "_tree_count_node") as n_id,'
			' "FROM_PLOT_TREES" as r_type,  '
			' (id(plot) + "_" + id(treetrait) + "_rel") as r_id, '
			' (id(plot) + "_" + id(treetrait)) as r_start, '
			' (id(plot) + "_" + id(treetrait) + "_tree_count_node") as r_end ' 
		' UNION '
		#tree data (from block)
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(ttt:TreeTreeTrait) '
				' -[:DATA_FOR]->(:PlotTreeTrait) '
				' -[:FOR_TRAIT]->(treetrait:TreeTrait), '
			' (ttt)-[:FROM_TREE]->(tree:Tree) '
				' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (treetrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(treetrait)) as d_id, '
			' "Trees" as n_label, '
			' count(DISTINCT tree) as n_name, '
			' (id(block) + "_" + id(treetrait) + "_tree_count_node") as n_id,'
			' "FROM_BLOCK_TREES" as r_type,  '
			' (id(block) + "_" + id(treetrait) + "_rel") as r_id, '
			' (id(block) + "_" + id(treetrait)) as r_start, '
			' (id(block) + "_" + id(treetrait) + "_tree_count_node") as r_end '
		' UNION '
		#block data
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(bbt:BlockBlockTrait) '
				' -[:DATA_FOR]->(:PlotBlockTrait) '
				' -[:FOR_TRAIT]->(blocktrait:BlockTrait), '
			' (bbt)-[:FROM_BLOCK]->(block:Block) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (blocktrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(blocktrait)) as d_id, '
			' "Block" as n_label, '
			' block.name as n_name, '
			' id(block) as n_id,'
			' "FROM_BLOCK" as r_type,  '
			' (id(block) + "_" + id(blocktrait) + "_rel") as r_id, '
			' (id(block) + "_" + id(blocktrait)) as r_start, '
			' id(block) as r_end '
		'UNION'
		#plot data
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(ppt:PlotPlotTrait) '
				' -[:FOR_TRAIT]->(plottrait:PlotTrait), '
		' 	(ppt)-[:FROM_PLOT]-(plot:Plot) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (plottrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(plottrait)) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id,'
			' "FROM_PLOT" as r_type,  '
			' (id(plot) + "_" + id(plottrait) + "_rel") as r_id, '
			' (id(plot) + "_" + id(plottrait)) as r_start, '
			' id(plot) as r_end '
		' UNION '
		#link blocks into plots
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (block:Block) '
				' WHERE '
					' (data)-[:DATA_FOR*2]->(:TreeSampleTrait) '
					' -[:FROM_TREE]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
				' OR '
					'(data)-[:DATA_FOR]->(:TreeTreeTrait) '
					' -[:FROM_TREE]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
				' OR '
					' (data)-[:DATA_FOR]->(:BlockBlockTrait) '
					' -[:FROM_BLOCK]->(block:Block) '
		' WITH DISTINCT block '
		' MATCH (block)-[:IS_IN*2]->(plot:Plot) '
		' RETURN '
			' "Block" as d_label, '
			' block.name as d_name, '
			' id(block) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(block) + "_" + id(plot)) as r_id, '
			' id(block) as r_start, '
			' id(plot) as r_end'
		' UNION '
		# link plots into farms
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (plot:Plot) '
				' WHERE '
					' (data)-[:DATA_FOR*3]->(:PlotSampleTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
				' OR '
					'(data)-[:DATA_FOR*2]->(:PlotTreeTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
				' OR '
					' (data)-[:DATA_FOR*2]->(:PlotBlockTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
				' OR '
					' (data)-[:DATA_FOR]->(:PlotPlotTrait) '
					' -[:FROM_PLOT]->(plot:Plot) '
		' WITH DISTINCT plot '
		' MATCH (plot)-[:IS_IN]->(farm:Farm) '
		' RETURN '		
			' "Plot" as d_label, '
			' plot.name as d_name, '
			' id(plot) as d_id, '
			' "Farm" as n_label, '
			' farm.name as n_name, '
			' id(farm) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(plot) + "_" + id(farm)) as r_id, '
			' id(plot) as r_start, '
			' id(farm) as r_end'
		' UNION '
		# link farms into regions
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (farm:Farm) '
				' WHERE '
					' (data)-[:DATA_FOR*3]->(:PlotSampleTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
				' OR '
					'(data)-[:DATA_FOR*2]->(:PlotTreeTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
				' OR '
					' (data)-[:DATA_FOR*2]->(:PlotBlockTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
				' OR '
					' (data)-[:DATA_FOR]->(:PlotPlotTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(farm:Farm)'
		' WITH DISTINCT farm '
		' MATCH (farm)-[:IS_IN]->(region:Region) '
		' RETURN '
			' "Farm" as d_label, '
			' farm.name as d_name, '
			' id(farm) as d_id, '
			' "Region" as n_label, '
			' region.name as n_name, '
			' id(region) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(farm) + "_" + id(region)) as r_id, '
			' id(farm) as r_start, '
			' id(region) as r_end'
		' UNION '
		# link regions into countries
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH data '
			' MATCH (region:Region) '
				' WHERE '
					' (data)-[:DATA_FOR*3]->(:PlotSampleTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm) '
					' -[:IS_IN]->(region:Region) '
				' OR '
					'(data)-[:DATA_FOR*2]->(:PlotTreeTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm)'
					' -[:IS_IN]->(region:Region) '
				' OR '
					' (data)-[:DATA_FOR*2]->(:PlotBlockTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm)'
					' -[:IS_IN]->(region:Region) '
				' OR '
					' (data)-[:DATA_FOR]->(:PlotPlotTrait) '
					' -[:FROM_PLOT]->(:Plot) '
					' -[:IS_IN]->(:Farm)'
					' -[:IS_IN]->(region:Region) '
		' WITH DISTINCT region '
		' MATCH (region)-[:IS_IN]->(country:Country) '
		' RETURN '
			' "Region" as d_label, '
			' region.name as d_name, '
			' id(region) as d_id, '
			' "Country" as n_label, '
			' country.name as n_name, '
			' id(country) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(region) + "_" + id(country)) as r_id, '
			' id(region) as r_start, '
			' id(country) as r_end '
	)