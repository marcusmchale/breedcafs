class Cypher:
	def __init__(self):
		pass
	# user procedures
	allowed_emails = (
		' MATCH '
		'	(e: Emails) '
		' RETURN '
		'	e.allowed '
	)
	user_allowed_emails = (
		' MATCH '
		'	(u:User) '
		' WITH '
		'	COLLECT (DISTINCT u.email) as registered_emails '
		' MATCH '
		'	(user:User {'
		'		username_lower : toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(e: Emails) '
		' RETURN '
		'	FILTER (n in e.allowed WHERE NOT n in registered_emails) as user_allowed '
	)
	email_find = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' RETURN '
		'	user '
	)
	confirm_email = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' SET '
		'	user.confirmed = true '
	)
	user_find = (
		' MATCH '
		'	(user: User) '
		'		WHERE '
		'			user.username_lower = toLower($username) '
		'		OR '
		'			user.email = toLower(trim($email)) '
		' RETURN '
		'	user '
	)
	username_find = (
		' MATCH '
		'	(user: User { '
		'		username_lower: toLower($username)'
		'	}) '
		' RETURN '
		'	user '
	)
	user_affiliations = (
		' MATCH '
		'	(u: User { '
		'		username_lower: toLower($username) '
		'	}) '
		'	-[a: AFFILIATED]->(p: Partner) '
		' OPTIONAL MATCH '
		'	(p)<-[: AFFILIATED {admin: true}]-(admin: User) '
		' RETURN '
		'	p.name , '
		'	p.fullname , '
		'	a.confirmed as confirmed, '
		'	a.data_shared as data_shared , '
		'	admin.email as admin_email'
	)
	add_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		}), '
		'		(p:Partner { '
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	MERGE '
		'		(u)-[a: AFFILIATED { '
		'			data_shared: false, '
		'			admin: false, '
		'			confirm_timestamp: [], '
		'			confirmed: false '
		' 		}]->(p) '
		' 	ON CREATE SET '
		'		a.add_timestamp = timestamp() '
		' 	RETURN '
		'		p.name '
	)
	remove_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		 }) '
		'		-[a:AFFILIATED { '
		'			data_shared: false '
		'		}]->(p: Partner {'
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	WHERE '
		'		size(a.confirm_timestamp) = 0 '
		' 	DELETE '
		'		a '
		' 	RETURN p.name '
	)
	password_reset = (
		' MATCH '
		'	(user: User { '
		'		email : toLower(trim($email)) '
		' 	}) '
		' SET user.password = $password '
	)
	user_register = (
		# This is a little cautious using merge to prevent overwriting a user profile if it is called in error
		' MATCH '
		'	(partner:Partner {'
		'		name_lower: toLower(trim($partner)) '
		'	}) '
		' MERGE '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	ON CREATE SET '
		'		user.username = trim($username), '
		'		user.password = $password, ' 
		'		user.email = toLower(trim($email)), '
		'		user.name = $name, '
		'		user.time = timestamp(), '
		'		user.access = ["user"], '
		'		user.confirmed = false, '
		'		user.found = false '
		'	ON MATCH SET '
		'		user.found = TRUE '
		' WITH '
		'	user, partner '	
		' WHERE '
		'	user.found = false '
		' CREATE '
		'	(user)-[r: AFFILIATED { '
		'		data_shared: true, '
		'		confirmed: false, '
		'		confirm_timestamp: [], '
		'		admin: false '				
		'	}]->(partner), '
		'	(user)-[: SUBMITTED]->(sub: Submissions), '
		'		(sub)-[: SUBMITTED]->(: Emails {allowed :[]}),'
		'		(sub)-[: SUBMITTED]->(: Partners), '
		'		(sub)-[: SUBMITTED]->(: Traits), '
		'		(sub)-[: SUBMITTED]->(locations: Locations), '
		'			(locations)-[: SUBMITTED]->(: Countries), '
		'			(locations)-[: SUBMITTED]->(: Regions), '
		'			(locations)-[: SUBMITTED]->(: Farms), '
		'			(locations)-[: SUBMITTED]->(: Fields), '
		'		(sub)-[:SUBMITTED]->(traits:Traits), '
		'			(traits)-[: SUBMITTED]->(: FarmTraits), '
		'			(traits)-[: SUBMITTED]->(: FieldTraits), '
		'			(traits)-[: SUBMITTED]->(: BlockTraits), '
		'			(traits)-[: SUBMITTED]->(: TreeTraits), '
		'			(traits)-[: SUBMITTED]->(: BranchTraits), '
		'			(traits)-[: SUBMITTED]->(: LeafTraits), '
		'			(traits)-[: SUBMITTED]->(: SampleTraits), '
		'		(sub)-[:SUBMITTED]->(varieties:Varieties), '
		'			(varieties)-[: SUBMITTED]->(: Hybrids), '
		'			(varieties)-[: SUBMITTED]->(: Inbreds), '
		'			(varieties)-[: SUBMITTED]->(: Grafts), '
		'		(sub)-[:SUBMITTED]->(items: Items), '
		'			(items)-[: SUBMITTED]->(: Blocks), '
		'			(items)-[: SUBMITTED]->(: Trees), '
		'			(items)-[: SUBMITTED]->(: Branches), '
		'			(items)-[: SUBMITTED]->(: Leaves), '
		'			(items)-[: SUBMITTED]->(: Samples), '
		'		(sub)-[:SUBMITTED]->(data: DataSubmissions) '
	)
	add_allowed_email = (
		' MATCH '
		'	(all: Emails) '
		' WITH '
		'	all.allowed as allowed_emails '
		' UNWIND '
		'	allowed_emails as email '
		' WITH '
		'	COLLECT(DISTINCT email) as set '
		' WHERE '
		'	NOT toLower(trim($email)) IN set '
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' SET e.allowed = e.allowed + [toLower(trim($email))] '
		' RETURN toLower(trim($email)) '
	)
	remove_allowed_email = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' WITH e, extract(x in $email | toLower(trim(x))) as emails'
		' SET e.allowed = FILTER (n in e.allowed WHERE NOT n IN emails) '
		' RETURN emails '
	)
	user_del = (
		' MATCH '
		'	(u:User { '
		'		email: toLower(trim($email)), '
		'		confirmed: false '
		'	}) '
		' OPTIONAL MATCH '
		'	(u)-[:SUBMITTED*..3]->(n) '
		' DETACH DELETE '
		' u,n '
	)
	partner_admin_users = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: AFFILIATED { '
		'		admin: true '
		'	}]->(p:Partner) '
		' WITH p '
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) ' 
		' RETURN { '
		'	Username: u.username, '
		'	Email: u.email, '
		'	Name: u.name, '
		'	Partner: p.name, '
		'	PartnerFullName: p.fullname, '
		'	Confirmed: a.confirmed '
		' } '
	)
	global_admin_users = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.confirmed '
		' } '
	)
	# these functions toggle the confirmed status so do both confirm/un-confirm operations
	partner_confirm_users = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:AFFILIATED {admin : true}]->(p:Partner) '
		' WHERE '
		'	"partner_admin" in user.access'
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(confirm["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(confirm["username"])) '
		' 	SET '
		'		a.confirmed = NOT a.confirmed, '
		'		a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' 	RETURN u.name '
	)
	global_confirm_users = ( 
		' MATCH '
		'	(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' WITH '
		'	p,a,u '
		' WHERE '
		'	p.name_lower = toLower(trim(confirm["partner"])) '
		' AND '
		'	u.username_lower = toLower(trim(confirm["username"])) '
		' SET '
		'	a.confirmed = NOT a.confirmed, '
		'	a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' RETURN u.name '
	)
	partner_admins = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.admin '
		' } '
	)
	confirm_admins = (
		' MATCH '
		'		(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $admins as admin '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(admin["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(admin["username"])) '
		' 	SET '
		'		a.admin = NOT a.admin '
		'	WITH u '
		'		MATCH (u)-[a:AFFILIATED]->(:Partner) '
		'		WITH u, collect(a.admin) as admin_rights '
		'		set u.access = CASE '
		'			WHEN true IN admin_rights '
		'			THEN ["user","partner_admin"] '
		'			ELSE ["user"] '
		'			END '
		' 	RETURN '
		'		u.name '
	)
	# leaf procedures
	leaves_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(user_leaves: Leaves), '
		# and both the FieldBranches and branch id counter nodes
		'	(tree:Tree) '
		'	-[:IS_IN]->(: FieldTrees)'
		'	-[:IS_IN]->(field: Field { '
		'		uid: toInteger($field_uid) '
		'	}) '
		'	<-[:FROM_FIELD]-(field_leaves: FieldLeaves) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: (toInteger($field_uid) + "_leaf")'
		'	}) '
		' WHERE tree.id >= toInteger($start) '
		' AND tree.id <= toInteger($end) '
		' MATCH '
		'	(field)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree)-[: IS_IN {current: True}]->(: BlockTrees)'
		'	-[:IS_IN]->(block: Block) '
		# find treatment details if registered
		' OPTIONAL MATCH '
		'	(tree)-[: IN_TREATMENT_CATEGORY]->(tc: TreatmentCategory) '
		'	-[: FOR_TREATMENT]->(: FieldItemTreatment) '
		'	-[: FOR_TREATMENT]->(treatment: Treatment) '
		# Create links for context TreeLeaves and FieldLeaves
		' MERGE (tree_leaves: TreeLeaves)-[:FROM_TREE]->(tree) '
		' MERGE (tree_leaves)-[:FROM_FIELD]->(field_leaves) '
		# per UserLeaves per FieldLeaves for tracking
		' MERGE (user_leaves)-[:SUBMITTED]->(user_field_leaves: UserFieldLeaves)-[:CONTRIBUTED]->(field_leaves) '
		# per UserFieldLeaves per TreeLeaves for tracking
		' MERGE (user_field_leaves)-[:SUBMITTED]->(user_tree_leaves: UserTreeLeaves)-[:CONTRIBUTED]->(tree_leaves) '
		# create leaf ID's
		' WITH '
		'	tree, id, tree_leaves, user_tree_leaves, '
		'	field.uid as field_uid, '
		'	field.name as field, '
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country, '
		'	treatment, '
		'	collect(distinct tc.category) as categories '
		' WITH '
		'	tree, id, tree_leaves, user_tree_leaves, '
		'	field_uid, '
		'	field,'
		'	block, '
		'	block_uid, '
		'	farm, '
		'	region, '
		'	country, '
		'	collect({ '
		'		name: treatment.name, '
		'		categories: categories '
		'	}) as Treatments '
		' ORDER BY tree.id '
		' UNWIND range(1, toInteger($replicates)) as replicates '
		'	SET '
		'		id._LOCK_ = true '
		'	SET '
		'		id.count = id.count + 1 '
		'	CREATE '
		'		(l: Leaf: Item { '
		'			uid: (field_uid + "_L" + id.count), '
		'			id: id.count, '
		'			replicates: $replicates '
		'		}), '
		# link leaf to TreeLeaves
		'		(l)-[:FROM_TREE]->(tree_leaves), '
		# link UserTreeLeaves to branch with timestamp for submission
		'		(user_tree_leaves)-[:SUBMITTED {time: timestamp()}]->(l) '
		# unlock the id counter node
		'	REMOVE '
		'		id._LOCK_ '
		# return the list of ID's created
		' RETURN { '
		'	Country: country, '
		'	Region: region, '
		'	Farm: farm, '
		'	Field: field, '
		'	`Field UID`: field_uid, '
		'	Block: block, '
		'	`Block UID`: block_uid, '
		'	`Tree UID`: tree.uid, '
		'	`Tree Custom ID`: tree.custom_id, '
		'	Variety: tree.variety, '
		'	UID: l.uid, '
		'	Treatments: Treatments '
		' } '
		' ORDER BY '
		'	l.id '
	)

	leaves_add_block = (
		' MATCH '
		# find the user branch submission node
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(user_leaves: Leaves), '
		# and both the FieldBranches and branch id counter nodes
		'	(tree:Tree) '
		'	-[:IS_IN]->(: BlockTrees)'
		'	-[:IS_IN]->(block: Block { '
		'		uid: $block_uid '
		'	}) '
		'	-[:IS_IN]->(: FieldBlocks) '
		'	-[:IS_IN]->(field: Field { '
		'		uid: toInteger($field_uid) '
		'	}) '
		'	<-[:FROM_FIELD]-(field_leaves: FieldLeaves) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: (toInteger($field_uid) + "_leaf")'
		'	}) '
		' WHERE tree.id >= toInteger($start) '
		' AND tree.id <= toInteger($end) '
		' MATCH '
		'	(field)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# find treatment details if registered
		' OPTIONAL MATCH '
		'	(tree)-[: IN_TREATMENT_CATEGORY]->(tc: TreatmentCategory) '
		'	-[: FOR_TREATMENT]->(: FieldItemTreatment) '
		'	-[: FOR_TREATMENT]->(treatment: Treatment) '
		# Create links for context TreeLeaves and FieldLeaves
		' MERGE (tree_leaves: TreeLeaves)-[:FROM_TREE]->(tree) '
		' MERGE (tree_leaves)-[:FROM_FIELD]->(field_leaves) '
		# per UserLeaves per FieldLeaves for tracking
		' MERGE (user_leaves)-[:SUBMITTED]->(user_field_leaves: UserFieldLeaves)-[:CONTRIBUTED]->(field_leaves) '
		# per UserFieldLeaves per TreeLeaves for tracking
		' MERGE (user_field_leaves)-[:SUBMITTED]->(user_tree_leaves: UserTreeLeaves)-[:CONTRIBUTED]->(tree_leaves) '
		# create leaf ID's
		' WITH '
		'	tree, id, tree_leaves, user_tree_leaves, '
		'	field.uid as field_uid, '
		'	field.name as field,'
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country, '
		'	treatment, '
		'	collect(distinct tc.category) as categories '
		' WITH '
		'	tree, id, tree_leaves, user_tree_leaves, '
		'	field_uid, '
		'	field,'
		'	block, '
		'	block_uid, '
		'	farm, '
		'	region, '
		'	country, '
		'	collect({ '
		'		name: treatment.name, '
		'		categories: categories '
		'	}) as Treatments '
		' ORDER BY tree.id '
		' UNWIND range(1, toInteger($replicates)) as replicates '
		'	SET '
		'		id._LOCK_ = true '
		'	SET '
		'		id.count = id.count + 1 '
		'	CREATE '
		'		(l: Leaf: Item { '
		'			uid: (field_uid + "_L" + id.count), '
		'			id: id.count, '
		'			replicates: $replicates '
		'		}), '
		# link leaf to TreeLeaves
		'		(l)-[:FROM_TREE]->(tree_leaves), '
		# link UserTreeLeaves to branch with timestamp for submission
		'		(user_tree_leaves)-[:SUBMITTED {time: timestamp()}]->(l) '
		# unlock the id counter node
		'	REMOVE '
		'		id._LOCK_ '
		# return the list of ID's created
		' RETURN { '
		'	Country: country, '
		'	Region: region, '
		'	Farm: farm, '
		'	Field: field, '
		'	`Field UID`: field_uid, '
		'	Block: block, '
		'	`Block UID`: block_uid, '
		'	`Tree UID`: tree.uid, '
		'	`Tree Custom ID`: tree.custom_id, '
		'	Variety: tree.variety, '
		'	UID: l.uid, '
		'	Treatments: Treatments '
		' } '
		' ORDER BY '
		'	l.id '
	)

	samples_add_per_tree = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username))}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(samples: Samples), '
		'	(tree:Tree) '
		'	-[:IS_IN]->(: FieldTrees) '
		'	-[:IS_IN]->(: Field { '
		'		uid: toInteger($field_uid) '
		'	}), '
		'	(id:Counter { '
		'		uid: (toInteger($field_uid) + "_sample") '
		'	}) '
		'	-[:FOR]->(field_samples: FieldSamples) '
		'	-[:FROM_FIELD]->(field: Field { '
		'		uid: toInteger($field_uid) '
		'	}) '
		'	-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		' WHERE '
		'	tree.id >= $start '
		' AND '
		'	tree.id <= $end '
		# get block name if available
		' OPTIONAL MATCH '
		'	(tree) '
		'	-[:IS_IN {current: True}]->(: BlockTrees)'
		'	-[:IS_IN]->(block:Block) '
		# find treatment details if registered
		' OPTIONAL MATCH '
		'	(tree)-[: IN_TREATMENT_CATEGORY]->(tc: TreatmentCategory) '
		'	-[: FOR_TREATMENT]->(: FieldItemTreatment) '
		'	-[: FOR_TREATMENT]->(treatment: Treatment) '
		# with the selected trees to be sampled
		' WITH '
		'	tree, '
		'	samples, '
		'	id, '
		'	field_samples, '
		'	block, '
		'	field, '		
		'	farm, '
		'	region, '
		'	country,  '
		'	treatment, '
		'	collect (distinct tc.category) as categories '
		' WITH '
		'	tree, '
		'	samples, '
		'	id, '
		'	field_samples, '
		'	block, '
		'	field, '		
		'	farm, '
		'	region, '
		'	country,  '
		'	collect({ '
		'		name: treatment.name, '
		'		categories: categories '
		'	}) as Treatments '
		' ORDER BY '
		'	tree.id '
		' MERGE '
		'	(tree)<-[:FROM_TREE]-(tree_samples:TreeSamples) '
		# Track user submissions through UserFieldSamples container node
		' MERGE '
		'	(samples)-[:SUBMITTED]->(user_field_samples:UserFieldSamples)-[:CONTRIBUTED]->(field_samples) '
		' WITH '
		'	id, '
		'	tree_samples, '
		'	field_samples, '
		'	user_field_samples, '
		'	tree, '
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	field.name as field, '
		'	field.uid as field_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country, '
		'	Treatments '
		# with replicates
		' UNWIND '
		'	range(1, $replicates) as replicates '
		# incrementing with a Field level counter
		'	SET '
		'		id._LOCK_ = true '
		'	SET '
		'		id.count = id.count + 1 '
		# Create samples
		'	CREATE '
		'		(s: Sample: Item { '
		'			uid: (field_uid + "_S" + id.count), '
		'			id: id.count, '
		'			replicates: $replicates, '
		'			tree_count: 1 '
		'		}) '
		'	REMOVE '
		'		id._LOCK_ '
		# Link the sample to its TreeSamples
		'	MERGE '
		'		(s)-[: FROM_TREE]->(tree_samples) '
		# and the FieldSamples container
		'	MERGE '
		'		(s)-[: FROM_FIELD]->(field_samples) '
		# and user tracking through UserTreeSamples
		'	MERGE  '
		'		(user_field_samples)-[s1:SUBMITTED]->(s) '
		'		ON CREATE SET s1.time = timestamp() '
		'	SET '
		'		id._LOCK_ = false '
		# return for csv
		'	RETURN { '
		'		Country: country, '
		'		Region: region, '
		'		Farm: farm, '
		'		Field: field, '
		'		`Field UID`: field_uid, '
		'		Block: block, '
		'		`Block UID`: block_uid, '
		'		`Tree UID`: tree.uid, '
		'		`Tree Custom ID` : tree.custom_id, '
		'		Variety: tree.variety, '
		'		`UID`: s.uid, '
		'		Treatments: Treatments '
		'	} '
		'	ORDER BY s.id '
	)

	samples_add_per_tree_block = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username))}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(samples: Samples), '
		'	(tree:Tree) '
		'	-[:IS_IN]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block { '
		'		uid: $block_uid '
		'	}), '
		'	(id:Counter { '
		'		uid: (toInteger($field_uid) + "_sample") '
		'	}) '
		'	-[:FOR]->(field_samples: FieldSamples) '
		'	-[:FROM_FIELD]->(field: Field { '
		'		uid: toInteger($field_uid) '
		'	}) '
		'	-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		' WHERE '
		'	tree.id >= $start '
		' AND '
		'	tree.id <= $end '
		# find treatment details if registered
		' OPTIONAL MATCH '
		'	(tree)-[: IN_TREATMENT_CATEGORY]->(tc: TreatmentCategory) '
		'	-[: FOR_TREATMENT]->(: FieldItemTreatment) '
		'	-[: FOR_TREATMENT]->(treatment: Treatment) '
		# with the selected trees to be sampled
		' WITH '
		'	tree, '
		'	samples, '
		'	id, '
		'	field_samples, '
		'	field, '
		'	block, '
		'	farm, '
		'	region, '
		'	country,  '
		'	treatment, '
		'	collect(distinct tc.category) as categories '
		# with the selected trees to be sampled
		' WITH '
		'	tree, '
		'	samples, '
		'	id, '
		'	field_samples, '
		'	field, '
		'	block, '
		'	farm, '
		'	region, '
		'	country,  '
		'	collect({ '
		'		name: treatment.name, '
		'		categories: categories '
		'	}) as Treatments '
		' ORDER BY '
		'	tree.id '
		' MERGE '
		'	(tree)<-[:FROM_TREE]-(tree_samples:TreeSamples) '
		# Track user submissions through UserFieldSamples container node
		' MERGE '
		'	(samples)-[:SUBMITTED]->(user_field_samples:UserFieldSamples)-[:CONTRIBUTED]->(field_samples) '
		' WITH '
		'	id, '
		'	tree_samples, '
		'	field_samples, '
		'	user_field_samples, '
		'	tree, '
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	field.name as field, '
		'	field.uid as field_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country, '
		'	Treatments '
		# with replicates
		' UNWIND '
		'	range(1, $replicates) as replicates '
		# incrementing with a Field level counter
		'	SET '
		'		id._LOCK_ = true '
		'	SET '
		'		id.count = id.count + 1 '
		# Create samples
		'	CREATE '
		'		(s: Sample: Item { '
		'			uid: (field_uid + "_S" + id.count), '
		'			id: id.count, '
		'			replicates: $replicates, '
		'			tree_count: 1 '
		'		}) '
		'	REMOVE '
		'		id._LOCK_ '
		# Link the sample to its TreeSamples
		'	MERGE '
		'		(s)-[: FROM_TREE]->(tree_samples) '
		# and the FieldSamples container
		'	MERGE '
		'		(s)-[: FROM_FIELD]->(field_samples) '
		# and user tracking through UserTreeSamples
		'	MERGE  '
		'		(user_field_samples)-[s1:SUBMITTED]->(s) '
		'		ON CREATE SET s1.time = timestamp() '
		'	SET '
		'		id._LOCK_ = false '
		# return for csv
		'	RETURN { '
		'		Country: country, '
		'		Region: region, '
		'		Farm: farm, '
		'		Field: field, '
		'		`Field UID`: field_uid, '
		'		Block: block, '
		'		`Block UID`: block_uid, '
		'		`Tree UID`: tree.uid, '
		'		`Tree Custom ID` : tree.custom_id, '
		'		Variety: tree.variety, '
		'		`UID`: s.uid, '
		'		Treatments: Treatments '
		'	} '
		'	ORDER BY s.id '
	)

	samples_add_pooled = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username))}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(samples: Samples), '
		'	(id:Counter { '
		'		uid: (toInteger($field_uid) + "_sample") '
		'	}) '
		'	-[:FOR]->(field_samples: FieldSamples) '
		'	-[:FROM_FIELD]->(field: Field { '
		'		uid: toInteger($field_uid) '
		'	}) '
		'	-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# Track user submissions through successive UserFieldSamples then UserTreeSamples container nodes
		' MERGE '
		'	(samples)-[:SUBMITTED]->(user_field_samples:UserFieldSamples)-[:CONTRIBUTED]->(field_samples) '
		' WITH '
		'	id, '
		'	field_samples, '
		'	user_field_samples, '
		'	field.name as field, '
		'	field.uid as field_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		# with replicates
		' UNWIND '
		'	range(1, $sample_count) as sample_count '
		# incrementing with a Field level counter
		'	SET '
		'		id._LOCK_ = true '
		'	SET '
		'		id.count = id.count + 1 '
		# Create samples
		'	CREATE '
		'		(s: Sample: Item { '
		'			uid: (field_uid + "_S" + id.count), '
		'			id: id.count '
		'		}) '
		'	REMOVE '
		'		id._LOCK_ '
		# and the FieldSamples node
		'	MERGE '
		'		(s)-[: FROM_FIELD]->(field_samples) '
		# and user tracking through UserTreeSamples
		'	MERGE  '
		'		(user_field_samples)-[s1:SUBMITTED]->(s) '
		'		ON CREATE SET s1.time = timestamp() '
		'	SET '
		'		id._LOCK_ = false '
		# return for csv
		'	RETURN { '
		'		Country: country, '
		'		Region: region, '
		'		Farm: farm, '
		'		Field: field, '
		'		`Field UID`: field_uid, '
		'		`UID`: s.uid '
		'	} '
		'	ORDER BY s.id '
	)

	# Upload procedures
	upload_check_value = (
		# make sure that all the entries match accepted entries
		# handles empty items and white space
		# forces strings to lower case and float/integer types
		# removes % symbols
		# ! ensure to declare trait (as node) and value (from file) before including
		' CASE '
		'	WHEN trait.format = "multicat" '
		'		THEN CASE '
		'			WHEN size(FILTER (n in split(value, ":") WHERE size(n) > 0)) '
		'				= size(FILTER (n in split(value, ":") WHERE toLower(trim(n)) in '
		'					EXTRACT(item in trait.category_list | toLower(item)))) '
		'			THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "categorical" '
		'		THEN CASE '
		'			WHEN toLower(trim(value)) in extract(item in trait.category_list | toLower(item)) '
		'				THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "text" '
		'		THEN CASE '
		'			WHEN trait.name_lower = "assign to block" '
		'				THEN CASE '
		'					WHEN size(split(value, "_" )) = 2 '
		'					AND left(split(toUpper(value), "_")[1],1) = "B" '
		'					THEN toUpper(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "assign to trees" '
		'				THEN CASE '
		'					WHEN '
		'						size( '
		'							FILTER ('
		'								x in split(value, ",") '
		'								WHERE size(split(trim(toUpper(x)), "_T")) = 2 '
		'								AND toInteger(split(trim(toUpper(x)), "_T")[0]) IS NOT NULL '
		'								AND toInteger(split(trim(toUpper(x)), "_T")[1]) IS NOT NULL '
		'							) '
		'						) > 0 '
		'					THEN '
		'						EXTRACT('
		'							n in FILTER ('
		'								x in split(value, ",") '
		'								WHERE size(split(trim(toUpper(x)), "_T")) = 2 '
		'								AND toInteger(split(trim(toUpper(x)), "_T")[0]) IS NOT NULL '
		'								AND toInteger(split(trim(toUpper(x)), "_T")[1]) IS NOT NULL '
		'							) | toUpper(trim(n)) '
		'						) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "assign to branch" '
		'				THEN CASE '
		'					WHEN size(split(value, "_" )) = 2 '
		'					AND left(split(toUpper(value), "_")[1],1) = "R" '
		'					THEN toUpper(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "assign to leaf" '
		'				THEN CASE '
		'					WHEN size(split(value, "_" )) = 2 '
		'					AND left(split(toUpper(value), "_")[1],1) = "L" '
		'					THEN toUpper(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "variety name" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "variety code" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "synthetic fertiliser n:p:k ratio" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 3 '
		'					AND toFloat(trim(split(value, ":")[0])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[1])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[2])) IS NOT NULL '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name contains "time" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 2 '
		'					AND size(split(value, ":")[0]) <= 2 '
		'					AND toInteger(trim(split(value, ":")[0])) <=24 '
		'					AND toInteger(trim(split(value, ":")[0])) >= 0 '
		'					AND size(split(value, ":")[1]) <= 2 '
		'					AND toInteger(trim(split(value, ":")[1])) < 60 '
		'					AND toInteger(trim(split(value, ":")[1])) >= 0 '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			ELSE '
		'				toString(value) '
		'			END '
		'	WHEN trait.format = "percent" '
		'		THEN CASE '
		'			WHEN toFloat(replace(value, "%", "")) IS NOT NULL '
		'				THEN toFloat(replace(value, "%", "")) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "counter" '
		'		THEN CASE '
		'			WHEN toInteger(value) IS NOT NULL '
		'				THEN toInteger(value) '
		'			ELSE '
		'				Null '
		'			END '
		'	WHEN trait.format = "numeric" '
		'		THEN CASE '
		'			WHEN toFloat(value) IS NOT NULL '
		'				THEN toFloat(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "boolean" '
		'		THEN CASE '
		'			WHEN toLower(value) in ["yes","y"] '
		'				THEN True '
		'			WHEN toLower(value) in ["no","n"] '
		'				THEN False '
		'			WHEN toBoolean(value) IS NOT NULL '
		'				THEN toBoolean(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "location" '
		'		THEN CASE '
		'			WHEN size(split(value, ";")) = 2 '
		'			AND toFloat(trim(split(value, ";")[0])) IS NOT NULL '
		'			AND toFloat(trim(split(value, ";")[1])) IS NOT NULL '
		'				THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "date" '
		'		THEN CASE '
		'			WHEN size(split(value, "-")) = 3 '
		'			AND size(trim(split(value, "-")[0])) = 4 '
		'			AND size(trim(split(value, "-")[1])) <= 2 '
		'			AND size(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) <= 12 '
		'			AND size(trim(split(value, "-")[2])) <= 2 '
		'			AND size(trim(split(value, "-")[2])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) <= 31 '
		'			THEN '
		'				trim(value) '
		'			ELSE '
		'				Null '
		'			END '
		'	ELSE Null '
		'	END '
	)
	shared_upload_code = (
		' FOREACH (n in CASE '
		'	WHEN trait.level = "field" '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(item)<-[: FOR_ITEM]-(:ItemTrait)-[: FOR_TRAIT]->(trait) '
		' ) '
		' FOREACH (n in CASE '
		'	WHEN trait.level in ["block", "tree", "sample"] '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(field)<-[: FROM_FIELD]-(field_trait: FieldItemTrait)-[: FOR_TRAIT]->(trait) '
		'			MERGE '
		'				(item)<-[: FOR_ITEM]-(:ItemTrait)-[: FOR_TRAIT]->(field_trait) '
		' ) '
		' FOREACH (n in CASE '
		'	WHEN trait.level in ["branch", "leaf"] '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(field)<-[: FROM_FIELD]-(field_trait)-[: FOR_TRAIT]->(trait) '
		'			MERGE '
		'				(item)<-[:FOR_ITEM]-(:ItemTrait)-[: FOR_TRAIT]->(field_trait) '
		' ) '
		# get rid of some of the optional matches since they are no longer needed
		' WITH '
		'	field, item, trait, time, replicate, '
		'	person, '
		'	location, timestamp, text_time, text_date, '
		+ upload_check_value + ' AS value WHERE value IS NOT NULL '
		# get the user submission tracking nodes
		' MATCH '
		'	(:User { '
		'		username_lower : toLower(trim($username))'
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(data_sub: DataSubmissions) '
		# and the item/trait node
		' MATCH '
		' (item)<-[ :FOR_ITEM]-(item_trait)-[ :FOR_TRAIT*..2]->(trait) '
		# Perform optional matches so can modify relationships for some traits
		#
		# In case trait "assign to block"
		# if has block assignment find current IS_IN block-trees rel (to remove current flag) and counter (to decrement)
		' OPTIONAL MATCH '
		'	(item) '
		'		-[is_in_block_current:IS_IN {current: True}]->(: BlockTrees)'
		'		<-[:FOR]-(block_counter_current:Counter) '
		# and then find the block by uid for update of IS_IN block-trees rel and counter 
		' OPTIONAL MATCH '
		'	(block_counter_update: Counter) '
		'	-[: FOR]->(block_trees_update: BlockTrees) '
		'	-[: IS_IN]->(: Block {uid: value}) '
		'	-[: IS_IN]->( :FieldBlocks)'
		'	-[: IS_IN]->(field) '
		# Using many with statements around long optional match blocks
		# otherwise there is a database error I haven't diagnosed
		' WITH '
		'	field, item, trait, item_trait, time, replicate, value, data_sub, '
		'	person, '
		'	location, timestamp, text_time, text_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update '		   
		# In case trait "assign to trees"
		# if item already has tree assignment find current
		' OPTIONAL MATCH '
		'	(item)-[from_tree_current: FROM_TREE]->(:TreeSamples) '
		'		-[: FROM_TREE]->(:Tree) '
		# and update tree by uid
		' OPTIONAL MATCH '
		'	(tree_update: Tree)-[: IS_IN*2]->(field) '
		'	WHERE tree_update.uid in value '
		' WITH '
		'	field, item, trait, item_trait, time, replicate, value, data_sub, '
		'	person, '
		'	location, timestamp, text_time, text_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	collect(from_tree_current) as from_tree_current, '
		'	collect(tree_update) as tree_update '
		# In case trait "assign to branch"
		# if item has branch assignment find current
		' OPTIONAL MATCH '
		'	(item)-[from_branch_current: FROM_BRANCH]->(: Branch) '
		# and update branch by uid
		' OPTIONAL MATCH '
		'	(branch_update: Branch {uid: value}) '
		' WITH '
		'	field, item, trait, item_trait, time, replicate, value, data_sub, '
		'	person, '
		'	location, timestamp, text_time, text_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	from_tree_current, tree_update, '
		'	from_branch_current, branch_update '
		# In case when trait "assign to leaf"
		# find current leaf assignment
		' OPTIONAL MATCH '
		'	(item)-[from_leaf_current:FROM_LEAF]->(:Leaf) '
		# and update leaf by uid
		' OPTIONAL MATCH '
		'	(leaf_update: Leaf {uid: value}) '
		' WITH '
		'	field, item, trait, item_trait, time, replicate, value, data_sub, '
		'	person, '
		'	location, timestamp, text_time, text_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	from_tree_current, tree_update, '
		'	from_branch_current, branch_update, '
		'	from_leaf_current, leaf_update '	
		# In case trait is "variety name " or "variety code" 
		# find current variety assignment
		' OPTIONAL MATCH '
		'	(item)-[is_variety_current: IS_VARIETY]->()-[:IS_VARIETY]->(:Variety) '
		# find variety by name
		' OPTIONAL MATCH '
		'	(variety_name_update:Variety {name_lower: toLower(toString('
		'		CASE WHEN trait.name_lower in ["variety name", "variety code"] THEN value ELSE null END))}) '
		# or by code
		' OPTIONAL MATCH '
		'	(variety_code_update:Variety {el_frances_code_lower: toLower(toString('
		'		CASE WHEN trait.name_lower in ["variety name", "variety code"] THEN value ELSE null END))}) '
		' WITH '
		'	field, item, trait, item_trait, time, replicate, value, data_sub, '
		'	person, '
		'	location, timestamp, text_time, text_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	from_tree_current, tree_update, '
		'	from_branch_current, branch_update, '
		'	from_leaf_current, leaf_update, '
		'	is_variety_current, '
		'	CASE '
		'		WHEN variety_name_update IS NOT NULL AND variety_code_update IS NULL '
		'		THEN variety_name_update '
		'		WHEN variety_name_update IS NULL AND variety_code_update IS NOT NULL '
		'		THEN variety_code_update '
		'		ELSE Null END as variety_update '
		# Merge the data point to ensure unique to the time and item/trait node
		' MERGE '
		'	(d:Data { '
		'		time : time, '
		'		replicate: CASE WHEN replicate IS NULL THEN 1 ELSE toInteger(replicate) END '
		'	}) '
		'	-[:DATA_FOR]->(item_trait) '
		'	ON MATCH SET '
		'		d.found = True '
		'	ON CREATE SET '
		'		d.found = False, '
		'		d.location = location, '
		'		d.person = person, '
		'		d.timestamp = timestamp, '
		'		d.text_date = text_date, '
		'		d.text_time = text_time, '
		'		d.value = CASE '
		' 			WHEN trait.format <> "multicat" THEN value '
		'			ELSE extract(i in FILTER (n in split(value, ":") WHERE  size(n) > 0 )| toLower(trim(i)))'
		'			END '
		# additional statements to occur when new data point
		' FOREACH (n IN CASE '
		'		WHEN d.found = False '
		'			THEN [1] ELSE [] END | '
		# track user submissions through /User/Trait container
		'				MERGE '
		'					(data_sub)-[:SUBMITTED]->(ut) '
		'					-[:CONTRIBUTED]->(trait) '
		# then /UserTrait/ItemTrait container
		'				MERGE '
		'					(ut)-[:SUBMITTED]->(uit:UserItemTrait) '
		'					-[:CONTRIBUTED]->(item_trait) '
		# then finally the data with a timestamp
		'				MERGE '
		'					(uit)-[s1:SUBMITTED]->(d) '
		'					ON CREATE SET '
		'						s1.time = timestamp() '
		' ) '
		# Now update "special" trait values
		# if "assign to block" 
		' FOREACH (n IN CASE '
		'	WHEN d.value = value '
		'	AND trait.level = "tree" '
		'	AND trait.name_lower = "assign to block" '
		'	AND block_trees_update IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# link tree to block (and track number of trees in block with counter)
		'			MERGE '
		'				(item)-[s1:IS_IN]->(block_trees_update) '
		'			ON CREATE SET '
		'				s1.time = timestamp(), '
		'				s1.user = $username, '
		'				s1.from = "upload" '
		'			SET '
		'				block_counter_current._LOCK_ = true, '
		'				block_counter_update._LOCK_ = true '
		'			SET '
		'				is_in_block_current.current = False, '
		'				s1.current = True, '
		'				block_counter_current.count = block_counter_current.count - 1, '
		'				block_counter_update.count = block_counter_update.count + 1 '
		'			REMOVE '
		'				block_counter_current._LOCK_, '
		'				block_counter_update._LOCK_ '
		' ) '		   
		# if trait is branch id then link to branch
		' FOREACH (n IN CASE '
		'	WHEN d.value = value '
		'	AND trait.level in ["leaf","sample"] '
		'	AND trait.name_lower = "assign to branch" '
		'	AND branch_update IS NOT NULL '
		'	THEN [1] ELSE [] END | '
		'		DELETE from_branch_current '
		'		MERGE '
		'			(item)-[s1:FROM_BRANCH]->(branch_update) '
		'		ON CREATE SET '
		'			s1.time = timestamp(), '
		'			s1.user = $username '
				
		' ) '
		# if trait is leaf id then link to leaf
		' FOREACH (n IN CASE '
		'	WHEN d.value = value '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower = "assign to leaf" '
		'	AND leaf_update IS NOT NULL '
		'	THEN [1] ELSE [] END | '
		'		DELETE from_leaf_current'
		'		MERGE '
		'			(item)-[s1:FROM_LEAF]->(leaf_update) '
		'		ON CREATE SET '
		'			s1.time = timestamp(), '
		'			s1.user = $username '
		' ) '
		# if variety trait
		' FOREACH (n IN CASE '
		'	WHEN d.value = value '
		'	AND trait.level = "tree" '
		'	AND trait.name_lower IN ["variety name", "variety code"] '
		'	AND variety_update IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# Create per Field per Variety node
		'			DELETE is_variety_current '
		'			MERGE '
		'				(field)<-[: FROM_FIELD]-(field_variety) '
		'				-[: IS_VARIETY]->(variety_update) '
		'			MERGE '
		'				(item)-[s1: IS_VARIETY]->(field_variety) '
		'			ON CREATE SET '
		'				s1.time = timestamp(), '
		'				s1.user = $username, '
		# also set the tree variety property
		'				item.variety = variety_update.name '
		' ) '
		# if sample tissue type set custom id parameter.
		' SET item.tissue = CASE '
		'	WHEN d.value = value '
		'	AND d.value IS NOT NULL '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower = "tissue type" '
		'	THEN d.value '
		'	ELSE item.tissue ' 
		'	END '
		# if sample harvest condition set custom id parameter. 
		' SET item.harvest_condition = CASE '
		'	WHEN d.value = value '
		'	AND d.value IS NOT NULL '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower = "harvest condition" '
		'	THEN d.value '
		'	ELSE item.harvest_condition '
		'	END '
		# if sample harvest date set custom id parameter.
		' SET item.harvest_text_date = CASE '
		'	WHEN d.value = value '
		'	AND d.value IS NOT NULL '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower = "harvest date" '
		'	THEN d.value '
		'	ELSE item.harvest_text_date '
		'	END '
		# if sample harvest date set custom id parameter.
		' SET item.harvest_text_time = CASE '
		'	WHEN d.value = value '
		'	AND d.value IS NOT NULL '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower = "harvest time" '
		'	THEN d.value '
		'	ELSE item.harvest_text_time '
		'	END '
		# if sample date or time trait and date is set then calculate time (optionally with time if also set) 
		' SET item.harvest_time = CASE ' 
		'	WHEN d.value = value '
		'	AND d.value IS NOT NULL '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower IN ["harvest time", "harvest date"] '
		'	AND item.harvest_text_date IS NOT NULL '
		'	THEN CASE '
		'		WHEN item.harvest_text_time IS NULL '
		'		THEN '
		'			apoc.date.parse(item.harvest_text_date + " 12:00", "ms", "yyyy-MM-dd HH:mm") '
		'		ELSE '
		'			apoc.date.parse(item.harvest_text_date + " " + item.harvest_text_time, "ms", "yyyy-MM-dd HH:mm") '
		'		END '
		'	ELSE item.harvest_time '
		'	END '
		# if custom tree ID set custom id parameter. 
		' SET item.custom_id = CASE '
		'	WHEN d.value = value '
		'	AND d.value IS NOT NULL '
		'	AND trait.level = "tree" '
		'	AND trait.name_lower = "custom tree id" '
		'	THEN toString(d.value) '
		'	ELSE item.custom_id '
		'	END '
		# if trait is tree id for pooled samples then link to trees
		' FOREACH (n IN CASE '
		'	WHEN d.value = value '
		'	AND trait.level = "sample" '
		'	AND trait.name_lower = "assign to trees" '
		'	THEN [1] ELSE [] END | '
		'		FOREACH (current_from_tree_rel in from_tree_current | '
		'			DELETE current_from_tree_rel '
		'		) '
		'		FOREACH (sampled_tree in tree_update | '					   
		'			MERGE '
		'				(tree_samples: TreeSamples)-[: FROM_TREE]->(sampled_tree) '
		'			MERGE '
		'				(item)-[s1: FROM_TREE]->(tree_samples) '
		'			ON CREATE SET '
		'				s1.time = timestamp(), '
		'				s1.user = $username '
		'		) '
		' 	) '
		' WITH '
		# Flattening the unwind from above foreach (tree_update) with distinct d
		'	d, value, item, trait, timestamp '
		' MATCH '
		'	(user:User)-[:SUBMITTED*..7]->()-[submitted:SUBMITTED]->(d) '
		# And give the user feedback on their submission success
		' RETURN { '
		'	found: d.found, '
		'	submitted_by: user.name, '
		'	submitted_at: submitted.time, '
		'	value: d.value, '
		'	uploaded_value: value, '
		'	uid: item.uid, '
		'	trait: trait.name, '
		'	time: d.time, '
		'	timestamp: d.timestamp, '
		'	text_date: d.text_date, '
		'	text_time: d.text_time '
		' } '
	)
	# generic upload to handle mixed UID (multiple levels) in csv in database format
	upload_fb_check = (
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	split(trim(toUpper(csvLine.uid)), ".")[0] as uid, '
		'	trim(toLower(csvLine.trait)) as trait_name_lower, '
		'	trim(csvLine.value) as value '
		# Identify the items and traits assessed
		' OPTIONAL MATCH '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					uid '
		'				END '
		'	})'
		' OPTIONAL MATCH '
		'	(trait: Trait { '
		'		name_lower: trait_name_lower, '
		'		level: '
		'			CASE '
		'				WHEN split(uid, "_")[1] IS NULL '
		'					THEN "field" '
		'				WHEN left(split(uid, "_")[1],1) = "B" '
		'					THEN "block" '
		'				WHEN left(split(uid, "_")[1],1) = "T" '
		'					THEN "tree" '
		'				WHEN left(split(uid, "_")[1],1) = "R" '
		'					THEN "branch" '
		'				WHEN left(split(uid, "_")[1],1) = "L" '
		'					THEN "leaf" '
		'				WHEN left(split(uid, "_")[1],1) = "S" '
		'					THEN "sample" '
		'				END '
		'	}) '
		' 	WITH '
		'		CASE WHEN item IS NULL THEN False ELSE True END as item, '
		'		CASE WHEN trait IS NULL THEN False ELSE trait.name_lower END as trait, '
		'		trait.format as format, '
		'		trait.category_list as category_list, '
		'		CASE WHEN item IS NOT NULL AND trait IS NOT NULL '
		'			THEN '
		'				CASE WHEN ' + upload_check_value +
		'				IS NULL THEN False ELSE True END '
		'			ELSE False '
		'			END '
		'			as value ' 
		' RETURN { '
		'	uid: item, '
		'	trait: trait, '
		'	format: format,'
		'	category_list: category_list,'
		'	value: value '
		' } '
	)
	upload_fb = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	trim(csvLine.location) as location, '
		'	trim(csvLine.person) as person, '
		'	split(trim(toUpper(csvLine.uid)), ".")[0] as uid, '
		'	split(trim(toUpper(csvLine.uid)), ".")[1] as replicate, ' 
		'	toLower(trim(csvLine.trait)) as trait_name_lower, '
		'	csvLine.timestamp as timestamp, '
		'	trim(csvLine.value) as value, '
		'	apoc.date.parse(csvLine.timestamp, "ms", "yyyy-MM-dd HH:mm:sszzz") as time '
		# Identify the items and traits assessed
		' MATCH '
		'	(field:Field { '
		'		uid: toInteger(split(uid, "_")[0]) '
		'	}), '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					uid '
		'				END '
		'	}), '
		'	(trait: Trait { '
		'		name_lower: trait_name_lower, '
		'		level: '
		'			CASE '
		'				WHEN split(uid, "_")[1] IS NULL '
		'					THEN "field" '
		'				WHEN left(split(uid, "_")[1],1) = "B" '
		'					THEN "block" '
		'				WHEN left(split(uid, "_")[1],1) = "T" '
		'					THEN "tree" '
		'				WHEN left(split(uid, "_")[1],1) = "R" '
		'					THEN "branch" '
		'				WHEN left(split(uid, "_")[1],1) = "L" '
		'					THEN "leaf" '
		'				WHEN left(split(uid, "_")[1],1) = "S" '
		'					THEN "sample" '
		'				END '
		'	}) '
		'	WHERE size(value) > 0 '
		' WITH '
		'	field, item, trait, '
		'	person, time, replicate, '
		'	value, '
		# this is unique to FB uploads
		'	timestamp, '
		'	location, '
		# the following are nulls where table has values to allow shared code between formats
		'	null as text_time, '
		'	null as text_date '
		'	WHERE time IS NOT NULL '
		+ shared_upload_code
	)
	# Upload Table procedures
	upload_table_check = (
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine, '
		'	split(trim(toUpper(csvLine.uid)), ".")[0] as uid  '
		' OPTIONAL MATCH  '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					toUpper(uid) '
		'				END '
		'	}) '
		' UNWIND $traits as trait_name '
		'	OPTIONAL MATCH '
		'		(trait: Trait { '
		'			name_lower: toLower(trait_name), '
		'			level: '
		'				CASE '
		'					WHEN split(uid, "_")[1] IS NULL '
		'						THEN "field" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "B" '
		'						THEN "block" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "T" '
		'						THEN "tree" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "R" '
		'						THEN "branch" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "L" '
		'						THEN "leaf" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "S" '
		'						THEN "sample" '
		'					END '
		'		}) '
		'	WITH item, trait, csvLine[trait_name] as value '
		' 	WITH '
		'		CASE WHEN item IS NULL THEN False ELSE True END as item, '
		'		CASE WHEN trait IS NULL THEN False ELSE trait.name_lower END as trait, '
		'		trait.format as format, '
		'		trait.category_list as category_list,'
		'		CASE WHEN item IS NOT NULL AND trait IS NOT NULL '
		'			THEN '
		'				CASE WHEN ' + upload_check_value +
		'				IS NULL THEN False ELSE True END '
		'			ELSE False '
		'			END '
		'			as value ' 
		' RETURN { '
		'	uid: item, '
		'	trait: trait, '
		'	format: format,'
		'	category_list: category_list,'
		'	value: value '
		' } '
	)
	upload_table = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine, '
		'	trim(csvLine.person) as person, '
		'	split(trim(toUpper(csvLine.uid)), ".")[0] as uid, '
		'	split(trim(toUpper(csvLine.uid)), ".")[1] as replicate, '
		'	apoc.date.parse( '
		'		CASE '
		'			WHEN size(split(replace(csvLine.date, " ", ""), "-")) = 3 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[0]) = 4 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[1]) <=2 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[1]) >=1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[1]) >= 1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[1]) <= 12 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[2]) <=2 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[2]) >=1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[2]) >= 1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[2]) <= 31 '
		'			THEN '
		'				replace(csvLine.date, " ", "") '
		'			ELSE '
		'				Null '
		'			END '
		'		+ " " + '
		'		CASE '
		'			WHEN size(split(replace(csvLine.time, " ", ""), ":")) = 2 '
		'			AND size(split(replace(csvLine.time, " ", ""), ":")[0]) <= 2 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[0]) <=24 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[0]) >= 0 '
		'			AND size(split(replace(csvLine.time, " ", ""), ":")[1]) <= 2 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[1]) <=60 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[1]) >=0 '
		'			THEN '
		'				replace(csvLine.time, " ", "") '
		'			ELSE '
		'				"12:00" '
		'			END '
		'		, "ms", "yyyy-MM-dd HH:mm") as time '
		# And identify the fields and traits assessed
		' MATCH  '
		'	(field:Field { '
		'		uid: toInteger(split(uid, "_")[0]) '
		'	}), '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					toUpper(uid) '
		'				END '
		'	}) '
		' UNWIND $traits as trait_name '
		'	MATCH '
		'		(trait: Trait { '
		'			name_lower: toLower(trait_name), '
		'			level: '
		'				CASE '
		'					WHEN split(uid, "_")[1] IS NULL '
		'						THEN "field" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "B" '
		'						THEN "block" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "T" '
		'						THEN "tree" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "R" '
		'						THEN "branch" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "L" '
		'						THEN "leaf" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "S" '
		'						THEN "sample" '
		'					END '
		'		}) '
		# Check for data in table
		# all load_csv values are string so can just check size after trimming whitespace  
		'	WHERE size(csvLine[trait_name]) > 0 '
		'	WITH '
		'		field, item, trait, '
		'		person, time, replicate, '
		'		csvLine[trait_name] as value, '
		# these are unique to table uploads
		' 		csvLine.time as text_time, '
		'		csvLine.date as text_date, '
		# the following are null where FB has values to allow shared code between formats
		'		null as timestamp, '
		'		null as location '
		' 		WHERE time IS NOT Null '
		+ shared_upload_code
	)
	get_fields_treecount = (
		' MATCH (country:Country)<-[:IS_IN]-(region: Region) '
		' OPTIONAL MATCH (region)<-[:IS_IN]-(farm: Farm) '
		' OPTIONAL MATCH (farm)<-[:IS_IN]-(field: Field) '
		' OPTIONAL MATCH '
		'	(field)'
		'	<-[:IS_IN]-(:FieldTrees)'
		'	<-[:FOR]-(field_tree_counter:Counter {name:"tree"}) '
		' OPTIONAL MATCH '
		'	(field)'
		'	<-[:IS_IN*2]-(block:Block)'
		'	<-[:IS_IN]-(:BlockTrees)'
		'	<-[:FOR]-(block_tree_counter:Counter {name:"tree"}) '
		' WITH '
		'	country, '
		'	region, '
		'	farm, '
		'	field, '
		'	field_tree_counter.count as field_trees, '
		'	{'
		'		name: block.name, '
		'		label:"Block", '
		'		treecount: block_tree_counter.count '
		'	} as blocks, '
		'	block_tree_counter.count as block_trees '
		' WITH '
		'	country, '
		'	region, '
		'	farm, '
		'	{ '
		'		name: field.name, '
		'		label:"Field", '
		'		treecount: field_trees - sum(block_trees), '
		'		children: FILTER(block IN collect(blocks) WHERE block["name"] IS NOT NULL)'
		'	} as fields '
		' WITH '
		'	country, '
		'	region, '
		'	{'
		'		name: farm.name, '
		'		label: "Farm", '
		'		children: FILTER(field IN collect(fields) WHERE field["name"] IS NOT NULL)'
		'	} as farms '
		' WITH '
		'	country, '
		'	{'
		'		name: region.name, '
		'		label:"Region", '
		'		children: FILTER(farm IN collect(farms) WHERE farm["name"] IS NOT NULL)'
		'	} as regions '
		' WITH '
		'	{'
		'		name: country.name, '
		'		label:"Country", '
		'		children: FILTER(region IN collect (regions) WHERE region["name"] IS NOT NULL)'
		'	} as countries '
		' RETURN countries '
	)
	get_submissions_range = (
		# first get all the data collections and link to a base node formed from block/field/farm
		' MATCH '
		'	(:User {username_lower: toLower($username)}) '
		'		-[:SUBMITTED*4]->() '
		'		-[s:SUBMITTED]->(data: Data) '
		'		-[:DATA_FOR]->(dit) '
		'		-[:FOR_TRAIT*..2]->(trait: Trait), '
		'	(dit) '
		'		-[:FOR_ITEM]->(item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' OPTIONAL MATCH '
		'	(item)-[:FROM_TREE*2]->(tree_item_tree:Tree) '
		' OPTIONAL MATCH '
		'	(tree_item_tree)-[:IS_IN {current: True}]-() '
		'	-[:IS_IN]->(tree_item_block: Block) '
		'	-[:IS_IN*2]->(tree_item_block_field: Field) '
		' OPTIONAL MATCH '
		'	(tree_item_tree)-[:IS_IN*2]->(tree_item_field: Field) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN {current: True}]-()'
		'	-[:IS_IN]->(tree_block: Block) '
		'	-[:IS_IN*2]->(tree_block_field: Field) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN*2]->(tree_field) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN*2]->(block_field: Field) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN]->(field_farm:Farm) '
		' RETURN '
		'	"Trait" as d_label, '
		'	trait.name + " (" + count(distinct(data)) + ")" as d_name, '
		'	COALESCE( '
		'		id(tree_item_block), '
		'		id(tree_item_field), '
		'		id(tree_block), '
		'		id(tree_field), '
		'		id(block_field), '
		'		id(field_farm) '
		'		) + "_" + id(trait) as d_id, '
		'	filter(i IN labels(item) WHERE i <> "Item")[0] as n_label, '
		'	CASE WHEN '
		'		trait.level in ["sample", "leaf", "branch", "tree"] '
		'		THEN '
		'			count(DISTINCT item) '
		'		ELSE '
		'			item.name '
		'		END '	
		'	 	as n_name,'
		'	CASE WHEN '
		'		trait.level in ["sample", "leaf", "branch", "tree"] '
		'		THEN '
		'			COALESCE( '
		'				id(tree_item_block), '
		'				id(tree_item_field), '
		'				id(tree_block), '
		'				id(tree_field) '
		'				) + "_" + id(trait) + filter(i IN labels(item) WHERE i <> "Item")[0] + "_count_node" '
		'		ELSE '
		'			id(item) '
		'		END '
		'		as n_id, '
		'	"FROM" as r_type, '
		'	COALESCE( '
		'		id(tree_item_block), '
		'		id(tree_item_field), '
		'		id(tree_block), '
		'		id(tree_field), '
		'		id(block_field), '
		'		id(field_farm) '
		'		) + "_" + id(trait) + filter(i IN labels(item) WHERE i <> "Item")[0] + "_data_node" as r_id, '
		'	COALESCE( '
		'		id(tree_item_block), '
		'		id(tree_item_field), '
		'		id(tree_block), '
		'		id(tree_field), '
		'		id(block_field), '
		'		id(field_farm) '
		'		) + "_" + id(trait) as r_start, '
		'	CASE WHEN '
		'		trait.level in ["sample", "leaf", "branch", "tree"] '
		'		THEN '
		'			COALESCE( '
		'				id(tree_item_block), '
		'				id(tree_item_field), '
		'				id(tree_block), '
		'				id(tree_field) '
		'				) + "_" + id(trait) + filter(i IN labels(item) WHERE i <> "Item")[0] + "_count_node" '
		'		ELSE '
		'			id(item) '
		'		END '
		'		as r_end '
		' UNION '
		# link the above into block context where relevant
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >= $starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN {current: True}]->(:BlockTrees) '
		'	-[:IS_IN]->(tree_item_block:Block)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN {current: True}]->(:BlockTrees) '
		'	-[:IS_IN]->(tree_block:Block) '
		' WITH distinct(COALESCE(tree_item_block, tree_block)) as block '
		' MATCH (block)-[:IS_IN*2]->(field:Field) '
		' RETURN '
			' "Block" as d_label, '
			' block.name as d_name, '
			' id(block) as d_id, '
			' "Field" as n_label, '
			' field.name as n_name, '
			' id(field) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(block) + "_" + id(field)) as r_id, '
			' id(block) as r_start, '
			' id(field) as r_end'
		' UNION '
		# and then blocks into fields
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_block: Block)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(tree_block: Block) '
		' WITH distinct(COALESCE('
		'	tree_item_block, '
		'	tree_block, '
		'	CASE WHEN "Block" in labels(item) THEN item END '
		'	)) as block '
		' WHERE block IS NOT NULL'
		' MATCH (block)-[:IS_IN*2]->(field:Field) '
		' RETURN '
		' "Block" as d_label, '
		' block.name as d_name, '
		' id(block) as d_id, '
		' "Field" as n_label, '
		' field.name as n_name, '
		' id(field) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(block) + "_" + id(field)) as r_id, '
		' id(block) as r_start, '
		' id(field) as r_end'
		' UNION '
		# and then fields into farms
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_field: Field)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(field_item_field: Field) '
		' WITH distinct(COALESCE(tree_item_field, field_item_field, item)) as field '
		' MATCH (field)-[:IS_IN]->(farm:Farm) '
		' RETURN '
		' "Field" as d_label, '
		' field.name as d_name, '
		' id(field) as d_id, '
		' "Farm" as n_label, '
		' farm.name as n_name, '
		' id(farm) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(field) + "_" + id(farm)) as r_id, '
		' id(field) as r_start, '
		' id(farm) as r_end'
		' UNION '
		# and then farms into regions
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_field: Field)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(field_item_field: Field) '
		' WITH distinct(COALESCE(tree_item_field, field_item_field, item)) as field '
		' MATCH '
		'	(field)-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		' RETURN '
		' "Farm" as d_label, '
		' farm.name as d_name, '
		' id(farm) as d_id, '
		' "Region" as n_label, '
		' region.name as n_name, '
		' id(region) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(farm) + "_" + id(region)) as r_id, '
		' id(farm) as r_start, '
		' id(region) as r_end '
		' UNION '
		# and then regions into countries
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_field: Field)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(field_item_field: Field) '
		' WITH distinct(COALESCE(tree_item_field, field_item_field, item)) as field '
		' MATCH '
		'	(field)-[:IS_IN]->(:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		' RETURN '
		' "Region" as d_label, '
		' region.name as d_name, '
		' id(region) as d_id, '
		' "Country" as n_label, '
		' country.name as n_name, '
		' id(country) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(region) + "_" + id(country)) as r_id, '
		' id(region) as r_start, '
		' id(country) as r_end '
	)
	match_record_submission_node = (
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(rs: RecordSubmissions) '
		' RETURN rs '
	)

	merge_record_submission_node = (
		' MERGE (:User {username_lower: toLower($username)}) '
		'	-[: SUBMITTED]->(sub: Submissions) '
		' MERGE (sub) '
		'	-[: SUBMITTED]->(: RecordSubmissions) '
	)
