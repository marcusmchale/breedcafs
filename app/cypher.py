class Cypher():
#user procedures
	allowed_emails = ( ' MATCH (e:Emails) '
		' RETURN e.allowed ' )
	user_allowed_emails = ( ' MATCH (u:User) '
		' WITH COLLECT (DISTINCT u.email) as registered_emails '
		' MATCH (:User {username : $username}) '
		' -[:SUBMITTED]->(:Submissions) '
		' -[:SUBMITTED]->(e:Emails) '
		' RETURN FILTER (n in e.allowed WHERE NOT n in registered_emails) as user_allowed' )
	user_find = ('MATCH (user:User) '
	' WHERE user.username = $username '
	' OR user.email = $email '
	' RETURN user ')
	user_affiliations = (' MATCH (u:User {username : $username}) '
		' -[a:AFFILIATED]->(p:Partner) '
		' OPTIONAL MATCH (p)<-[:AFFILIATED {admin : true}]-(admin:User) '
		' RETURN p.name , '
			' p.fullname , '
			' a.confirmed as confirmed, '
			' a.data_shared as data_shared , '
			' admin.email as admin_email' )
	add_affiliations = ( ' UNWIND $partners as partner '
		' MATCH (u:User {username : $username}) '
		' MATCH (p:Partner {name : partner}) '
		' MERGE (u)-[a:AFFILIATED { '
			' data_shared : false, '
			' admin : false, '
			' confirm_timestamp : [], '
			' confirmed : false '
		' }]->(p) '
		' ON CREATE SET a.add_timestamp = timestamp() '
		' RETURN p.name ')
	remove_affiliations = (	' UNWIND $partners as partner '
		' MATCH (u:User {username: $username}) '
		' -[a:AFFILIATED {data_shared:false}]->(p:Partner {name:partner}) '
		' WHERE size(a.confirm_timestamp) = 0 '
		' DELETE a '
		' RETURN p.name ')
	username_find = ('MATCH (user:User {username : $username}) '
		' RETURN user ')
	email_find = ('MATCH (user:User {email : $email} '
		'RETURN user ')
	confirm_email = ('MATCH (user:User {email : $email}) '
		' SET user.confirmed = true ')
	password_reset = ('MATCH (user:User {email : $email}) '
		' SET user.password = $password ')
	user_register = ('MATCH (partner:Partner {name:$partner}) '
		' CREATE ' 
			' (user:User {username : $username, '
					' password : $password, ' 
					' email : $email, '
					' name : $name, '
					' time : timestamp(), '
					' access : ["user"], '
					' confirmed : false}) '
				' -[r:AFFILIATED { '
					' data_shared : true, '
					' confirmed : false, '
					' confirm_timestamp : [], '
					' admin : false '
				'}] -> (partner), '
			' (user)-[:SUBMITTED]->(sub:Submissions), '
			' (sub)-[:SUBMITTED]->(:Emails {allowed :[]}),'
			' (sub)-[:SUBMITTED]->(locations:Locations), '
				' (locations)-[:SUBMITTED]->(:Countries), '
				' (locations)-[:SUBMITTED]->(:Regions), '
				' (locations)-[:SUBMITTED]->(:Farms), '
				' (locations)-[:SUBMITTED]->(:Plots), '
			' (sub)-[:SUBMITTED]->(items:Items), '
				' (items)-[:SUBMITTED]->(:Blocks), '
				' (items)-[:SUBMITTED]->(:Trees), '
				' (items)-[:SUBMITTED]->(:Samples), '
			' (sub)-[:SUBMITTED]->(data:DataSub), '
				'(data)-[:SUBMITTED]->(:FieldBook)'
			' ')
	add_allowed_email = ( ' MATCH (all:Emails) '
		' WITH all.allowed as allowed_emails '
		' UNWIND allowed_emails as email '
		' WITH collect(DISTINCT email) as set '
		' WHERE NOT $email IN set '
		' MATCH (:User {username : $username}) '
		' -[:SUBMITTED]->(:Submissions) '
		' -[:SUBMITTED]->(e:Emails) '
		' SET e.allowed = e.allowed + [$email] '
		' RETURN $email ' )
	user_del = ( ' MATCH (u:User {email:$email, confirmed: false}) '
		' OPTIONAL MATCH (u)-[:SUBMITTED*..3]->(n) '
		' DETACH DELETE u,n ' )
	partner_admin_users = ( 'MATCH (:User {username : $username}) '
		' -[:AFFILIATED {admin: true}]->(p:Partner)<-[a:AFFILIATED]-(u:User) ' 
		' RETURN {'
			' Username : u.username, '
			' Email : u.email, '
			' Name : u.name, '
			' Partner : p.name, '
			' PartnerFullName : p.fullname, '
			' Confirmed : a.confirmed '
			' } ' )
	global_admin_users = ( 'MATCH (u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN {'
			' Username : u.username, '
			' Email : u.email, '
			' Name : u.name, '
			' Partner : p.name, '
			' PartnerFullName : p.fullname, '
			' Confirmed : a.confirmed '
			' } ' )
	#these functions toggle the confirmed status so do both confirm/unconfirm operations
	partner_confirm_users = ( ' MATCH (user:User {username: $username}) '
		' -[:AFFILIATED {admin : true}]->(p:Partner) '
		' WHERE "partner_admin" in user.access'
		' MATCH (p)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $confirm_list as confirm '
		' WITH p,a,u '
		' WHERE p.name = confirm["partner"] '
		' AND u.username = confirm["username"]'
		' SET a.confirmed = NOT a.confirmed '
		' SET a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' RETURN u.name'
		)
	global_confirm_users = ( 
		' MATCH (p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $confirm_list as confirm '
		' WITH p,a,u '
		' WHERE p.name = confirm["partner"] '
		' AND u.username = confirm["username"]'
		' SET a.confirmed = NOT a.confirmed '
		' SET a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' RETURN u.name '
		)
	partner_admins = ( ' MATCH (u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN {'
			' Username : u.username, '
			' Email : u.email, '
			' Name : u.name, '
			' Partner : p.name, '
			' PartnerFullName : p.fullname, '
			' Confirmed : a.admin '
			' } ' )
	confirm_admins = ( ' MATCH (p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $admins as admin '
		' WITH p,a,u '
		' WHERE p.name = admin["partner"] '
		' AND u.username = admin["username"] '
		' SET a.admin = NOT a.admin '
		' RETURN u.name ' )
##LOCATION PROCEDURES
#country procedures
	country_find = ( 'MATCH (country:Country {name : $country}) '
		' RETURN country ' )
	country_add = ( 'MATCH (:User {username:$username}) '
			' -[:SUBMITTED]->(:Submissions) '
			' -[:SUBMITTED]->(:Locations) '
			' -[:SUBMITTED]->(c:Countries) '
		' MERGE (c)-[s:SUBMITTED]->(:Country {name :$country}) '
			' ON CREATE SET s.time = timestamp() ' )
#region procedures
	region_find = ('MATCH (:Country {name : $country}) '
		' <-[:IS_IN]-(region:Region { name:$region}) '
		' RETURN region ')
	region_add = ( 'MATCH (:User {username:$username}) '
			' -[:SUBMITTED]->(:Submissions) '
			' -[:SUBMITTED]->(:Locations) '
			' -[:SUBMITTED]->(r:Regions), ' 
		' (c:Country {name : $country}) '
		' MERGE (region:Region { name:$region})-[:IS_IN]->(c) '
		' MERGE (r)-[s:SUBMITTED]->(region) '
			' ON CREATE SET s.time = timestamp() ' )
	get_farms = ('MATCH (f:Farm) '
		' -[:IS_IN]->(:Region {name: $region}) '
		' -[:IS_IN]->(:Country {name: $country}) '
		' RETURN properties (f)')
	farm_find = ( ' MATCH (farm:Farm { name: $farm}) ' 
		' -[:IS_IN]->(:Region { name: $region }) '
		' -[:IS_IN]->(:Country { name: $country }) '
		' RETURN farm ' )
	farm_add = ( 'MATCH (:User {username:$username}) '
			' -[:SUBMITTED]->(:Submissions) '
			' -[:SUBMITTED]->(:Locations) '
			' -[:SUBMITTED]->(f:Farms), ' 
		' (r:Region {name : $region})-[:IS_IN]->(:Country {name : $country}) '
		' MERGE (farm:Farm { name:$farm})-[:IS_IN]->(r) '
		' MERGE (f)-[s:SUBMITTED]->(farm) '
			' ON CREATE SET s.time = timestamp() ' )
#plot procedures
	get_plots = ('MATCH (p:Plot) '
		' -[:IS_IN]->(:Farm {name: $farm}) '
		' -[:IS_IN]->(:Region {name: $region}) '
		' -[:IS_IN]->(:Country {name: $country}) '
		' RETURN properties (p)')
	plot_find = ( ' MATCH (plot:Plot { name: $plot}) '
			' -[:IS_IN]->(:Farm { name: $farm}) ' 
			' -[:IS_IN]->(:Region { name: $region }) '
			' -[:IS_IN]->(:Country { name: $country }) ' 
	 	' RETURN plot ')
#for autoincrement:
# https://stackoverflow.com/questions/32040409/reliable-autoincrementing-identifiers-for-all-nodes-relationships-in-neo4j
# for lock:
#this allows the increment counter (allowing for concurrent transactions to be serialised):
#http://neo4j.com/docs/stable/transactions-isolation.html
#https://stackoverflow.com/questions/35138645/how-to-perform-an-atomic-update-on-relationship-properties-with-py2neo
#https://stackoverflow.com/questions/31798311/write-lock-behavior-in-neo4j-cypher-over-transational-rest-ap
#This was tested by running many threads on the same operation (plot_add)
#without plot_id_lock (as a separate cypher query) it fails to maintain the count properly and clashes with the unique UID constraint
	plot_id_lock = (' MERGE (id:Counter {name:"Plots", uid: "Plots"}) '
		' ON CREATE SET id._LOCK_ = true, id.count=0 '
		' ON MATCH SET id._LOCK_ = true ')
	plot_add = ( 'MATCH (:User {username:$username}) '
			' -[:SUBMITTED]->(:Submissions) '
			' -[:SUBMITTED]->(:Locations) '
			' -[:SUBMITTED]->(p:Plots),'
		' (f:Farm { name: $farm}) ' 
			' -[:IS_IN]->(:Region { name: $region }) '
			' -[:IS_IN]->(:Country { name: $country }),  '
		' (id:Counter {uid:"Plots"}) '
		' SET id.count = id.count+1 '
		' MERGE (plot:Plot { name:$plot, uid:id.count}) '
			' -[:IS_IN]->(f)'
		' MERGE (p)-[s:SUBMITTED]->(plot) '
			' ON CREATE SET s.time = timestamp() '
		' MERGE (id)-[:COUNTED]->(plot) '
		' SET id._LOCK_ = false' )
##ITEM PROCEDURES
	#no longer need fill path as have unique plotID
	get_blocks = ('MATCH (b:Block) '
			' -[:IS_IN]->(:PlotBlocks) '
			' -[:IS_IN]->(:Plot {uid: toInteger($plotID)})'
		' RETURN properties (b)')
	block_find = ( 'MATCH (block:Block {name : $block}) '
		' -[:IS_IN]->(:PlotBlocks) '
		' -[:IS_IN]->(:Plot {uid : $plotID}) '
	 	' RETURN block' )
	block_id_lock = (' MATCH (p:Plot {uid:$plotID})'
		' MERGE (id:Counter {name:"Blocks", uid: ("plot_" + $plotID + "_blocks")}) '
				'-[:FOR]->(:PlotBlocks)-[:IS_IN]->(p) '
			' ON MATCH SET id._LOCK_ = true '
			' ON CREATE SET id._LOCK_ = true, id.count = 0 ')
	block_add = ('MATCH (:User {username:$username}) '
			' -[:SUBMITTED]->(:Submissions) '
			' -[:SUBMITTED]->(:Items) '
			' -[:SUBMITTED]->(b:Blocks), '
		' (id:Counter {uid: ("plot_" + $plotID + "_blocks")}) '
			' -[:FOR]->(pb:PlotBlocks) '
		' SET id.count = id.count+1 '
		' MERGE (block:Block {name: $block, '
					' uid:($plotID + "_B" + id.count), '
					' id:id.count}) '
				' -[:IS_IN]->(pb)'
		' MERGE (b)-[s:SUBMITTED]->(block) '
			' ON CREATE SET s.time = timestamp () '
		' SET id._LOCK_ = false')
	get_blocks_csv = ( ' MATCH (b:Block) '
			' -[:IS_IN]->(:PlotBlocks) '
			' -[:IS_IN]->(p:Plot {uid : $plotID}) '
			' -[:IS_IN]->(f:Farm) '
			' -[:IS_IN]->(r:Region) '
			' -[:IS_IN]->(c:Country) '
		' RETURN {UID : b.uid, '
			' PlotID : p.uid, '
			' BlockID : b.id, '
			' Block : b.name, '
			' Plot : p.name, '
			' Farm : f.name, '
			' Region : r.name, '
			' Country : c.name }'
		' ORDER BY b.id' )
#tree procedures
	tree_id_lock = (' MATCH (p:Plot {uid: $plotID})'
		' MERGE (id:Counter {name : "Trees", uid: ("plot_" + $plotID + "_trees")}) '
				' -[:FOR]->(:PlotTrees)-[:IS_IN]->(p) '
			' ON CREATE SET id._LOCK_ = true, id.count = 0 '
			' ON MATCH SET id._LOCK_ = true ')
	trees_add = ( 'MATCH (:User {username:$username}) '
				' -[:SUBMITTED]->(:Submissions) '
				' -[:SUBMITTED]->(:Items) '
				' -[:SUBMITTED]->(ut:Trees), '
			' (pt:PlotTrees)-[:IS_IN]->(p:Plot {uid: $plotID}) '
		#create per user per plot trees node
		' MERGE (ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		' WITH p, pt, upt'
		' MATCH (id:Counter {uid: ("plot_" + $plotID + "_trees")}) '
			' -[:FOR]->(pt) '
			' -[:IS_IN]->(p) '
			' -[:IS_IN]->(f:Farm) '
			' -[:IS_IN]->(r:Region) '
			' -[:IS_IN]->(c:Country) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter ' 
		' SET id.count=id.count+1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		' MERGE (t:Tree {uid:(toString(p.uid) + "_T" + toString(id.count)), '
					' id:id.count}) '
				' -[:IS_IN]->(pt) '
		' MERGE (upt)-[s2:SUBMITTED]->(t) '
			' ON CREATE SET s2.time = timestamp() '
		' SET id._LOCK_ = false '
		' RETURN {UID:t.uid, '
			' PlotID:p.uid, '
			' TreeID:t.id, '
			' Plot:p.name, '
			' Farm:f.name, '
			' Region:r.name, '
			' Country:c.name} '
		' ORDER BY t.id ' )
	#no optional parameters in Neo4j so creating an almost duplicate query where block is given
	block_trees_add = ( 'MATCH (:User {username:$username}) '
				' -[:SUBMITTED]->(:Submissions) '
				' -[:SUBMITTED]->(:Items) '
				' -[:SUBMITTED]->(ut:Trees), '
			' (pt:PlotTrees)-[:IS_IN]->(p:Plot {uid: $plotID}) '
		#create per user per plot trees node
		' MERGE (ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		' WITH p, pt, upt'
		' MATCH (id:Counter {uid: ("plot_" + $plotID + "_trees")}) '
				' -[:FOR]->(pt) '
				' -[:IS_IN]->(p) '
				' -[:IS_IN]->(f:Farm) '
				' -[:IS_IN]->(r:Region) '
				' -[:IS_IN]->(c:Country), '
			' (b:Block {uid : $blockUID})'
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter ' 
		' SET id.count=id.count+1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		' MERGE (t:Tree {uid:(toString(p.uid) + "_T" + toString(id.count)), '
					' id:id.count}) '
				' -[:IS_IN]->(pt) '
		' MERGE (upt)-[s2:SUBMITTED]->(t) '
			' ON CREATE SET s2.time = timestamp() '
		' MERGE (bt:BlockTrees)-[:IS_IN]->(b)'
		' MERGE (t)-[s3:IS_IN]-(bt)'
			' ON CREATE SET s3.time = timestamp() '
		' SET id._LOCK_ = false '
		' RETURN {UID:t.uid, '
			' PlotID:p.uid, '
			' TreeID:t.id, '
			' Block:b.name, '
			' Plot:p.name, '
			' Farm:f.name, '
			' Region:r.name, '
			' Country:c.name} '
		' ORDER BY t.id')
	trees_get = ( 'MATCH (tree:Tree) '
			' -[:IS_IN]->(pt:PlotTrees) '
			' -[:IS_IN]->(plot:Plot {uid : $plotID}) '
			' -[:IS_IN]->(farm:Farm) '
			' -[:IS_IN]->(region:Region) '
			' -[:IS_IN]->(country:Country) '
		#filter by range of tree ID's
		' WHERE tree.id >= $start '
		' AND tree.id <= $end '
		#find block if registered
		' OPTIONAL MATCH (tree) '
			' -[:IS_IN]->(:BlockTrees)-[:IS_IN]->(block:Block)'
		#find custom tree name if registered
		' OPTIONAL MATCH (tree)'
			' <-[:FROM_TREE]-(ttt:TreeTreeTrait)'
			' -[:DATA_FOR]->(:PlotTreeTrait) '
			' -[:FOR_TRAIT]->(:TreeTrait {name:"name"}) '
		' OPTIONAL MATCH (ttt) '
			' <-[:DATA_FOR]-(d:Data) '
		' RETURN { UID : tree.uid, '
			' PlotID : p.uid, '
			' TreeID : t.id, '
			' TreeName : d.value, '
			' Block : b.name, '
			' Plot : p.name, '
			' Farm : f.name, '
			' Region : r.name, '
			' Country : c.name } '
		' ORDER BY t.id ' )
#sample procedures
	#these are unique in allowing users to submit other than locations/items/data
	#not sure if good idea, check with Benoit if can get list of tissues and storage procedures instead
	#also if keeping this way good idea to create as a separate container section (not within items, maybe methods or similar?)
	tissue_add = (' MATCH (:User {username:$username})-[:SUBMITTED]->(:Submissions) '
			' -[:SUBMITTED]->(:Items)-[:SUBMITTED]->(sa:Samples) '
		' MERGE (sa)-[s:SUBMITTED]->(:Tissue {name: $tissue}) '
			' ON CREATE SET s.time = timestamp() ' )
	storage_add = ('MATCH (user:User {username:$username})-[:SUBMITTED]->(:Submissions)  '
			' -[:SUBMITTED]->(:Items)-[:SUBMITTED]->(sa:Samples) '
		' MERGE (sa)-[s:SUBMITTED]->(:Storage {name :$storage}) '
			' ON CREATE SET s.time = timestamp() ')
	#regular stuff
	sample_id_lock = ( ' MATCH  (p:Plot {uid: $plotID}) '
		' MERGE (id:Counter {name : "Samples", '
				' uid: ("plot_" + $plotID + "_samples") '
				' }) '
			' -[:FOR]->(:PlotSamples) '
			' -[:FROM_PLOT]->(p) '
		' ON CREATE SET id._LOCK_ = true, id.count = 0 '
		' ON MATCH SET id._LOCK_ = true ' )
	samples_add = (' MATCH '
			' (t:Tree) '
				' -[:IS_IN]->(:PlotTrees) '
				' -[:IS_IN]->(:Plot {uid: $plotID}), '
			' (tissue:Tissue {name:$tissue}), '
			' (storage:Storage {name:$storage}), '
			' (:User {username:$username}) '
				' -[:SUBMITTED]->(:Submissions) '
				' -[:SUBMITTED]->(:Items) '
				' -[:SUBMITTED]->(samples:Samples), '
			' (id:Counter {uid: ("plot_" + $plotID + "_samples")}) '
				' -[:FOR]->(ps:PlotSamples) '
				' -[:FROM_PLOT]->(p:Plot {uid: $plotID}) '
				' -[:IS_IN]->(f:Farm) '
				' -[:IS_IN]->(r:Region) '
				' -[:IS_IN]->(c:Country) '
		# with the selected trees to be sampled
		' WITH t, tissue, storage, samples, id, ps, p, f, r, c '
		' ORDER BY t.id '
		' WHERE t.id >= $start '
		' AND t.id <= $end '
		#get tree name
		' OPTIONAL MATCH (t)'
			' <-[:FROM_TREE]-(treename:TreeTreeTrait)'
			' -[:DATA_FOR]->(:PlotTreeTrait) '
			' -[:FOR_TRAIT]->(:TreeTrait {name:"name"}) '
		' OPTIONAL MATCH (treename) '
			' <-[:DATA_FOR]-(d:Data) '
		# get block name
		' OPTIONAL MATCH (t) '
			' -[:IS_IN]->(:BlockTrees) '
			' -[:IS_IN]->(b:Block) '
		#with replicates
		' UNWIND range(1, $replicates) as replicates '
		#incrementing with a plot level counter
		' SET id.count = id.count + 1 '
		#Create samples
		' CREATE (s:Sample { '
				' uid: (p.uid + "_S" + id.count), '
				' id:id.count, '
				' date:$date, '
				' time:$time, '
				' replicates: $replicates '
				'}) '
		#Create a per Tissue per Storage container node
		' MERGE (tissue)<-[:OF_TISSUE]-(TiSt:TissueStorage)-[:STORED_IN]->(storage) '
		#and split this off per PlotSamples
		' MERGE (TiSt)<-[:COLLECTED_AS]-(pts:PlotTissueStorage)-[:FROM_PLOT]->(ps) '
		#Create a TreeSamples node per tree
		' MERGE (t)<-[:FROM_TREE]-(ts:TreeSamples) '
		#Link the sample to its TreeSamples and PlotTissueSamples containers
		' MERGE (s)-[:FROM_TREE]->(ts) '
		' MERGE (s)-[:FROM_PLOT]->(pts) '
		#track user submissions through successive UserPlotSamples then UserTreeSamples container nodes
		' MERGE (samples)-[:SUBMITTED]->(ups:UserPlotSamples)-[:CONTRIBUTED]->(ps) '
		' MERGE (ups)-[:SUBMITTED]->(uts:UserTreeSamples)-[:CONTRIBUTED]->(ts) '
		' MERGE (uts)-[s1:SUBMITTED]->(s) '
			' ON CREATE SET s1.time = timestamp() '
		' SET id._LOCK_ = false '
		#return for csv
		' RETURN { '
			' UID : s.uid, '
			' PlotID : p.uid, '
			' TreeID : t.id, '
			' TreeName : d.value, '
			' SampleID : s.id, '
			' Date : s.date, '
			' Tissue : tissue.name, '
			' Storage : storage.name, '
			' Block : b.name, '
			' Plot : p.name, '
			' Farm : f.name, '
			' Region : r.name, '
			' Country : c.name '
		' } '
		' ORDER BY s.id '
		)
	upload_FB_sample = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the samples, trees, plots and traits assessed
		' MATCH (sample:Sample {uid:csvLine.UID}) '
					' -[:FROM_TREE]->(:TreeSamples) '
					' -[:FROM_TREE]->(tree:Tree) '
					' -[:IS_IN]->(:PlotTrees) '
					' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}), '
				' (trait:SampleTrait {name:csvLine.trait}), '
			# get the user submission tracking nodes
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(submissions:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(fb:FieldBook) '
		# Create /Plot/SampleTrait (per plot per trait) container node
		' MERGE (plot)<-[:FROM_PLOT]-(pst:PlotSampleTrait)-[:FOR_TRAIT]->(trait) '
		# Then  /Tree/SampleTrait container node
		' MERGE (tree)<-[:FROM_TREE]-(tst:TreeSampleTrait)-[:DATA_FOR]->(pst)'
		# And finally /Sample/SampleTrait container node
		' MERGE (sample)<-[:FROM_SAMPLE]-(sst:SampleSampleTrait)-[:DATA_FOR]->(tst)'
		# Merge the data point linking to Sample/SampleTrait node
		' MERGE (d:Data { '
					' sample : csvLine.UID, '
					' trait : csvLine.trait, '
					' value : csvLine.value, '
					' timeFB : csvLine.timestamp, '
					#the below converts the time to epoch (ms) - same as neo4j timestamp() to allow simple math on date/time
					' time : apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz"), '
					' person : csvLine.person, '
					' location : csvLine.location }) '
				' -[:DATA_FOR]->(sst) '
			#storing whether found or not for user feedback
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
		#track user submissions through /User/Plot/SampleTrait container
		' MERGE (fb)-[:SUBMITTED]->(upst:UserPlotSampleTrait)-[:CONTRIBUTED]->(pst) '
		' MERGE (upst)-[s1:SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '
		#And give the user feedback on their submission success
		' RETURN d.found ' )
	upload_FB_tree = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the trees, plots and traits assessed
		' MATCH (tree:Tree {uid:csvLine.UID}) '
				' -[:IS_IN]-(:PlotTrees) '
				' -[:IS_IN]->(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}),'
			' (trait:TreeTrait {name:csvLine.trait}), '
			# get the user submission tracking nodes
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(submissions:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(fb:FieldBook), '
			#and the block submission node in case block names are part of the TreeTrait data (this is a special case to handle flexible blocks)
			' (submissions)-[:SUBMITTED]->(:Items) '
				' -[:SUBMITTED]->(blocks:Blocks) '
		# Create per plot per TreeTrait node
		' MERGE (plot)<-[:FROM_PLOT]-(ptt:PlotTreeTrait)-[:FOR_TRAIT]->(trait) '
		# Also per Tree per Plot/TreeTrait node
		' MERGE (tree)<-[:FROM_TREE]-(ttt:TreeTreeTrait)-[:DATA_FOR]->(ptt) '
		# Merge the data point linking to Tree/TreeTrait node
		' MERGE (d:Data { '
					' tree : csvLine.UID, '
					' value : csvLine.value, '
					' timeFB : csvLine.timestamp, '
					#the below converts the time to epoch (ms) - same as neo4j timestamp() to allow simple math on date/time
					' time : apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz"), '
					' person : csvLine.person, '
					' location : csvLine.location}) '
				' -[:DATA_FOR]->(ttt) '
			#storing whether found or not for user feedback
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
		#track user submissions through User/Plot/TreeTrait container
		' MERGE (fb)-[:SUBMITTED]->(uptt:UserPlotTreeTrait)-[:CONTRIBUTED]->(ptt) '
		' MERGE (uptt)-[s1:SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '
		# if block data create link tree to block
		' FOREACH (n IN CASE WHEN csvLine.trait = "block" THEN [1] ELSE [] END | '
				#first ensure we have the PlotBlocks container and lock the counter
				' MERGE (id:Counter {name:"Blocks", uid: ("plot_" + plot.uid + "_blocks")}) '
						'-[:FOR]->(pb:PlotBlocks)-[:IS_IN]->(plot) '
					' ON MATCH SET id._LOCK_ = true '
					' ON CREATE SET id._LOCK_ = true, id.count = 0 '
				#then increment the counter and add our block
				' SET id.count = id.count + 1 '
				' MERGE (block:Block {name:csvLine.value})-[:IS_IN]->(pb) '
					' ON CREATE SET block.uid = (plot.uid + "_B" + id.count), block.id = id.count '
				#then ensure we have the BlockTrees container
				' MERGE (bt:BlockTrees)-[:IS_IN]->(block) '
				#then link the tree to this
				' MERGE (tree)-[s2:IS_IN]->(bt) '
					' ON CREATE SET s2.time = timestamp()'
				# and track the user submission in this part of the graph too, to be consistent with other block submissions
				# also add from_fb tag to allow more easy identification of these special cases (they may need scrutiny for typos/redundancy)
				' MERGE (blocks)-[s3:SUBMITTED]->(block) '
					' ON CREATE SET s3.time = timestamp(), s3.from_fb = true '
				#and "unlock"
				' SET id._LOCK_ = false'
			' ) '
		#And give the user feedback on their submission success
		' RETURN d.found ' )
	upload_FB_block = ( 
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the plots and traits assessed
		' MATCH (block:Block {uid:csvLine.UID}) '
			' -[:IS_IN]-(:PlotBlocks) '
			' -[:IS_IN]-(plot:Plot {uid:toInteger(head(split(csvLine.UID, "_")))}), '
			' (trait:BlockTrait {name:csvLine.trait}), '
			# get the user submission tracking nodes
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(fb:FieldBook) '
		# Crete per plot per trait node
		' MERGE (plot)<-[:FROM_PLOT]-(pbt:PlotBlockTrait)-[:FOR_TRAIT]->(trait) '
		# Also per block per PlotBlockTrait node
		' MERGE (block)<-[:FROM_BLOCK]-(bbt:BlockBlockTrait)-[:DATA_FOR]->(pbt) '
		# Merge the data point linking to the Block/BlockTrait node
		' MERGE (d:Data {block : csvLine.UID, '
					' trait : csvLine.trait, '
					' value : csvLine.value, '
					' timeFB : csvLine.timestamp, '
					' time : apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz"), '
					' person : csvLine.person, '
					' location : csvLine.location}) '
				' -[:DATA_FOR]->(bbt)'
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
		# track user submissions through User/Plot/BlockTrait container
		' MERGE (fb)-[:SUBMITTED]->(upbt:UserPlotBlockTrait)-[:CONTRIBUTED]->(pbt) '
		' MERGE (upbt)-[s1:SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '
		#And give the user feedback on their submission success
		' RETURN d.found' 
		)
	upload_FB_plot = ( 
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		# And identify the plots and traits assessed
		' MATCH (plot:Plot {uid:toInteger(csvLine.UID)}),'
			' (trait:PlotTrait {name:csvLine.trait}), '
			# get the user submission tracking nodes
			' (:User {username : $username}) '
				' -[:SUBMITTED]->(:Submissions) '
				' -[:SUBMITTED]->(:DataSub) '
				' -[:SUBMITTED]->(fb:FieldBook)'
		# Create per plot per trait container node
		' MERGE (plot)<-[:FROM_PLOT]-(ppt:PlotPlotTrait)-[:FOR_TRAIT]->(trait) '
		# Merge the data point linking to the Plot/PlotTrait node
		' MERGE (d:Data {plot : csvLine.UID, '
					' trait : csvLine.trait, '
					' value : csvLine.value, '
					' timeFB : csvLine.timestamp, '
					' time : apoc.date.parse(csvLine.timestamp,"ms","yyyy-MM-dd HH:mm:sszzz"), '
					' person : csvLine.person, '
					' location : csvLine.location}) '
				' -[:DATA_FOR]->(ppt)'
			' ON CREATE SET d.found = false '
			' ON MATCH SET d.found = true '
		# track user submissions through User/Plot/PlotTrait container
		' MERGE (fb)-[:SUBMITTED]->(uppt:UserPlotPlotTrait)-[:CONTRIBUTED]->(ppt) '
		' MERGE (uppt)-[s1:SUBMITTED]->(d) '
			' ON CREATE SET s1.time = timestamp() '
		#And give the user feedback on their submission success
		' RETURN d.found' 
		)
	get_plots_treecount = (
		' MATCH (C:Country) '
		' OPTIONAL MATCH (C) <-[:IS_IN]-(R:Region) '
		' OPTIONAL MATCH (R) <-[:IS_IN]-(F:Farm) '
		' OPTIONAL MATCH (F) <-[:IS_IN]-(P:Plot) '
		' OPTIONAL MATCH (P) <-[:IS_IN]-(pt:PlotTrees) '
		' OPTIONAL MATCH (pt) <-[:FOR]-(T:Counter {name:"Trees"}) '
		' RETURN '
			' labels(C)[0] as C_label, '
			' labels(R)[0] as R_label, '
			' labels(F)[0] as F_label, '
			' labels(P)[0] as P_label, '
			' C.name, R.name, F.name, P.name, P.uid, T.count ' )
	get_submissions_range = ( 
		# gets arguments to filter by time from last SUBMITTED relationship
		# currently not using these though
		# >=$starttime  <= $endtime
		#regions
		#sample data (in plot but not block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(sst:SampleSampleTrait) '
					' -[:DATA_FOR*2]->(:PlotSampleTrait) '
					' -[:FOR_TRAIT]->(sampletrait:SampleTrait), '
				' (sst)'
					' -[:FROM_SAMPLE]->(sample:Sample) '
					' -[:FROM_TREE*2]->(tree:Tree) '
					' -[:IS_IN*2]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT '
					' (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (sampletrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(sampletrait)) as d_id, '
			' "Samples" as n_label, '
			' count(DISTINCT sample) as n_name, '
			' (id(plot) + "_" + id(sampletrait) + "_sample_count_node") as n_id,'
			' "FROM_PLOT_SAMPLES" as r_type,  '
			' (id(plot) + "_" + id(sampletrait) + "_data_count_node") as r_id, '
			' (id(plot) + "_" + id(sampletrait)) as r_start, '
			' (id(plot) + "_" + id(sampletrait) + "_sample_count_node") as r_end '
			' '
		' UNION '
		#sample data (in block)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(sst:SampleSampleTrait) '
					' -[:DATA_FOR*2]->(:PlotSampleTrait) '
					' -[:FOR_TRAIT]->(sampletrait:SampleTrait), '
				' (sst) '
					' -[:FROM_SAMPLE]->(sample:Sample)'
					' -[:FROM_TREE*2]->(:Tree) '
					' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (sampletrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(sampletrait)) as d_id, ' #need unique id while both with and without block come from same pst node)
			' "Samples" as n_label, '
			' count(DISTINCT sample) as n_name, '
			' (id(block) + "_" + id(sampletrait) + "_sample_count_node") as n_id,'
			' "FROM_BLOCK_SAMPLES" as r_type,  '
			' (id(block) + "_" + id(sampletrait) + "_data_count_node") as r_id, '
			' (id(block) + "_" + id(sampletrait)) as r_start, '
			' (id(block) + "_" + id(sampletrait) + "_sample_count_node") as r_end '
		' UNION '
		#tree data (from plot but not block, connect to tree counter)
		' MATCH '
			'(:User {username:$username}) '
					' -[:SUBMITTED*4]->() '
					' -[s:SUBMITTED]->(data:Data) '
					' -[:DATA_FOR]->(ttt:TreeTreeTrait) '
					' -[:DATA_FOR]->(:PlotTreeTrait) '
					' -[:FOR_TRAIT]->(treetrait:TreeTrait), '
				' (ttt)-[:FROM_TREE]->(tree:Tree), '
				' (ptt)-[:FROM_PLOT]->(plot:Plot) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
				' AND NOT (tree)-[:IS_IN]->(:BlockTrees) '
		' RETURN '
			' "Trait" as d_label, '
			' (treetrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(treetrait)) as d_id, '
			' "Trees" as n_label, '
			' count(DISTINCT tree) as n_name, '
			' (id(plot) + "_" + id(treetrait) + "_tree_count_node") as n_id,'
			' "FROM_PLOT_TREES" as r_type,  '
			' (id(plot) + "_" + id(treetrait) + "_rel") as r_id, '
			' (id(plot) + "_" + id(treetrait)) as r_start, '
			' (id(plot) + "_" + id(treetrait) + "_tree_count_node") as r_end ' 
		' UNION '
		#tree data (from block)
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(ttt:TreeTreeTrait) '
				' -[:DATA_FOR]->(:PlotTreeTrait) '
				' -[:FOR_TRAIT]->(treetrait:TreeTrait), '
			' (ttt)-[:FROM_TREE]->(tree:Tree) '
				' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (treetrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(treetrait)) as d_id, '
			' "Trees" as n_label, '
			' count(DISTINCT tree) as n_name, '
			' (id(block) + "_" + id(treetrait) + "_tree_count_node") as n_id,'
			' "FROM_BLOCK_TREES" as r_type,  '
			' (id(block) + "_" + id(treetrait) + "_rel") as r_id, '
			' (id(block) + "_" + id(treetrait)) as r_start, '
			' (id(block) + "_" + id(treetrait) + "_tree_count_node") as r_end '
		' UNION '
		#block data
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(bbt:BlockBlockTrait) '
				' -[:DATA_FOR]->(:PlotBlockTrait) '
				' -[:FOR_TRAIT]->(blocktrait:BlockTrait), '
			' (bbt)-[:FROM_BLOCK]-(block:Block) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (blocktrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(block) + "_" + id(blocktrait)) as d_id, '
			' "Block" as n_label, '
			' block.name as n_name, '
			' id(block) as n_id,'
			' "FROM_BLOCK" as r_type,  '
			' (id(block) + "_" + id(blocktrait) + "_rel") as r_id, '
			' (id(block) + "_" + id(blocktrait)) as r_start, '
			' id(block) as r_end '
		'UNION'
		#plot data
		' MATCH (:User {username:$username}) '
				' -[:SUBMITTED*4]->() '
				' -[s:SUBMITTED]->(data:Data) '
				' -[:DATA_FOR]->(ppt:PlotPlotTrait) '
				' -[:FOR_TRAIT]->(plottrait:PlotTrait), '
		' 	(ppt)-[:FROM_PLOT]-(plot:Plot) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' RETURN '
			' "Trait" as d_label, '
			' (plottrait.name + " (" + count(DISTINCT data) +")") as d_name, '
			' (id(plot) + "_" + id(plottrait)) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id,'
			' "FROM_PLOT" as r_type,  '
			' (id(plot) + "_" + id(plottrait) + "_rel") as r_id, '
			' (id(plot) + "_" + id(plottrait)) as r_start, '
			' id(plot) as r_end '
		' UNION '
		#link blocks into plots
		' MATCH (:User {username:$username}) '
			' -[:SUBMITTED*4]->() '
			' -[s:SUBMITTED]->(data:Data) '
			' -[:DATA_FOR*..2]->() '
			' -[:FROM_TREE]->() '
			' -[:IS_IN*2]->(block:Block) '
			' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH DISTINCT block '
		' MATCH (block)-[:IS_IN*2]->(plot:Plot) '
		' RETURN '
			' "Block" as d_label, '
			' block.name as d_name, '
			' id(block) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(block) + "_" + id(plot)) as r_id, '
			' id(block) as r_start, '
			' id(plot) as r_end')
