class Cypher:
	def __init__(self):
		pass
	# user procedures
	allowed_emails = (
		' MATCH '
		'	(e: Emails) '
		' RETURN '
		'	e.allowed '
	)
	user_allowed_emails = (
		' MATCH '
		'	(u:User) '
		' WITH '
		'	COLLECT (DISTINCT u.email) as registered_emails '
		' MATCH '
		'	(user:User {'
		'		username_lower : toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(e: Emails) '
		' RETURN '
		'	FILTER (n in e.allowed WHERE NOT n in registered_emails) as user_allowed '
	)
	email_find = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' RETURN '
		'	user '
	)
	confirm_email = (
		' MATCH '
		'	(user: User { '
		'		email: toLower(trim($email)) '
		'	}) '
		' SET '
		'	user.confirmed = true '
	)
	user_find = (
		' MATCH '
		'	(user: User) '
		'		WHERE '
		'			user.username_lower = toLower($username) '
		'		OR '
		'			user.email = toLower(trim($email)) '
		' RETURN '
		'	user '
	)
	username_find = (
		' MATCH '
		'	(user: User { '
		'		username_lower: toLower($username)'
		'	}) '
		' RETURN '
		'	user '
	)
	user_affiliations = (
		' MATCH '
		'	(u: User { '
		'		username_lower: toLower($username) '
		'	}) '
		'	-[a: AFFILIATED]->(p: Partner) '
		' OPTIONAL MATCH '
		'	(p)<-[: AFFILIATED {admin: true}]-(admin: User) '
		' RETURN '
		'	p.name , '
		'	p.fullname , '
		'	a.confirmed as confirmed, '
		'	a.data_shared as data_shared , '
		'	admin.email as admin_email'
	)
	add_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		}), '
		'		(p:Partner { '
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	MERGE '
		'		(u)-[a: AFFILIATED { '
		'			data_shared: false, '
		'			admin: false, '
		'			confirm_timestamp: [], '
		'			confirmed: false '
		' 		}]->(p) '
		' 	ON CREATE SET '
		'		a.add_timestamp = timestamp() '
		' 	RETURN '
		'		p.name '
	)
	remove_affiliations = (
		' UNWIND '
		'	$partners as partner '
		' 	MATCH '
		'		(u:User { '
		'			username_lower: toLower(trim($username)) '
		'		 }) '
		'		-[a:AFFILIATED { '
		'			data_shared: false '
		'		}]->(p: Partner {'
		'			name_lower: toLower(trim(partner)) '
		'		}) '
		' 	WHERE '
		'		size(a.confirm_timestamp) = 0 '
		' 	DELETE '
		'		a '
		' 	RETURN p.name '
	)
	password_reset = (
		' MATCH '
		'	(user: User { '
		'		email : toLower(trim($email)) '
		' 	}) '
		' SET user.password = $password '
	)
	user_register = (
		# This is a little cautious using merge to prevent overwriting a user profile if it is called in error
		' MATCH '
		'	(partner:Partner {'
		'		name_lower: toLower(trim($partner)) '
		'	}) '
		' MERGE '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	ON CREATE SET '
		'		user.username = trim($username), '
		'		user.password = $password, ' 
		'		user.email = toLower(trim($email)), '
		'		user.name = $name, '
		'		user.time = timestamp(), '
		'		user.access = ["user"], '
		'		user.confirmed = false, '
		'		user.found = false '
		'	ON MATCH SET '
		'		user.found = TRUE '
		' WITH '
		'	user, partner '	
		' WHERE '
		'	user.found = false '
		' CREATE '
		'	(user)-[r: AFFILIATED { '
		'		data_shared: true, '
		'		confirmed: false, '
		'		confirm_timestamp: [], '
		'		admin: false '				
		'	}]->(partner), '
		'	(user)-[: SUBMITTED]->(sub: Submissions), '
		'		(sub)-[: SUBMITTED]->(: Emails {allowed :[]}),'
		'		(sub)-[: SUBMITTED]->(: Partners), '
		'		(sub)-[: SUBMITTED]->(: Traits), '
		'		(sub)-[: SUBMITTED]->(: Trials), '
		'		(sub)-[: SUBMITTED]->(locations: Locations), '
		'			(locations)-[: SUBMITTED]->(: Countries), '
		'			(locations)-[: SUBMITTED]->(: Regions), '
		'			(locations)-[: SUBMITTED]->(: Farms), '
		'			(locations)-[: SUBMITTED]->(: Plots), '
		'		(sub)-[:SUBMITTED]->(traits:Traits), '
		'			(traits)-[: SUBMITTED]->(: FarmTraits), '
		'			(traits)-[: SUBMITTED]->(: PlotTraits), '
		'			(traits)-[: SUBMITTED]->(: BlockTraits), '
		'			(traits)-[: SUBMITTED]->(: TreeTraits), '
		'			(traits)-[: SUBMITTED]->(: BranchTraits), '
		'			(traits)-[: SUBMITTED]->(: LeafTraits), '
		'			(traits)-[: SUBMITTED]->(: SampleTraits), '
		'		(sub)-[:SUBMITTED]->(varieties:Varieties), '
		'			(varieties)-[: SUBMITTED]->(: Hybrids), '
		'			(varieties)-[: SUBMITTED]->(: Inbreds), '
		'			(varieties)-[: SUBMITTED]->(: Grafts), '
		'		(sub)-[:SUBMITTED]->(descriptors: SampleDescriptors), '
		'			(descriptors)-[: SUBMITTED]->(: Tissues), '
		'			(descriptors)-[: SUBMITTED]->(: StorageMethods), '
		'		(sub)-[:SUBMITTED]->(items: Items), '
		'			(items)-[: SUBMITTED]->(: Blocks), '
		'			(items)-[: SUBMITTED]->(: Trees), '
		'			(items)-[: SUBMITTED]->(: Branches), '
		'			(items)-[: SUBMITTED]->(: Leaves), '
		'			(items)-[: SUBMITTED]->(: Samples), '
		'		(sub)-[:SUBMITTED]->(data: DataSubmissions) '
	)
	add_allowed_email = (
		' MATCH '
		'	(all: Emails) '
		' WITH '
		'	all.allowed as allowed_emails '
		' UNWIND '
		'	allowed_emails as email '
		' WITH '
		'	COLLECT(DISTINCT email) as set '
		' WHERE '
		'	NOT toLower(trim($email)) IN set '
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' SET e.allowed = e.allowed + [toLower(trim($email))] '
		' RETURN toLower(trim($email)) '
	)
	remove_allowed_email = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(e: Emails) '
		' WITH e, extract(x in $email | toLower(trim(x))) as emails'
		' SET e.allowed = FILTER (n in e.allowed WHERE NOT n IN emails) '
		' RETURN emails '
	)
	user_del = (
		' MATCH '
		'	(u:User { '
		'		email: toLower(trim($email)), '
		'		confirmed: false '
		'	}) '
		' OPTIONAL MATCH '
		'	(u)-[:SUBMITTED*..3]->(n) '
		' DETACH DELETE '
		' u,n '
	)
	partner_admin_users = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: AFFILIATED { '
		'		admin: true '
		'	}]->(p:Partner) '
		' WITH p '
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) ' 
		' RETURN { '
		'	Username: u.username, '
		'	Email: u.email, '
		'	Name: u.name, '
		'	Partner: p.name, '
		'	PartnerFullName: p.fullname, '
		'	Confirmed: a.confirmed '
		' } '
	)
	global_admin_users = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.confirmed '
		' } '
	)
	# these functions toggle the confirmed status so do both confirm/un-confirm operations
	partner_confirm_users = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:AFFILIATED {admin : true}]->(p:Partner) '
		' WHERE '
		'	"partner_admin" in user.access'
		' MATCH '
		'	(p)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(confirm["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(confirm["username"])) '
		' 	SET '
		'		a.confirmed = NOT a.confirmed, '
		'		a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' 	RETURN u.name '
	)
	global_confirm_users = ( 
		' MATCH '
		'	(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND '
		'	$confirm_list as confirm '
		' WITH '
		'	p,a,u '
		' WHERE '
		'	p.name_lower = toLower(trim(confirm["partner"])) '
		' AND '
		'	u.username_lower = toLower(trim(confirm["username"])) '
		' SET '
		'	a.confirmed = NOT a.confirmed, '
		'	a.confirm_timestamp = a.confirm_timestamp + timestamp() '
		' RETURN u.name '
	)
	partner_admins = (
		' MATCH '
		'	(u:User)-[a:AFFILIATED]->(p:Partner) '
		' RETURN { '
		'	Username : u.username, '
		'	Email : u.email, '
		'	Name : u.name, '
		'	Partner : p.name, '
		'	PartnerFullName : p.fullname, '
		'	Confirmed : a.admin '
		' } '
	)
	confirm_admins = (
		' MATCH '
		'		(p:Partner)<-[a:AFFILIATED]-(u:User) '
		' UNWIND $admins as admin '
		' 	WITH '
		'		p,a,u '
		' 	WHERE '
		'		p.name_lower = toLower(trim(admin["partner"])) '
		' 	AND '
		'		u.username_lower = toLower(trim(admin["username"])) '
		' 	SET '
		'		a.admin = NOT a.admin '
		'	WITH u '
		'		MATCH (u)-[a:AFFILIATED]->(:Partner) '
		'		WITH u, collect(a.admin) as admin_rights '
		'		set u.access = CASE '
		'			WHEN true IN admin_rights '
		'			THEN ["user","partner_admin"] '
		'			ELSE ["user"] '
		'			END '
		' 	RETURN '
		'		u.name '
	)
	# LOCATION PROCEDURES
	# country procedures
	country_find = (
		' MATCH '
		'	(country:Country { '
		'		name_lower : toLower(trim($country))'
		' 	}) '
		' RETURN '
		'	country '
	)
	country_add = (
		' MATCH \n'
		'	(: User  {\n'
		'		username_lower: toLower(trim($username)) \n'
		' 	}) \n'
		'	-[: SUBMITTED]->(: Submissions) \n'
		'	-[: SUBMITTED]->(: Locations) \n'
		'	-[: SUBMITTED]->(c: Countries) \n'
		' MERGE \n'
		'	(c)-[s: SUBMITTED]->(country: Country { \n'
		'		name_lower: toLower(trim($country)) \n'
		' 	}) \n'
		'	ON CREATE SET \n'
		'		country.name = trim($country), \n'
		'	 	s.time = timestamp() \n'
		' RETURN country.name \n'
	)
	# region procedures
	region_find = (
		' MATCH '
		'	(:Country { '
		'		name_lower : toLower(trim($country)) '
		' 	}) '
		'	<-[:IS_IN]-(region:Region { '
		'		name_lower: toLower(trim($region)) '
		' 	}) '
		' RETURN region '
	)
	region_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Locations) '
		'	-[:SUBMITTED]->(r: Regions), ' 
		'	(c:Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' MERGE '
		'	(region:Region { '
		'		name_lower: toLower(trim($region)) '
		' 	}) '
		'	-[:IS_IN]->(c) '
		'	ON CREATE SET '
		'		region.name = trim($region) '
		' MERGE '
		'	(r)-[s: SUBMITTED]->(region) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN '
		'	region.name '
	)
	get_farms = (
		' MATCH '
		'	(f: Farm) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' RETURN properties (f) '
	)
	farm_find = (
		' MATCH '
		'	(farm: Farm { '
		'		name_lower: toLower(trim($farm)) '
		' 	}) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower(trim($country)) '
		'	}) '
		' RETURN farm '
	)
	farm_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		' 	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(f: Farms), ' 
		'	(r: Region { '
		'		name_lower: toLower(trim($region)) '
		'	}) '
		'	-[:IS_IN]->(: Country {name_lower: toLower(trim($country))}) '
		' MERGE '
		'	(farm: Farm { '
		'		name_lower: toLower(trim($farm)) '
		' 	}) '
		' 	-[:IS_IN]->(r) '
		'	ON CREATE SET '
		'		farm.name = trim($farm) '
		' MERGE '
		'	(f)-[s:SUBMITTED]->(farm) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN farm.name '
	)
	# plot procedures
	get_plots = (
		' MATCH '
		'	(p:Plot) '
		'	-[:IS_IN]->(:Farm {name_lower: toLower(trim($farm))}) '
		'	-[:IS_IN]->(:Region {name_lower: toLower(trim($region))}) '
		'	-[:IS_IN]->(:Country {name_lower: toLower(trim($country))}) '
		' RETURN '
		'	properties (p) '
	)
	plot_find = (
		' MATCH '
		'	(plot:Plot {name_lower: toLower(trim($plot))}) '
		' 	-[:IS_IN]->(:Farm { name: toLower(trim($farm))}) ' 
		' 	-[:IS_IN]->(:Region { name: toLower(trim($region))}) '
		' 	-[:IS_IN]->(:Country { name: toLower(trim($country))}) '
		' RETURN '
		'	plot '
	)
	# for autoincrement:
	# https://stackoverflow.com/questions/32040409/reliable-autoincrementing-identifiers-for-all-nodes-relationships-in-neo4j
	# for lock:
	# this allows the increment counter (allowing for concurrent transactions to be serialised):
	# http://neo4j.com/docs/stable/transactions-isolation.html
	# https://stackoverflow.com/questions/35138645/how-to-perform-an-atomic-update-on-relationship-properties-with-py2neo
	# https://stackoverflow.com/questions/31798311/write-lock-behavior-in-neo4j-cypher-over-transational-rest-ap
	plot_id_lock = (
		' MATCH '
		'	(id: Counter { '
		'		name: "plot" '
		' 	}) '
		' SET '
		'	id._LOCK_ = true '
	)
	plot_add = (
		' MATCH '
		'	(:User { '
		'		username_lower:toLower(trim($username)) '
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(: Locations) '
		'	-[: SUBMITTED]->(p: Plots), '
		'	(f: Farm { '
		'		name_lower: toLower(trim($farm)) '
		'	}) '
		'	-[:IS_IN]->(: Region { '
		'		name_lower: toLower($region) }) '
		'	-[:IS_IN]->(: Country { '
		'		name_lower: toLower($country) '
		' 	}),  '
		'	(id: Counter { '
		'		name: "plot" '
		'	}) '
		' SET '
		'	id.count = id.count + 1 '
		' MERGE '
		'	(plot: Plot: Item { '
		'		name_lower:toLower(trim(($plot))) '
		' 	}) '
		'	-[:IS_IN]->(f) '
		' 	ON CREATE SET '
		' 		plot.name = trim($plot), '
		'		plot.uid = id.count '
		# Create the plot level counters and container nodes for sub-levels
		' MERGE '
		'	(block_counter: Counter { '
		'		name: "block", '
		'		uid: (toString(id.count) + "_block") '
		'	}) '
		'	-[: FOR]->(: PlotBlocks)-[: IS_IN]->(plot) '
		'	ON CREATE SET '
		'		block_counter.count = 0 '
		' MERGE '
		'	(tree_counter: Counter { '
		'		name: "tree", '
		'		uid: (toString(id.count) + "_tree") '
		'	}) '
		'	-[: FOR]->(: PlotTrees)-[: IS_IN]->(plot) '
		'	ON CREATE SET '
		'		tree_counter.count = 0 '
		' MERGE '
		'	(branch_counter: Counter { '
		'		name: "branch", '
		'		uid: (toString(id.count) + "_branch") '
		'	}) '
		'	-[:FOR]->(: PlotBranches)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		branch_counter.count = 0 '
		' MERGE '
		'	(leaf_counter: Counter { '
		'		name: "leaf", '
		'		uid: (toString(id.count) + "_leaf") '
		'	}) '
		'	-[:FOR]->(: PlotLeaves)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		leaf_counter.count = 0 '
		' MERGE '
		'	(sample_counter: Counter { '
		'		name: "sample", '
		'		uid: (toString(id.count) + "_sample") '
		'	}) '
		'	-[:FOR]->(: PlotSamples)-[: FROM_PLOT]->(plot) '
		'	ON CREATE SET '
		'		sample_counter.count = 0 '
		# track time and user
		' MERGE '
		'	(p)-[s:SUBMITTED]->(plot) '
		'	ON CREATE SET '
		'		s.time = timestamp() '
		' MERGE '
		'	(id)-[: COUNTED]->(plot) '
		' SET id._LOCK_ = false' 
		' RETURN { '
		'	uid: plot.uid,'
		'	name:plot.name '
		' } '
	)
	# ITEM PROCEDURES
	# have unique plotID so don't need other location details
	id_lock = (
		' MATCH '
		'	(id:Counter { '
		'		name: $level, '
		'		uid: ($plotID + "_" + $level ) '
		'	}) '
		' SET '
		'	id._LOCK_ = true '
		' RETURN { '
		'	lock : id._LOCK_, '
		'	uid : id.uid '
		' } '
	)
	# a lock for separate BlockTree counters (store the count of trees per block only, not used to generate IDs)
	block_id_lock = (
		' MATCH '
		'	(id:Counter { '
		'		name: $level, '
		'		uid: ($blockUID + "_" + $level ) '
		'	}) '
		' SET '
		'	id._LOCK_ = true '
		' RETURN { '
		'	lock : id._LOCK_, '
		'	uid : id.uid '
		' } '
	)
	get_blocks = (
		' MATCH '
		'	(b:Block) '
		'	-[:IS_IN]->(:PlotBlocks) '
		'	-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		' RETURN properties (b) '
	)
	block_find = (
		' MATCH '
		'	(block:Block { '
		'		name : $block'
		'	}) '
		'	-[:IS_IN]->(:PlotBlocks) '
		'	-[:IS_IN]->(:Plot { '
		'		uid : toInteger($plotID) '
		'	}) '
		' RETURN '
		'	block '
	)
	block_add = (
		' MATCH '
		'	(: User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(b:Blocks), '
		'	(id:Counter { '
		'		uid: ($plotID + "_block") '
		'	}) '
		'	-[:FOR]->(pb: PlotBlocks) '
		'	-[:IS_IN]->(p:Plot) '
		' SET id.count = id.count+1 '
		' MERGE '
		'	(block: Block: Item { '
		'		name_lower: toLower(trim($block)), '
		'		uid:($plotID + "_B" + id.count), '
		'		id:id.count '
		'	}) '
		'	-[:IS_IN]->(pb) '
		' 	ON CREATE SET '
		'		block.name = trim($block) '
		' MERGE '
		'	(b)-[s:SUBMITTED]->(block) '
		'	ON CREATE SET '
		'		s.time = timestamp() '
		# Create BlockTrees container node and counter
		' MERGE '
		'	(block_tree_counter: Counter { '
		'		name: "tree", '
		'		uid: (block.uid + "_tree") '
		'	}) '
		'	-[:FOR]->(: BlockTrees)-[:IS_IN]->(block) '
		'	ON CREATE SET '
		'		block_tree_counter.count = 0 '
		' SET id._LOCK_ = false '
		' RETURN { '
		'	uid: block.uid, '
		'	name: block.name '
		' } '
	)
	get_blocks_details = (
		' MATCH '
		'	(b: Block) '
		'	-[:IS_IN]->(: PlotBlocks) '
		'	-[:IS_IN]->(p: Plot { '
		'		uid : toInteger($plotID)'
		'	}) '
		'	-[:IS_IN]->(f: Farm) '
		'	-[:IS_IN]->(r: Region) '
		'	-[:IS_IN]->(c: Country) '
		' RETURN { '
		'	Country: c.name, '
		'	Region: r.name, '
		'	Farm: f.name, '
		'	Plot: p.name, '
		'	PlotUID: p.uid, '
		'	Block: b.name, '
		'	BlockUID: b.uid, '
		'	BlockID: b.id '
		' } '
		' ORDER BY b.id '
	)
	# tree procedures
	trees_add = (
		# Start with users tree submissions node (UserTrees)
		# and the plots tree container (PlotTrees)
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ut:Trees), '
		'	(pt:PlotTrees)-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		# create per user per plot trees node (UserPlotTrees) linking these
		' MERGE '
		'	(ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		# keep the PlotTrees and UserPlotTrees nodes
		' WITH '
		'	pt, upt'
		# find the id counter node (plot tree counter)
		' MATCH '
		'	(id:Counter { '
		'		uid: ($plotID + "_tree") '
		'	}) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter ' 
		' 	SET '
		'		id.count = id.count + 1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		' 	CREATE '
		'		(t: Tree: Item { '
		'			uid: ($plotID + "_T" + id.count), '
		'			id: id.count, '
		'			custom_id: "", '
		'			variety: "" '
		'		}) '
		'		-[:IS_IN]->(pt) '
		'	CREATE '
		'		(upt)-[: SUBMITTED {time: timestamp()}]->(t) '
		# unlock the counter
		'	SET '
		'		id._LOCK_ = false '
		# and return a table of IDs
		'	RETURN '
		'		count (t)'
	)
	trees_add_block = (
		# Start with users tree submissions node (UserTrees)
		# and the plots tree container (PlotTrees)
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(ut:Trees), '
		'	(pt:PlotTrees)-[:IS_IN]->(:Plot { '
		'		uid: toInteger($plotID) '
		'	}), '
		'	(bt:BlockTrees)-[:IS_IN]->(:Block { '
		'		uid: $blockUID '
		'	}) '
		# create per user per plot trees node (UserPlotTrees) linking these
		' MERGE '
		'	(ut)-[:SUBMITTED]->(upt:UserPlotTrees)-[:CONTRIBUTED]->(pt) '
		# keep the PlotTrees and UserPlotTrees nodes
		' WITH '
		'	pt, upt, bt'
		# find the id counter node (plot tree counter)
		' MATCH '
		'	(id:Counter {uid: ($plotID + "_tree")}), '
		# and the block counter node
		'	(bc:Counter {uid: ($blockUID + "_tree")}) '
		# now iterate for the number of trees entered
		' UNWIND range(1, $count) as counter '
		'	SET '
		'		id.count = id.count + 1, '
		'		bc.count = bc.count + 1 '
		# add UserPlotTrees SUBMITTED trees with IS_IN relationship to PlotTrees
		'	CREATE '
		'		(t: Tree: Item { '
		'			uid: ($plotID + "_T" + id.count), '
		'			id: id.count, '
		'			custom_id: "", '
		'			variety: "" '
		'		}) '
		'		-[:IS_IN]->(pt), '
		'		(upt)-[:SUBMITTED { '
		'			time:timestamp() '
		'		}]->(t), '
		# link to block trees (record when it was added to this block and by who)
		'		(t)-[:IS_IN { '
		'			current: True, '
		'			time: timestamp(), '
		'			user: trim($username), '
		'			from: "web_form" '
		'		}]->(bt) '
		# unlock the counter
		'	SET '
		'		id._LOCK_ = false '
		'	RETURN '
		'		count(t) '
	)
	trees_get = (
		' MATCH '
		'	(tree: Tree) '
		'	-[:IS_IN]->(pt: PlotTrees) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid : toInteger($plotID) '
		'	}) '
		'	-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		# filter by range of tree ID's
		' WHERE '
		'	tree.id >= $start '
		' AND '
		'	tree.id <= $end '
		# find blocks if registered
		' OPTIONAL MATCH '
		'	(tree)-[:IS_IN {current:True}]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block)'
		' RETURN { '
		'	Country: country.name, '
		'	Region: region.name, '
		'	Farm: farm.name, '
		'	Plot: plot.name, '
		'	PlotUID: plot.uid, '
		'	Block: block.name, '
		'	BlockUID: block.uid, '
		'	TreeUID: tree.uid, '
		' 	TreeCustomID: tree.custom_id, '
		'	Variety: tree.variety, '
		'	TreeID: tree.id '
		' } '
		' ORDER BY tree.id '
	)
	treecount = (
		' MATCH '
		'	(tc: Counter { '
		'		uid: ($plotid + "_tree") '
		'	}) '
		' RETURN '
		'	tc.count '
	)
	# branch procedures
	branches_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User {'
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(:Submissions) '
		'	-[:SUBMITTED]->(:Items) '
		'	-[:SUBMITTED]->(user_branches:Branches), '
		# and both the PlotBranches and branch id counter nodes
		'	(tree:Tree) '
		'	-[:IS_IN]->(:PlotTrees)'
		'	-[:IS_IN]->(plot:Plot { '
		'		uid:toInteger($plotID) '
		'	}) '
		'	<-[:FROM_PLOT]-(plot_branches:PlotBranches) '
		'	<-[:FOR]-(id_counter:Counter { '
		'		uid: ($plotID + "_branch") '
		'	}), '
		'	(plot)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		' WHERE '
		'	tree.id >= toInteger($start) '
		' AND '
		'	tree.id <= toInteger($end) '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree)-[:IS_IN {current:True}]->(: BlockTrees) '
		'	-[:IS_IN]->(block: Block)'
		# create links for context TreeBranches and PlotBranches
		' MERGE '
		'	(tree_branches:TreeBranches)-[:FROM_TREE]->(tree) '
		' MERGE '
		'	(tree_branches)-[:FROM_PLOT]->(plot_branches)'
		# per UserBranches per PlotBranches for tracking
		' MERGE '
		'	(user_branches)-[:SUBMITTED]->(user_plot_branches:UserPlotBranches)-[:CONTRIBUTED]->(plot_branches) '
		# per UserPlotBranches per TreeBranches for tracking
		' MERGE '
		'	(user_plot_branches)-[:SUBMITTED]->(user_tree_branches:UserTreeBranches)-[:CONTRIBUTED]->(tree_branches) '
		' WITH '
		'	tree, '
		'	id_counter, '
		'	tree_branches, '
		'	user_tree_branches, '
		'	plot.uid as plot_uid, '
		'	plot.name as plot, '
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' ORDER BY '
		'	tree.id '
		# create new branch ids
		' UNWIND range(1, $replicates) as replicates '
		'	SET id_counter.count = id_counter.count + 1 '
		'	CREATE '
		'		(branch:Branch: Item { '
		'			uid: (plot_uid + "_R" + id_counter.count), '
		'			id: id_counter.count, '
		'			tree: tree.id, '
		'			replicates: $replicates '
		'		}) '
		# link branch to TreeBranches
		'	CREATE '
		'		(branch)-[:FROM_TREE]->(tree_branches) '
		# link UserTreeBranches to branch with timestamp for submission
		'	CREATE '
		'		(user_tree_branches)-[:SUBMITTED { '
		'			time : timestamp() '
		'		}]->(branch) '
		# unlock the id counter node
		'	SET '
		'		id_counter._LOCK_ = false '
		# return the list of ID's created
		'	RETURN { '
		'		Country : country, '
		'		Region : region, '
		'		Farm : farm, '
		'		Plot: plot, '
		'		PlotUID: plot_uid, '
		'		Block: block, '
		'		BlockUID: block_uid, '
		'		TreeUID: tree.uid, '
		'		Variety: tree.variety, '
		'		TreeCustomID: tree.custom_id, '
		'		BranchUID: branch.uid, '
		'		BranchID: branch.id '
		'	} '
		' ORDER BY branch.id '
	)
	branches_get = (
		' MATCH '
		'	(branch:Branch) '
		'	-[:FROM_TREE]->(tb:TreeBranches) '
		'	-[:FROM_TREE]->(tree:Tree) '
		'	-[:IS_IN]->(pt:PlotTrees) '
		'	-[:IS_IN]->(plot:Plot {uid : toInteger($plotID)}) '
		'	-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		# filter by range of tree ID's
		' WHERE tree.id >= $trees_start '
		' AND tree.id <= $trees_end '
		' AND branch.id >= $branches_start '
		' AND branch.id <= $branches_end '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree)-[: IS_IN {current:True}]->(:BlockTrees) '
		'	-[: IS_IN]->(block: Block) '
		' RETURN { '
		'	Country: country.name, '
		'	Region: region.name, '
		'	Farm: farm.name, '
		'	Plot: plot.name, '
		'	PlotUID: plot.uid, '
		'	Block: block.name, '
		'	BlockUID: block.uid, '
		'	TreeUID: tree.uid,'
		'	TreeCustomID: tree.custom_id,'
		'	Variety: tree.variety, '
		'	BranchUID: branch.uid, '
		'	BranchID: branch.id'
		' } '
		' ORDER BY '
		'	branch.id '
	)
	# leaf procedures
	leaves_add = (
		' MATCH '
		# find the user branch submission node
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(ul: Leaves), '
		# and both the PlotBranches and branch id counter nodes
		'	(t:Tree) '
		'	-[:IS_IN]->(: PlotTrees)'
		'	-[:IS_IN]->(p: Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		'	<-[:FROM_PLOT]-(pl: PlotLeaves) '
		'	<-[:FOR]-(id:Counter { '
		'		uid: ($plotID + "_leaf")'
		'	}) '
		' WHERE t.id >= toInteger($start) '
		' AND t.id <= toInteger($end) '
		' MATCH '
		'	(p)-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# find block if registered
		' OPTIONAL MATCH '
		'	(t)-[: IS_IN {current: True}]->(: BlockTrees)'
		'	-[:IS_IN]->(block:Block) '
		# Create links for context TreeLeaves and PlotLeaves
		' MERGE (tl:TreeLeaves)-[:FROM_TREE]->(t) '
		' MERGE (tl)-[:FROM_PLOT]->(pl) '
		# per UserLeaves per PlotLeaves for tracking
		' MERGE (ul)-[:SUBMITTED]->(upl: UserPlotLeaves)-[:CONTRIBUTED]->(pl) '
		# per UserPlotLeaves per TreeLeaves for tracking
		' MERGE (upl)-[:SUBMITTED]->(utl: UserTreeLeaves)-[:CONTRIBUTED]->(tl) '
		# create leaf ID's
		' WITH '
		'	t, id, tl, utl, '
		'	p.uid as plot_uid, '
		'	p.name as plot,'
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	farm.name as farm, '
		'	region.name as region, '
		'	country.name as country '
		' ORDER BY t.id '
		' UNWIND range(1, toInteger($replicates)) as replicates '
		'	SET '
		'		id.count = id.count + 1 '
		'	CREATE '
		'		(l: Leaf: Item { '
		'			uid: (plot_uid + "_L" + id.count), '
		'			id: id.count, '
		'			tree: t.id, '
		'			replicates: $replicates '
		'		}), '
		# link leaf to TreeLeaves
		'		(l)-[:FROM_TREE]->(tl), '
		# link UserTreeLeaves to branch with timestamp for submission
		'		(utl)-[:SUBMITTED {time: timestamp()}]->(l) '
		# unlock the id counter node
		'	SET id._LOCK_ = false '
		# return the list of ID's created
		' RETURN { '
		'	Country: country, '
		'	Region: region, '
		'	Farm: farm, '
		'	Plot: plot, '
		'	PlotUID: plot_uid, '
		'	Block: block, '
		'	BlockUID: block_uid, '
		'	TreeUID: t.uid, '
		'	TreeCustomID: t.custom_id, '
		'	Variety: t.variety, '
		'	LeafUID: l.uid, '
		'	LeafID: l.id '
		' } '
		' ORDER BY '
		'	l.id '
	)
	leaves_get = (
		' MATCH '
		'	(leaf: Leaf) '
		'	-[:FROM_TREE]-(tl: TreeLeaves) '
		'	-[:FROM_TREE]-(tree: Tree) '
		'	-[:IS_IN]->(pt: PlotTrees) '
		'	-[:IS_IN]->(plot: Plot { '
		'		uid : toInteger($plotID) '
		' }) '
		'	-[:IS_IN]->(farm: Farm) '
		'	-[:IS_IN]->(region: Region) '
		'	-[:IS_IN]->(country: Country) '
		# filter by ranges of ID's
		' WHERE tree.id >= $trees_start '
		' AND tree.id <= $trees_end '
		' AND leaf.id >= $leaves_start '
		' AND leaf.id <= $leaves_end '
		# find block if registered
		' OPTIONAL MATCH '
		'	(tree) '
		'	-[: IS_IN {current:True}]->(: BlockTrees)'
		'	-[:IS_IN]->(block: Block) '
		# and a branch if the leaf has been assigned to a branchID
		' OPTIONAL MATCH '
		'	(leaf) '
		'	-[:FROM_BRANCH {current: True}]->(branch: Branch) '
		' RETURN { '
		'	Country: country.name, '
		'	Region: region.name, '
		'	Farm: farm.name, '
		'	Plot: plot.name, '
		'	PlotUID: plot.uid, '
		'	Block: block.name, '
		'	BlockUID: block.uid, '
		'	TreeUID: tree.uid, '
		'	TreeCustomID: tree.custom_id, '
		'	Variety: tree.variety, '
		'	BranchUID: branch.uid,'
		'	LeafUID: leaf.uid, '
		'	LeafID: leaf.id '
		'	} '
		' ORDER BY '
		'	leaf.id '
	)
	# sample procedures
	# not sure if good idea for users to add these, maybe restrict to admins
	tissue_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: SampleDescriptors) '
		'	-[:SUBMITTED]->(tissues: Tissues) '
		' MERGE '
		'	(tissue:Tissue { '
		'		name_lower: toLower(trim($tissue)) '
		'	}) '
		'	ON CREATE SET '
		'		tissue.name = trim($tissue) '
		' MERGE '
		'	(tissues)-[s:SUBMITTED]->(tissue)'		
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN '
		'	tissue '
	)
	storage_add = (
		' MATCH '
		'	(user:User { '
		'		username_lower: toLower(trim($username)) '
		'	}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: SampleDescriptors) '
		'	-[:SUBMITTED]->(sm: StorageMethods) '
		' MERGE '
		'	(storage:Storage { '
		'		name_lower: toLower(trim($storage))}) '
		'	ON CREATE SET '
		'		storage.name = trim($storage) '
		' MERGE '
		'	(sm)-[s:SUBMITTED]->(storage) '
		'	ON CREATE SET s.time = timestamp() ' 
		' RETURN storage '
	)
	samples_add = (
		' MATCH '
		'	(:User { '
		'		username_lower: toLower(trim($username))}) '
		'	-[:SUBMITTED]->(: Submissions) '
		'	-[:SUBMITTED]->(: Items) '
		'	-[:SUBMITTED]->(samples: Samples), '
		'	(t:Tree) '
		'	-[:IS_IN]->(: PlotTrees) '
		'	-[:IS_IN]->(: Plot { '
		'		uid: toInteger($plotID) '
		'	}), '
		'	(tissue:Tissue { '
		'		name_lower: toLower(trim($tissue)) '
		'	}), '
		'	(storage:Storage { '
		'		name_lower: toLower(trim($storage)) '
		'	}), '
		'	(id:Counter { '
		'		uid: ($plotID + "_sample") '
		'	}) '
		'	-[:FOR]->(ps: PlotSamples) '
		'	-[:FROM_PLOT]->(p: Plot { '
		'		uid: toInteger($plotID) '
		'	}) '
		'	-[:IS_IN]->(f: Farm) '
		'	-[:IS_IN]->(r: Region) '
		'	-[:IS_IN]->(c: Country) '
		' WHERE '
		'	t.id >= $start '
		' AND '
		'	t.id <= $end '
		# with the selected trees to be sampled
		' WITH '
		'	t, tissue, storage, samples, id, ps, p, f, r, c '
		' ORDER BY '
		'	t.id '
		# get block name if available
		' OPTIONAL MATCH '
		'	(t) '
		'	-[:IS_IN {current: True}]->(: BlockTrees)'
		'	-[:IS_IN]->(block:Block) '
		# Merge a per Tissue per Storage container node
		' MERGE '
		'	(tissue)<-[: OF_TISSUE]-(TiSt: TissueStorage)-[:STORED_IN]->(storage) '
		# And split this off per PlotSamples
		' MERGE '
		'	(TiSt)<-[: COLLECTED_AS]-(pts: PlotTissueStorage)-[: FROM_PLOT]->(ps) '
		# Create a TreeSamples node per tree
		' MERGE '
		'	(t)<-[:FROM_TREE]-(ts:TreeSamples) '
		# Track user submissions through successive UserPlotSamples then UserTreeSamples container nodes
		' MERGE '
		'	(samples)-[:SUBMITTED]->(ups:UserPlotSamples)-[:CONTRIBUTED]->(ps) '
		' MERGE '
		'	(ups)-[:SUBMITTED]->(uts:UserTreeSamples)-[:CONTRIBUTED]->(ts) '
		' WITH '
		'	id, '
		'	ts, '
		'	pts, '
		'	uts, '
		'	t, '
		'	tissue.name as tissue, '
		'	storage.name as storage, '
		'	block.name as block, '
		'	block.uid as block_uid, '
		'	p.name as plot, '
		'	p.uid as plot_uid, '
		'	f.name as farm, '
		'	r.name as region, '
		'	c.name as country '
		# with replicates
		' UNWIND '
		'	range(1, $replicates) as replicates '
		# incrementing with a plot level counter
		'	SET '
		'		id.count = id.count + 1 '
		# Create samples
		'	CREATE '
		'		(s: Sample: Item { '
		'			uid: (plot_uid + "_S" + id.count), '
		'			id: id.count, '
		'			replicates: $replicates, '
		'			date: $date, '
		'			time: $time '
		'		}) '
		# Link the sample to its TreeSamples
		'	MERGE '
		'		(s)-[: FROM_TREE]->(ts) '
		# and the PlotTissueStorage container
		'	MERGE '
		'		(s)-[: COLLECTED_AS]->(pts) '
		# and user tracking through UserTreeSamples
		'	MERGE  '
		'		(uts)-[s1:SUBMITTED]->(s) '
		'		ON CREATE SET s1.time = timestamp() '
		'	SET '
		'		id._LOCK_ = false '
		# return for csv
		'	RETURN { '
		'		Country : country, '
		'		Region : region, '
		'		Farm : farm, '
		'		Plot : plot, '
		'		PlotUID : plot_uid, '
		'		Block : block, '
		'		BlockUID : block_uid, '
		'		TreeUID : t.uid, '
		'		TreeCustomID : t.custom_id, '
		'		Variety: t.variety, '
		'		SampleUID : s.uid, '
		'		Tissue : tissue, '
		'		Storage : storage, '
		'		Replicates: $replicates, '
		'		Date: $date, '
		'		SampleID: s.id '
		'	} '
		'	ORDER BY s.id '
		)
	# Upload procedures
	upload_check_value = (
		# make sure that all the entries match accepted entries
		# handles empty items and white space
		# forces strings to lower case and float/integer types
		# removes % symbols
		# ! ensure to declare trait (as node) and value (from file) before including
		' CASE '
		'	WHEN trait.format = "multicat" '
		'		THEN CASE '
		'			WHEN size(FILTER (n in split(value, ":") WHERE size(n) > 0)) '
		'				= size(FILTER (n in split(value, ":") WHERE toLower(trim(n)) in '
		'					extract(item in trait.category_list | toLower(item)))) '
		'			THEN extract(i in FILTER (n in split(value, ":") WHERE  size(n) > 0 )| trim(i)) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "categorical" '
		'		THEN CASE '
		'			WHEN toLower(trim(value)) in extract(item in trait.category_list | toLower(item)) '
		'				THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "text" '
		'		THEN CASE '
		'			WHEN trait.name_lower = "assign to block" '
		'				THEN CASE '
		'					WHEN size(split(value, "_" )) = 2 '
		'					AND left(split(toUpper(value), "_")[1],1) = "B" '
		'					THEN toUpper(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "assign to branch" '
		'				THEN CASE '
		'					WHEN size(split(value, "_" )) = 2 '
		'					AND left(split(toUpper(value), "_")[1],1) = "R" '
		'					THEN toUpper(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "assign to leaf" '
		'				THEN CASE '
		'					WHEN size(split(value, "_" )) = 2 '
		'					AND left(split(toUpper(value), "_")[1],1) = "L" '
		'					THEN toUpper(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "variety name (text)" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "el frances code (text)" '
		'				THEN CASE '
		'					WHEN toLower(value) in extract(item in trait.category_list | toLower(item)) '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name_lower = "synthetic fertiliser n:p:k ratio" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 3 '
		'					AND toFloat(trim(split(value, ":")[0])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[1])) IS NOT NULL '
		'					AND toFloat(trim(split(value, ":")[2])) IS NOT NULL '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			WHEN trait.name contains "time" '
		'				THEN CASE '
		'					WHEN size(split(value, ":")) = 2 '
		'					AND size(split(value, ":")[0]) <= 2 '
		'					AND toInteger(trim(split(value, ":")[0])) <=24 '
		'					AND toInteger(trim(split(value, ":")[0])) >= 0 '
		'					AND size(split(value, ":")[1]) <= 2 '
		'					AND toInteger(trim(split(value, ":")[1])) < 60 '
		'					AND toInteger(trim(split(value, ":")[1])) >= 0 '
		'						THEN trim(value) '
		'					ELSE Null '
		'					END '
		'			ELSE '
		'				toString(value) '
		'			END '
		'	WHEN trait.format = "percent" '
		'		THEN CASE '
		'			WHEN toFloat(replace(value, "%", "")) IS NOT NULL '
		'				THEN toFloat(replace(value, "%", "")) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "counter" '
		'		THEN CASE '
		'			WHEN toInteger(value) IS NOT NULL '
		'				THEN toInteger(value) '
		'			ELSE '
		'				Null '
		'			END '
		'	WHEN trait.format = "numeric" '
		'		THEN CASE '
		'			WHEN toFloat(value) IS NOT NULL '
		'				THEN toFloat(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "boolean" '
		'		THEN CASE '
		'			WHEN toLower(value) in ["yes","y"] '
		'				THEN True '
		'			WHEN toLower(value) in ["no","n"] '
		'				THEN False '
		'			WHEN toBoolean(value) IS NOT NULL '
		'				THEN toBoolean(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "location" '
		'		THEN CASE '
		'			WHEN size(split(value, ";")) = 2 '
		'			AND toFloat(trim(split(value, ";")[0])) IS NOT NULL '
		'			AND toFloat(trim(split(value, ";")[1])) IS NOT NULL '
		'				THEN trim(value) '
		'			ELSE Null '
		'			END '
		'	WHEN trait.format = "date" '
		'		THEN CASE '
		'			WHEN size(split(value, "-")) = 3 '
		'			AND size(trim(split(value, "-")[0])) = 4 '
		'			AND size(trim(split(value, "-")[1])) <= 2 '
		'			AND size(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) <= 12 '
		'			AND size(trim(split(value, "-")[2])) <= 2 '
		'			AND size(trim(split(value, "-")[2])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) >= 1 '
		'			AND toInteger(trim(split(value, "-")[1])) <= 31 '
		'			THEN '
		'				apoc.date.parse(value,"ms","yyyy-MM-dd HH:mm:sszzz") '
		'			ELSE '
		'				Null '
		'			END '
		'	ELSE Null '
		'	END '
	)
	# generic upload to handle mixed UID (multiple levels) in csv in database format
	upload_fb_check = (
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	trim(toUpper(csvLine.uid)) as uid, '
		'	trim(toLower(csvLine.trait)) as trait_name_lower, '
		'	trim(csvLine.value) as value '
		# Identify the items and traits assessed
		' OPTIONAL MATCH '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					uid '
		'				END '
		'	})'
		' OPTIONAL MATCH '
		'	(trait: Trait { '
		'		name_lower: trait_name_lower, '
		'		level: '
		'			CASE '
		'				WHEN split(uid, "_")[1] IS NULL '
		'					THEN "plot" '
		'				WHEN left(split(uid, "_")[1],1) = "B" '
		'					THEN "block" '
		'				WHEN left(split(uid, "_")[1],1) = "T" '
		'					THEN "tree" '
		'				WHEN left(split(uid, "_")[1],1) = "R" '
		'					THEN "branch" '
		'				WHEN left(split(uid, "_")[1],1) = "L" '
		'					THEN "leaf" '
		'				WHEN left(split(uid, "_")[1],1) = "S" '
		'					THEN "sample" '
		'				END '
		'	}) '
		' 	WITH '
		'		CASE WHEN item IS NULL THEN False ELSE True END as item, '
		'		CASE WHEN trait IS NULL THEN False ELSE trait.name_lower END as trait, '
		'		trait.format as format, '
		'		trait.category_list as category_list, '
		'		CASE WHEN item IS NOT NULL AND trait IS NOT NULL '
		'			THEN '
		'				CASE WHEN ' + upload_check_value +
		'				IS NULL THEN False ELSE True END '
		'			ELSE False '
		'			END '
		'			as value ' 
		' RETURN { '
		'	uid: item, '
		'	trait: trait, '
		'	format: format,'
		'	category_list: category_list,'
		'	value: value '
		' } '
	)
	shared_upload_code = (
		' FOREACH (n in CASE '
		'	WHEN trait.level = "plot" '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(item)<-[: FOR_ITEM]-()-[: FOR_TRAIT]->(trait) '
		' ) '
		' FOREACH (n in CASE '
		'	WHEN trait.level in ["block","tree"] '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(plot_item_plot)<-[: FROM_PLOT]-(pt)-[: FOR_TRAIT]->(trait) '
		'			MERGE '
		'				(item)<-[: FOR_ITEM]-()-[: FOR_TRAIT]->(pt) '
		' ) '
		' FOREACH (n in CASE '
		'	WHEN trait.level in ["branch","leaf","sample"] '
		'		THEN [1] ELSE [] END | '
		'			MERGE '
		'				(tree_item_plot)<-[: FROM_PLOT]-(pt)-[: FOR_TRAIT]->(trait) '
		'			MERGE '
		'				(tree_item_tree)<-[:FROM_TREE]-(tt)-[: FOR_TRAIT]->(pt) '
		'			MERGE '
		'				(item)<-[:FOR_ITEM]-()-[: FOR_TRAIT]->(pt) '
		' ) '
		# get rid of some of the optional matches since they are no longer needed
		' WITH '
		'	item, trait, time, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, '
		'	location, timestamp, table_time, table_date, '
		+ upload_check_value + ' AS value WHERE value IS NOT NULL '
		# get the user submission tracking nodes
		' MATCH '
		'	(:User { '
		'		username_lower : toLower(trim($username))'
		'	}) '
		'	-[: SUBMITTED]->(: Submissions) '
		'	-[: SUBMITTED]->(data_sub: DataSubmissions), '
		# and the item/trait node 
		'	(item)<-[ :FOR_ITEM]-(item_trait)-[ :FOR_TRAIT*..3]->(trait) '
		# Perform optional matches so can modify relationships for some traits
		#
		# In case trait "assign to block"
		# if has block assignment find current IS_IN block-trees rel (to remove current flag) and counter (to decrement)
		' OPTIONAL MATCH '
		'	(item) '
		'		-[is_in_block_current:IS_IN {current: True}]->(: BlockTrees)'
		'		<-[:FOR]-(block_counter_current:Counter) '
		# and then find the block by uid for update of IS_IN block-trees rel and counter (only match within plot_item_plot)
		' OPTIONAL MATCH '
		'	(block_counter_update: Counter) '
		'	-[: FOR]->(block_trees_update: BlockTrees) '
		'	-[: IS_IN]->(: Block {uid: value}) '
		'	-[: IS_IN]->( :PlotBlocks)'
		'	-[: IS_IN]->(plot_item_plot) '
		# Using many with statements around long optional match blocks
		# otherwise there is a database error I haven't diagnosed
		' WITH '
		'	item, trait, item_trait, time, value, data_sub, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, '
		'	location, timestamp, table_time, table_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update '
		# In case trait "assign to branch"
		# if item has branch assignment find current
		' OPTIONAL MATCH '
		'	(item)-[from_branch_current: FROM_BRANCH {current: True}]->(:Branch) '
		# and update branch by uid
		' OPTIONAL MATCH '
		'	(branch_update: Branch {uid: value})-[: FROM_TREE*2]->(tree_item_tree) '
		' WITH '
		'	item, trait, item_trait, time, value, data_sub, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, '
		'	location, timestamp, table_time, table_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	from_branch_current, branch_update '
		# In case when trait "assign to leaf"
		# find current leaf assignment
		' OPTIONAL MATCH '
		'	(item)-[from_leaf_current:FROM_LEAF {current:True}]->(:Leaf) '
		# and update leaf by uid
		' OPTIONAL MATCH '
		'	(leaf_update: Leaf {uid: value})-[:FROM_TREE*2]->(tree_item_tree) '
		' WITH '
		'	item, trait, item_trait, time, value, data_sub, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, '
		'	location, timestamp, table_time, table_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	from_branch_current, branch_update, '
		'	from_leaf_current, leaf_update '	
		# In case trait is "variety name (text)" or "el frances code (text)" 
		# find current variety assignment
		' OPTIONAL MATCH '
		'	(item)-[is_variety_current: IS_VARIETY {current:True}]->()-[:IS_VARIETY]->(:Variety) '
		# find variety by name
		' OPTIONAL MATCH '
		'	(variety_name_update:Variety {name_lower: toLower(toString(value))}) '
		# or by code
		' OPTIONAL MATCH '
		'	(variety_code_update:Variety {el_frances_code_lower: toLower(toString(value))}) '
		' WITH '
		'	item, trait, item_trait, time, value, data_sub, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, '
		'	location, timestamp, table_time, table_date, '
		'	is_in_block_current, block_counter_current, block_trees_update, block_counter_update, '
		'	from_branch_current, branch_update, '
		'	from_leaf_current, leaf_update, '
		'	is_variety_current, '
		'	CASE '
		'		WHEN variety_name_update IS NOT NULL AND variety_code_update IS NULL '
		'		THEN variety_name_update '
		'		WHEN variety_name_update IS NULL AND variety_code_update IS NOT NULL '
		'		THEN variety_code_update '
		'		ELSE Null END as variety_update '
		# Merge the data point to ensure unique to the time and item/trait node
		' MERGE '
		'	(d:Data { '
		'		time : time '
		'	}) '
		'	-[:DATA_FOR]->(item_trait) '
		'	ON MATCH SET '
		'		d.found = True '
		'	ON CREATE SET '
		'		d.found = False, '
		'		d.location = location, '
		'		d.person = person, '
		'		d.value = value, '
		'		d.timestamp = timestamp, '
		'		d.table_date = table_date, '
		'		d.table_time = table_time '
		# additional statements to occur when new data point
		' FOREACH (n IN CASE '
		'		WHEN d.found = False '
		'			THEN [1] ELSE [] END | '
		# track user submissions through /User/Trait container
		'				MERGE '
		'					(data_sub)-[:SUBMITTED]->(ut) '
		'					-[:CONTRIBUTED]->(trait) '
		# then /UserTrait/ItemTrait container
		'				MERGE '
		'					(ut)-[:SUBMITTED]->(uit) '
		'					-[:CONTRIBUTED]->(item_trait) '
		# then finally the data with a timestamp
		'				MERGE '
		'					(uit)-[s1:SUBMITTED]->(d) '
		'					ON CREATE SET '
		'						s1.time = timestamp() '
		' ) '
		# Now update "special" trait values
		# if "assign to block" 
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower = "assign to block" '
		'	AND block_trees_update IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# link tree to block (and track number of trees in block with counter)
		'			MERGE '
		'				(item)-[s1:IS_IN]->(block_trees_update) '
		'			ON CREATE SET '
		'				s1.time = timestamp(), '
		'				s1.user = $username, '
		'				s1.from = "upload" '
		'			SET '
		'				is_in_block_current.current = False, '
		'				s1.current = True, '
		'				block_counter_current.count = block_counter_current.count - 1, '
		'				block_counter_update.count = block_counter_update.count + 1 '
		' ) '
		# if trait is branch id then link to branch
		' FOREACH (n IN CASE '
		'	WHEN trait.level in ["leaf","sample"] '
		'	AND trait.name_lower = "assign to branch" '
		'	AND branch_update IS NOT NULL '
		'	THEN [1] ELSE [] END | '
		'		MERGE '
		'			(item)-[s1:FROM_BRANCH]->(branch_update) '
		'		ON CREATE SET '
		'			s1.time = timestamp(), '
		'			s1.user = $username, '
		'			s1.from = "upload" '
		'		SET  '
		'			from_branch_current.current = False,  '
		'			s1.current = True  '
		' ) '
		# if trait is leaf id then link to leaf
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "sample" '
		'	AND trait.name_lower = "assign to leaf" '
		'	AND leaf_update IS NOT NULL '
		'	THEN [1] ELSE [] END | '
		'		MERGE '
		'			(item)-[s1:FROM_LEAF]->(leaf_update) '
		'		ON CREATE SET '
		'			s1.time = timestamp(), '
		'			s1.user = $username, '
		'			s1.from = "upload" '
		'		SET  '
		'			from_leaf_current.current = False,  '
		'			s1.current = True  '
		' ) '
		# if variety trait
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower IN ["variety name (text)", "el frances code (text)"] '
		'	AND variety_update IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'			MERGE '
		'				(plot_item_plot)<-[: FROM_PLOT]-(pv) '
		'				-[: IS_VARIETY]->(variety_update) '
		'			MERGE '
		'				(item)-[s1: IS_VARIETY]->(pv) '
		'			ON CREATE SET '
		'				s1.time = timestamp(), '
		'				s1.user = $username, '
		'				s1.from = "upload" '
		'			SET '
		'				is_variety_current.current = False, '
		'				s1.current = True, '
		# also set the tree variety property
		'				item.variety = variety_update.name '
		' ) '
		# if custom tree ID set custom id parameter. 
		' FOREACH (n IN CASE '
		'	WHEN trait.level = "tree" '
		'	AND trait.name_lower = "custom tree id" '
		'	AND d.value IS NOT NULL '
		'		THEN [1] ELSE [] END | '
		# Create per plot per Variety node
		'			SET '
		'				item.custom_id = toString(d.value) '
		' ) '	
		' WITH '
		'	d, value, item, trait, timestamp '
		' MATCH '
		'	(user:User)-[:SUBMITTED*..7]->()-[submitted:SUBMITTED]->(d) '
		# And give the user feedback on their submission success
		' RETURN { '
		'	found: d.found, '
		'	submitted_by: user.name, '
		'	submitted_at: submitted.time, '
		'	value: d.value, '
		'	uploaded_value: value, '
		'	uid: item.uid, '
		'	trait: trait.name, '
		'	time: d.time, '
		'	timestamp: d.timestamp, '
		'	table_date: d.table_date, '
		'	table_time: d.table_time '
		' } '
	)
	upload_fb = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	trim(csvLine.location) as location, '
		'	trim(csvLine.person) as person, '
		'	trim(toUpper(csvLine.uid)) as uid, '
		'	toLower(trim(csvLine.trait)) as trait_name_lower, '
		'	csvLine.timestamp as timestamp, '
		'	trim(csvLine.value) as value, '
		'	apoc.date.parse(csvLine.timestamp, "ms", "yyyy-MM-dd HH:mm:sszzz") as time '
		# Identify the items and traits assessed
		' MATCH '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					uid '
		'				END '
		'	}), '
		'	(trait: Trait { '
		'		name_lower: trait_name_lower, '
		'		level: '
		'			CASE '
		'				WHEN split(uid, "_")[1] IS NULL '
		'					THEN "plot" '
		'				WHEN left(split(uid, "_")[1],1) = "B" '
		'					THEN "block" '
		'				WHEN left(split(uid, "_")[1],1) = "T" '
		'					THEN "tree" '
		'				WHEN left(split(uid, "_")[1],1) = "R" '
		'					THEN "branch" '
		'				WHEN left(split(uid, "_")[1],1) = "L" '
		'					THEN "leaf" '
		'				WHEN left(split(uid, "_")[1],1) = "S" '
		'					THEN "sample" '
		'				END '
		'	}) '
		'	WHERE size(value) > 0 '
		# these optional matches are used in FOREACH CASE statements 
		# to create Plot or Tree item trait containers where appropriate
		' OPTIONAL MATCH '
		'	(item)-[:IS_IN*2]->(plot_item_plot:Plot) '
		' OPTIONAL MATCH '
		'	(item)-[:FROM_TREE*2]->(tree_item_tree:Tree) '
		'	-[:IS_IN*2]->(tree_item_plot:Plot) '
		' WITH '
		'	item, trait, '
		'	plot_item_plot, tree_item_tree, tree_item_plot, '
		'	person, time, '
		'	value, '
		# this is unique to FB uploads
		'	timestamp, '
		'	location, '
		# the following are nulls where table has values to allow shared code between formats
		'	null as table_time, '
		'	null as table_date '
		'	WHERE time IS NOT NULL '
		+ shared_upload_code
	)
	# Upload Table procedures
	upload_table_check = (
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine, '
		'	trim(toUpper(csvLine.uid)) as uid '
		' OPTIONAL MATCH  '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					toUpper(uid) '
		'				END '
		'	}) '
		' UNWIND $traits as trait_name '
		'	OPTIONAL MATCH '
		'		(trait: Trait { '
		'			name_lower: toLower(trait_name), '
		'			level: '
		'				CASE '
		'					WHEN split(uid, "_")[1] IS NULL '
		'						THEN "plot" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "B" '
		'						THEN "block" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "T" '
		'						THEN "tree" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "R" '
		'						THEN "branch" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "L" '
		'						THEN "leaf" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "S" '
		'						THEN "sample" '
		'					END '
		'		}) '
		'	WITH item, trait, csvLine[trait_name] as value '
		' 	WITH '
		'		CASE WHEN item IS NULL THEN False ELSE True END as item, '
		'		CASE WHEN trait IS NULL THEN False ELSE trait.name_lower END as trait, '
		'		trait.format as format, '
		'		trait.category_list as category_list,'
		'		CASE WHEN item IS NOT NULL AND trait IS NOT NULL '
		'			THEN '
		'				CASE WHEN ' + upload_check_value +
		'				IS NULL THEN False ELSE True END '
		'			ELSE False '
		'			END '
		'			as value ' 
		' RETURN { '
		'	uid: item, '
		'	trait: trait, '
		'	format: format,'
		'	category_list: category_list,'
		'	value: value '
		' } '
	)
	upload_table = (
		# load in the csv
		' LOAD CSV WITH HEADERS FROM $filename as csvLine '
		' WITH '
		'	csvLine, '
		'	trim(csvLine.person) as person, '
		'	trim(toUpper(csvLine.uid)) as uid, '
		'	apoc.date.parse( '
		'		CASE '
		'			WHEN size(split(replace(csvLine.date, " ", ""), "-")) = 3 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[0]) = 4 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[1]) <=2 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[1]) >=1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[1]) >= 1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[1]) <= 12 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[2]) <=2 '
		'			AND size(split(replace(csvLine.date, " ", ""), "-")[2]) >=1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[2]) >= 1 '
		'			AND toInteger(split(replace(csvLine.date, " ", ""), "-")[2]) <= 31 '
		'			THEN '
		'				replace(csvLine.date, " ", "") '
		'			ELSE '
		'				Null '
		'			END '
		'		+ " " + '
		'		CASE '
		'			WHEN size(split(replace(csvLine.time, " ", ""), ":")) = 2 '
		'			AND size(split(replace(csvLine.time, " ", ""), ":")[0]) <= 2 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[0]) <=24 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[0]) >= 0'
		'			AND size(split(replace(csvLine.time, " ", ""), ":")[1]) <= 2 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[1]) <=24 '
		'			AND toInteger(split(replace(csvLine.time, " ", ""), ":")[1]) >=0 '
		'			THEN '
		'				replace(csvLine.time, " ", "") '
		'			ELSE '
		'				NULL '
		'			END '
		'		, "ms", "yyyy-MM-dd HH:mm") as time '
		# And identify the plots and traits assessed
		' MATCH  '
		'	(item: Item { '
		'		uid: '
		'			CASE '
		'				WHEN size(split(uid, "_")) = 1 '
		'					THEN toInteger(uid) '
		'				ELSE '
		'					toUpper(uid) '
		'				END '
		'	}) '
		' UNWIND $traits as trait_name '
		'	MATCH '
		'		(trait: Trait { '
		'			name_lower: toLower(trait_name), '
		'			level: '
		'				CASE '
		'					WHEN split(uid, "_")[1] IS NULL '
		'						THEN "plot" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "B" '
		'						THEN "block" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "T" '
		'						THEN "tree" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "R" '
		'						THEN "branch" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "L" '
		'						THEN "leaf" '
		'					WHEN toUpper(left(split(uid, "_")[1],1)) = "S" '
		'						THEN "sample" '
		'					END '
		'		}) '
		# Check for data in table
		# all load_csv values are string so can just check size after trimming whitespace  
		'	WHERE size(csvLine[trait_name]) > 0 '
		'	OPTIONAL MATCH '
		'		(item)-[:IS_IN*2]->(plot_item_plot:Plot) '
		'	OPTIONAL MATCH '
		'		(item)-[:FROM_TREE*2]->(tree_item_tree:Tree) '
		'		-[:IS_IN*2]->(tree_item_plot:Plot) '
		'	WITH '
		'		item, trait, '
		'		plot_item_plot, tree_item_tree, tree_item_plot, '
		'		person, time, '
		'		csvLine[trait_name] as value, '
		# these are unique to table uploads
		' 		csvLine.time as table_time, '
		'		csvLine.date as table_date, '
		# the following are null where FB has values to allow shared code between formats
		'		null as timestamp, '
		'		null as location '
		' 		WHERE time IS NOT Null '
		+ shared_upload_code
	)

	get_plots_treecount = (' MATCH (C:Country)<-[:IS_IN]-(R:Region) '
		' OPTIONAL MATCH (R)<-[:IS_IN]-(F:Farm) '
		' OPTIONAL MATCH (F)<-[:IS_IN]-(P:Plot) '
		' OPTIONAL MATCH (P)<-[:IS_IN]-(:PlotTrees)<-[:FOR]-(T:Counter {name:"tree"}) '
		' OPTIONAL MATCH (P)<-[:IS_IN*..2]-(B:Block) '
		' OPTIONAL MATCH (B)<-[:IS_IN*..2]-(t:Tree) '
		' WITH C, R, F, P, T, {name: B.name, label:"Block", treecount:count(t)} as blocks, count(t) as blocktrees '
		' WITH C, R, F, {name: P.name, label:"Plot", treecount: T.count - sum(blocktrees), children: FILTER(block IN collect(blocks) WHERE block["name"] IS NOT NULL)} as plots '
		' WITH C, R, {name: F.name, label:"Farm", children: FILTER(plot IN collect(plots) WHERE plot["name"] IS NOT NULL)} as farms '
		' WITH C, {name: R.name, label:"Region", children: FILTER(farm IN collect(farms) WHERE farm["name"] IS NOT NULL)} as regions '
		' WITH {name: C.name, label:"Country", children: FILTER(region IN collect (regions) WHERE region["name"] IS NOT NULL)} as countries '
		' RETURN countries ' )
	get_submissions_range = (
		# first get all the data collections and link to a base node formed from block/plot/farm
		' MATCH '
		'	(:User {username_lower: toLower($username)}) '
		'		-[:SUBMITTED*4]->() '
		'		-[s:SUBMITTED]->(data: Data) '
		'		-[:DATA_FOR]->(dit) '
		'		-[:FOR_TRAIT*..2]->(trait: Trait), '
		'	(dit) '
		'		-[:FOR_ITEM]->(item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' OPTIONAL MATCH '
		'	(item)-[:FROM_TREE*2]->(tree_item_tree:Tree) '
		'	-[:IS_IN {current: True}]-() '
		'	-[:IS_IN]->(tree_item_block: Block) '
		'	-[:IS_IN*2]->(tree_item_block_plot: Plot) '
		' OPTIONAL MATCH '
		'	(tree_item_tree)-[:IS_IN*2]->(tree_item_plot:Plot) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN {current: True}]-()'
		'	-[:IS_IN]->(tree_block: Block) '
		'	-[:IS_IN*2]->(tree_block_plot: Plot) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN*2]->(tree_plot) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN*2]->(block_plot: Plot) '
		' OPTIONAL MATCH '
		'	(item) '
		'	-[:IS_IN]->(plot_farm:Farm) '
		' RETURN '
		'	"Trait" as d_label, '
		'	trait.name + " (" + count(distinct(data)) + ")" as d_name, '
		'	COALESCE( '
		'		id(tree_item_block), '
		'		id(tree_item_plot), '
		'		id(tree_block), '
		'		id(tree_plot), '
		'		id(block_plot), '
		'		id(plot_farm) '
		'		) + "_" + id(trait) as d_id, '
		'	filter(i IN labels(item) WHERE i <> "Item")[0] as n_label, '
		'	CASE WHEN '
		'		trait.level in ["sample", "leaf", "branch", "tree"] '
		'		THEN '
		'			count(DISTINCT item) '
		'		ELSE '
		'			item.name '
		'		END '	
		'	 	as n_name,'
		'	CASE WHEN '
		'		trait.level in ["sample", "leaf", "branch", "tree"] '
		'		THEN '
		'			COALESCE( '
		'				id(tree_item_block), '
		'				id(tree_item_plot), '
		'				id(tree_block), '
		'				id(tree_plot) '
		'				) + "_" + id(trait) + filter(i IN labels(item) WHERE i <> "Item")[0] + "_count_node" '
		'		ELSE '
		'			id(item) '
		'		END '
		'		as n_id, '
		'	"FROM" as r_type, '
		'	COALESCE( '
		'		id(tree_item_block), '
		'		id(tree_item_plot), '
		'		id(tree_block), '
		'		id(tree_plot), '
		'		id(block_plot), '
		'		id(plot_farm) '
		'		) + "_" + id(trait) + filter(i IN labels(item) WHERE i <> "Item")[0] + "_data_node" as r_id, '
		'	COALESCE( '
		'		id(tree_item_block), '
		'		id(tree_item_plot), '
		'		id(tree_block), '
		'		id(tree_plot), '
		'		id(block_plot), '
		'		id(plot_farm) '
		'		) + "_" + id(trait) as r_start, '
		'	CASE WHEN '
		'		trait.level in ["sample", "leaf", "branch", "tree"] '
		'		THEN '
		'			COALESCE( '
		'				id(tree_item_block), '
		'				id(tree_item_plot), '
		'				id(tree_block), '
		'				id(tree_plot) '
		'				) + "_" + id(trait) + filter(i IN labels(item) WHERE i <> "Item")[0] + "_count_node" '
		'		ELSE '
		'			id(item) '
		'		END '
		'		as r_end '
		' UNION '
		#link the above into block context where relevant
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(data:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_block:Block)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(tree_block:Block) '
		' WITH distinct(COALESCE(tree_item_block, tree_block)) as block '
		' MATCH (block)-[:IS_IN*2]->(plot:Plot) '
		' RETURN '
			' "Block" as d_label, '
			' block.name as d_name, '
			' id(block) as d_id, '
			' "Plot" as n_label, '
			' plot.name as n_name, '
			' id(plot) as n_id, '
			' "IS_IN" as r_type,  '
			' (id(block) + "_" + id(plot)) as r_id, '
			' id(block) as r_start, '
			' id(plot) as r_end'
		' UNION '
		#and then plots into blocks
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(data:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_plot:Plot)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(tree_plot:Plot) '
		' WITH distinct(COALESCE(tree_item_plot, tree_plot)) as plot '
		' MATCH (plot)-[:IS_IN]->(farm:Farm) '
		' RETURN '
		' "Plot" as d_label, '
		' plot.name as d_name, '
		' id(plot) as d_id, '
		' "Farm" as n_label, '
		' farm.name as n_name, '
		' id(farm) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(plot) + "_" + id(farm)) as r_id, '
		' id(plot) as r_start, '
		' id(farm) as r_end'
		' UNION '
		# and then farms into regions
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(data:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_plot:Plot)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(tree_plot:Plot) '
		' WITH distinct(COALESCE(tree_item_plot, tree_plot)) as plot '
		' MATCH '
		'	(plot)-[:IS_IN]->(farm:Farm) '
		'	-[:IS_IN]->(region:Region) '
		' RETURN '
		' "Farm" as d_label, '
		' farm.name as d_name, '
		' id(farm) as d_id, '
		' "Region" as n_label, '
		' region.name as n_name, '
		' id(region) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(farm) + "_" + id(region)) as r_id, '
		' id(farm) as r_start, '
		' id(region) as r_end '
		' UNION '
		# and then regions into countries
		' MATCH (:User {username_lower: toLower($username)}) '
		'	-[:SUBMITTED*4]->() '
		'	-[s:SUBMITTED]->(data:Data) '
		'	-[:DATA_FOR]->() '
		'	-[:FOR_ITEM]->(item:Item) '
		' WHERE s.time >=$starttime AND s.time <= $endtime'
		' WITH item '
		' OPTIONAL MATCH (item) '
		'	-[:FROM_TREE*2]->(:Tree) '
		'	-[:IS_IN*2]->(tree_item_plot:Plot)'
		' OPTIONAL MATCH (item) '
		'	-[:IS_IN*2]->(tree_plot:Plot) '
		' WITH distinct(COALESCE(tree_item_plot, tree_plot)) as plot '
		' MATCH '
		'	(plot)-[:IS_IN]->(:Farm) '
		'	-[:IS_IN]->(region:Region) '
		'	-[:IS_IN]->(country:Country) '
		' RETURN '
		' "Region" as d_label, '
		' region.name as d_name, '
		' id(region) as d_id, '
		' "Country" as n_label, '
		' country.name as n_name, '
		' id(country) as n_id, '
		' "IS_IN" as r_type,  '
		' (id(region) + "_" + id(country)) as r_id, '
		' id(region) as r_start, '
		' id(country) as r_end '
	)